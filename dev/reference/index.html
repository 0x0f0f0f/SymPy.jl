<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference/API ¬∑ SymPy</title><meta name="title" content="Reference/API ¬∑ SymPy"/><meta property="og:title" content="Reference/API ¬∑ SymPy"/><meta property="twitter:title" content="Reference/API ¬∑ SymPy"/><meta name="description" content="Documentation for SymPy."/><meta property="og:description" content="Documentation for SymPy."/><meta property="twitter:description" content="Documentation for SymPy."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymPy</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Examples</a></li><li><span class="tocitem">SymPy tutorial</span><ul><li><a class="tocitem" href="../Tutorial/">About</a></li><li><a class="tocitem" href="../Tutorial/intro/">Introduction</a></li><li><a class="tocitem" href="../Tutorial/gotchas/">Gotchas</a></li><li><a class="tocitem" href="../Tutorial/basic_operations/">Basic operations</a></li><li><a class="tocitem" href="../Tutorial/simplification/">Simplification</a></li><li><a class="tocitem" href="../Tutorial/calculus/">Calculus</a></li><li><a class="tocitem" href="../Tutorial/solvers/">Solvers</a></li><li><a class="tocitem" href="../Tutorial/matrices/">Matrices</a></li><li><a class="tocitem" href="../Tutorial/manipulation/">Advanced expression  manipulation</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference/API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference/API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference/API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPy/SymPy.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPy/SymPy.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference/API"><a class="docs-heading-anchor" href="#Reference/API">Reference/API</a><a id="Reference/API-1"></a><a class="docs-heading-anchor-permalink" href="#Reference/API" title="Permalink"></a></h1><ul><li><a href="#SymPy.SymPy"><code>SymPy.SymPy</code></a></li><li><a href="#SymPy.ùëÑ"><code>SymPy.ùëÑ</code></a></li><li><a href="#SymPy.False"><code>SymPy.False</code></a></li><li><a href="#SymPy.IM"><code>SymPy.IM</code></a></li><li><a href="#SymPy.PI"><code>SymPy.PI</code></a></li><li><a href="#SymPy.True"><code>SymPy.True</code></a></li><li><a href="#SymPy.oo"><code>SymPy.oo</code></a></li><li><a href="#SymPy.sympy"><code>SymPy.sympy</code></a></li><li><a href="#SymPy.sympy_core"><code>SymPy.sympy_core</code></a></li><li><a href="#SymPy.sympy_matrices"><code>SymPy.sympy_matrices</code></a></li><li><a href="#SymPy.sympy_plotting"><code>SymPy.sympy_plotting</code></a></li><li><a href="#SymPy.zoo"><code>SymPy.zoo</code></a></li><li><a href="#SymPy.Differential"><code>SymPy.Differential</code></a></li><li><a href="#SymPy.Doc"><code>SymPy.Doc</code></a></li><li><a href="#SymPy.SymFunction"><code>SymPy.SymFunction</code></a></li><li><a href="#SymPy.SymMatrix"><code>SymPy.SymMatrix</code></a></li><li><a href="#SymPy.VectorField"><code>SymPy.VectorField</code></a></li><li><a href="#Base.:~-Tuple{Number, SymPy.SymbolicObject}"><code>Base.:~</code></a></li><li><a href="#Base.getindex-Tuple{SymMatrix, Int64, Int64}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{Sym, Vararg{Sym}}"><code>Base.getindex</code></a></li><li><a href="#Base.match-Tuple{Sym, Sym, Vararg{Any}}"><code>Base.match</code></a></li><li><a href="#Base.occursin-Tuple{Any, SymPermutationGroup}"><code>Base.occursin</code></a></li><li><a href="#Base.replace-Tuple{Sym, Sym, Function}"><code>Base.replace</code></a></li><li><a href="#CommonSolve.solve-Tuple{}"><code>CommonSolve.solve</code></a></li><li><a href="#SymPy.Introspection.args-Tuple{Sym}"><code>SymPy.Introspection.args</code></a></li><li><a href="#SymPy.Introspection.func-Tuple{Sym}"><code>SymPy.Introspection.func</code></a></li><li><a href="#SymPy.Introspection.funcname-Tuple{Sym}"><code>SymPy.Introspection.funcname</code></a></li><li><a href="#SymPy.N-Tuple{Sym}"><code>SymPy.N</code></a></li><li><a href="#SymPy.N-Tuple{Sym, Int64}"><code>SymPy.N</code></a></li><li><a href="#SymPy.Permutation-Tuple{Any}"><code>SymPy.Permutation</code></a></li><li><a href="#SymPy.PermutationGroup-Tuple"><code>SymPy.PermutationGroup</code></a></li><li><a href="#SymPy.Wild-Tuple{AbstractString}"><code>SymPy.Wild</code></a></li><li><a href="#SymPy.ask-Tuple{Sym, Vararg{Any}}"><code>SymPy.ask</code></a></li><li><a href="#SymPy.doit-Tuple{T} where T&lt;:SymPy.SymbolicObject"><code>SymPy.doit</code></a></li><li><a href="#SymPy.dsolve-Tuple{Any, Vararg{Any}}"><code>SymPy.dsolve</code></a></li><li><a href="#SymPy.elements-Tuple{Sym}"><code>SymPy.elements</code></a></li><li><a href="#SymPy.free_symbols-Union{Tuple{Union{Vector{T}, T}}, Tuple{T}} where T&lt;:SymPy.SymbolicObject"><code>SymPy.free_symbols</code></a></li><li><a href="#SymPy.import_from-Union{Tuple{Any}, Tuple{N}, Tuple{Any, Any}} where N"><code>SymPy.import_from</code></a></li><li><a href="#SymPy.import_sympy-Tuple{}"><code>SymPy.import_sympy</code></a></li><li><a href="#SymPy.jprint-Tuple{SymPy.SymbolicObject}"><code>SymPy.jprint</code></a></li><li><a href="#SymPy.lambdify"><code>SymPy.lambdify</code></a></li><li><a href="#SymPy.nonlinsolve-Tuple{}"><code>SymPy.nonlinsolve</code></a></li><li><a href="#SymPy.plot_implicit-Tuple{Any, Vararg{Any}}"><code>SymPy.plot_implicit</code></a></li><li><a href="#SymPy.plot_parametric_surface"><code>SymPy.plot_parametric_surface</code></a></li><li><a href="#SymPy.refine-Tuple{Any, Vararg{Any}}"><code>SymPy.refine</code></a></li><li><a href="#SymPy.simplify-Tuple{Any, Vararg{Any}}"><code>SymPy.simplify</code></a></li><li><a href="#SymPy.subs-Union{Tuple{T}, Tuple{T, Tuple{Any, Any}}} where T&lt;:SymPy.SymbolicObject"><code>SymPy.subs</code></a></li><li><a href="#SymPy.symbols-Tuple{AbstractString}"><code>SymPy.symbols</code></a></li><li><a href="#SymPy.walk_expression-Tuple{Any}"><code>SymPy.walk_expression</code></a></li><li><a href="#SymPy.@symfuns-Tuple"><code>SymPy.@symfuns</code></a></li><li><a href="#SymPy.@syms-Tuple"><code>SymPy.@syms</code></a></li><li><a href="#SymPy.@vars-Tuple"><code>SymPy.@vars</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:~-Tuple{Number, SymPy.SymbolicObject}" href="#Base.:~-Tuple{Number, SymPy.SymbolicObject}"><code>Base.:~</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhs ~ rhs</code></pre><p>Specify an equation.</p><p>Alternative syntax to <code>Eq(lhs, rhs)</code> or <code>lhs ‚©µ rhs</code> (<code>\Equal[tab]</code>) following <code>Symbolics.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/mathfuns.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{Sym, Vararg{Sym}}" href="#Base.getindex-Tuple{Sym, Vararg{Sym}}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x[i]</code></pre><p>Some SymPy Python objects have index notation provided for them through <code>__getitem__</code>. This allows Julia&#39;s <code>getindex</code> to dispatch to Python&#39;s <code>__getitem__</code>. The index (indices) must be symbolic. This will use 0-based indexing, as it is a simple pass through to Python.</p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; i,j = sympy.symbols(&quot;i j&quot;, integer=True)
(i, j)

julia&gt; x = sympy.IndexedBase(&quot;x&quot;)
x

julia&gt; a = sympy.Sum(x[i], (i, 1, j))
  j
 ___
 ‚ï≤
  ‚ï≤
  ‚ï±   x[i]
 ‚ï±
 ‚Äæ‚Äæ‚Äæ
i = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{SymMatrix, Int64, Int64}" href="#Base.getindex-Tuple{SymMatrix, Int64, Int64}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">M[i,j]</code></pre><p>Define <code>getindex</code> for SymPy&#39;s <code>ImmutableMatrix</code> class.</p><p>SymMatrix is 0-based, like python, not Julia. Use Matrix{Sym} for that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/matrix.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.match-Tuple{Sym, Sym, Vararg{Any}}" href="#Base.match-Tuple{Sym, Sym, Vararg{Any}}"><code>Base.match</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">match(pattern, expression, ...)</code></pre><p>Match a pattern against an expression; returns a dictionary of matches.</p><p>If a match is unsuccesful, returns an <em>empty</em> dictionary. (SymPy returns &quot;nothing&quot;)</p><p>The order of the arguments follows <code>Julia</code>&#39;s <code>match</code> function, not <code>sympy.match</code>, which can be used directly, otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/patternmatch.jl#L14-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.occursin-Tuple{Any, SymPermutationGroup}" href="#Base.occursin-Tuple{Any, SymPermutationGroup}"><code>Base.occursin</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>occursin(x, G::SymPermutationGroup)</p><p>Does G contain x. (In SymPy, this is `contains.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/permutations.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.replace-Tuple{Sym, Sym, Function}" href="#Base.replace-Tuple{Sym, Sym, Function}"><code>Base.replace</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace(expression, pattern, value, ...)
replace(expression, pattern =&gt; value; kwargs...)</code></pre><p>In the expression replace a mathcing pattern with the value. Returns the modified expression.</p><p><strong>Extended help</strong></p><p>From: <a href="http://docs.sympy.org/dev/modules/core.html">SymPy Docs</a></p><p>Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, <code>simultaneous</code> can be set to <code>false</code>. In addition, if an expression containing more than one <code>Wild</code> symbol is being used to match subexpressions and the <code>exact</code> flag is <code>true</code>, then the match will only succeed if non-zero values are received for each <code>Wild</code> that appears in the match pattern.</p><p>Differences from SymPy:</p><ul><li><p>&quot;types&quot; are specified via calling <code>func</code> on the head of an expression: <code>func(sin(x))</code> -&gt; <code>sin</code>, or directly through <code>sympy.sin</code></p></li><li><p>functions are supported, but only with <code>PyCall</code> commands.</p></li></ul><p>Examples (from the SymPy docs)</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; x, y, z = symbols(&quot;x, y, z&quot;)
(x, y, z)

julia&gt; f = log(sin(x)) + tan(sin(x^2)); string(f) # `string(f)` only so doctest can run
&quot;log(sin(x)) + tan(sin(x^2))&quot;
</code></pre><p><strong>&quot;type&quot; -&gt; &quot;type&quot;</strong></p><p>Types are specified through <code>func</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; func = SymPy.Introspection.func
func (generic function with 1 method)

julia&gt; replace(f, func(sin(x)), func(cos(x))) |&gt; string  # type -&gt; type
&quot;log(cos(x)) + tan(cos(x^2))&quot;

julia&gt; replace(f, sympy.sin, sympy.cos)  |&gt;  string
&quot;log(cos(x)) + tan(cos(x^2))&quot;

julia&gt; sin(x).replace(sympy.sin, sympy.cos, map=true)
(cos(x), Dict{Any, Any}(sin(x) =&gt; cos(x)))
</code></pre><p>The <code>func</code> function finds the head of an expression (<code>sin</code> and <code>cos</code> above). This could also have been written (perhaps more directly) as:</p><pre><code class="language-julia-repl hljs">julia&gt; replace(f, sympy.sin, sympy.cos) |&gt; string
&quot;log(cos(x)) + tan(cos(x^2))&quot;
</code></pre><p><strong>&quot;type&quot; -&gt; &quot;function&quot;</strong></p><p>To replace with a more complicated function, requires some assistance from <code>Python</code>, as an anonymous function must be defined witin Python, not <code>Julia</code>:</p><pre><code class="language-julia hljs">julia&gt; import PyCall

julia&gt; ## Anonymous function a -&gt; sin(2a)
       PyCall.py&quot;&quot;&quot;
       from sympy import sin, Mul
       def anonfn(*args):
           return sin(2*Mul(*args))
       &quot;&quot;&quot;)


julia&gt; replace(f, sympy.sin, PyCall.py&quot;anonfn&quot;)
                   ‚éõ   ‚éõ   2‚éû‚éû
log(sin(2‚ãÖx)) + tan‚éùsin‚éù2‚ãÖx ‚é†‚é†</code></pre><p><strong>&quot;pattern&quot; -&gt; &quot;expression&quot;</strong></p><p>Using &quot;<code>Wild</code>&quot; variables allows a pattern to be replaced by an expression:</p><pre><code class="language-julia-repl hljs">julia&gt; a, b = Wild(&quot;a&quot;), Wild(&quot;b&quot;)
(a_, b_)

julia&gt; replace(f, sin(a), tan(2a)) |&gt; string
&quot;log(tan(2*x)) + tan(tan(2*x^2))&quot;

julia&gt; replace(f, sin(a), tan(a/2)) |&gt; string
&quot;log(tan(x/2)) + tan(tan(x^2/2))&quot;

julia&gt; f.replace(sin(a), a) |&gt; string
&quot;log(x) + tan(x^2)&quot;

julia&gt; (x*y).replace(a*x, a)
y
</code></pre><p>In the SymPy docs we have:</p><p>Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols.&quot;</p><pre><code class="language-julia-repl hljs">julia&gt; replace(2x + y, a*x+b, b-a)  # y - 2
y - 2

julia&gt; replace(2x + y, a*x+b, b-a, exact=false)  # y + 2/x
    2
y + ‚îÄ
    x</code></pre><p><strong>&quot;pattern&quot; -&gt; &quot;func&quot;</strong></p><p>The function is redefined, as a fixed argument is passed:</p><pre><code class="language-julia hljs">julia&gt; PyCall.py&quot;&quot;&quot;
       from sympy import sin
       def anonfn(a):
           return sin(2*a)
       &quot;&quot;&quot;

julia&gt; replace(f, sin(a), PyCall.py&quot;anonfn&quot;)
                   ‚éõ   ‚éõ   2‚éû‚éû
log(sin(2‚ãÖx)) + tan‚éùsin‚éù2‚ãÖx ‚é†‚é†</code></pre><p><strong>&quot;func&quot; -&gt; &quot;func&quot;</strong></p><pre><code class="language-julia hljs">
julia&gt; PyCall.py&quot;&quot;&quot;
       def fn1(expr):
           return expr.is_Number

       def fn2(expr):
           return expr**2
       &quot;&quot;&quot;

julia&gt; replace(2*sin(x^3), PyCall.py&quot;fn1&quot;, PyCall.py&quot;fn2&quot;)
     ‚éõ 9‚éû
4‚ãÖsin‚éùx ‚é†</code></pre><pre><code class="language-julia hljs">julia&gt; PyCall.py&quot;&quot;&quot;
       def fn1(x):
           return x.is_Mul

       def fn2(x):
           return 2*x
       &quot;&quot;&quot;

julia&gt; replace(x*(x*y + 1), PyCall.py&quot;fn1&quot;, PyCall.py&quot;fn2&quot;)
2‚ãÖx‚ãÖ(2‚ãÖx‚ãÖy + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/patternmatch.jl#L29-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve-Tuple{}" href="#CommonSolve.solve-Tuple{}"><code>CommonSolve.solve</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve</code></pre><p>Use <code>solve</code> to solve algebraic equations.</p><p>Examples:</p><pre><code class="language-julia hljs">julia&gt; using SymPy

julia&gt; @syms x y a b c d
(x, y, a, b, c, d)

julia&gt; solve(x^2 + 2x + 1, x) # [-1]
1-element Vector{Sym}:
 -1

julia&gt; solve(x^2 + 2a*x + a^2, x) # [-a]
1-element Vector{Sym}:
 -a

julia&gt; solve([a*x + b*y-3, c*x + b*y - 1], [x,y]) # Dict(y =&gt; (a - 3*c)/(b*(a - c)),x =&gt; 2/(a - c))
Dict{Any, Any} with 2 entries:
  y =&gt; (a - 3*c)/(a*b - b*c)
  x =&gt; 2/(a - c)
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A very nice example using <code>solve</code> is a <a href="https://newptcai.github.io/euclidean-plane-geometry-with-julia.html">blog</a> entry on <a href="https://en.wikipedia.org/wiki/Napoleon%27s_theorem">Napolean&#39;s theorem</a> by Xing Shi Cai.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/mathfuns.jl#L101-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.N-Tuple{Sym, Int64}" href="#SymPy.N-Tuple{Sym, Int64}"><code>SymPy.N</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">N(x::Sym, digits::Int)</code></pre><p><code>N</code> can take a precision argument, whichm when given as an integer greater than 16, we try to match the digits of accuracy using <code>BigFloat</code> precision on conversions to floating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/numbers.jl#L271-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.N-Tuple{Sym}" href="#SymPy.N-Tuple{Sym}"><code>SymPy.N</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">N(ex)</code></pre><p>Convert a <code>Sym</code> value to a numeric Julian value.</p><p>In SymPy, <code>N(ex, options...)</code> is identifcal to <code>ex.evalf(options...)</code> and is used to convert expressions into floating-point approximations. A positional precision argument indicates the number of digits, keyword arguments <code>chop</code> can be used to trim floating point roundoff errors and <code>subs</code> for free variable substitution prior to conversions.</p><p>For example, symbolic roots can be computed numerically, even if not available symbolically, by calling <code>N</code> on the values.</p><p>Using <code>SymPy</code> within <code>Julia</code> makes having two such functions useful:</p><ul><li>one to do the equivalent of SymPy&#39;s <code>evalf</code> call</li><li>one to convert these expressions back into <code>Julia</code> objects (like <code>convert(T,  ex)</code>)</li></ul><p>We use <code>N</code> to return a <code>Julia</code> object and <code>evalf</code> to return a symbolic object. The type of <code>Julia</code> object is heurisitically identified.</p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; x = Sym(&quot;x&quot;)
x

julia&gt; p = subs(x, x, pi)
œÄ

julia&gt; N(p)                            # float version of pi
œÄ = 3.1415926535897...

julia&gt; p.evalf(60)                     # 60 digits of pi, as a symbolic value
3.14159265358979323846264338327950288419716939937510582097494

julia&gt; N(p, 60)                        # when a precision is given, &quot;Big&quot; values are returned
3.141592653589793238462643383279502884197169399375105820974939

julia&gt; r = subs(x,x,1.2)
1.20000000000000

julia&gt; N(r)                            # float
1.2

julia&gt; q = subs(x, x, 1//2)
1/2

julia&gt; N(q)                            # 1//2
1//2

julia&gt; z = solve(x^2 + 1)[1]           # -‚Öà
-‚Öà

julia&gt; N(z)                            # 0 - 1im
0 - 1im

julia&gt; z.evalf()
-1.0‚ãÖ‚Öà

julia&gt; rts = solve(x^5 - x + 1)
5-element Vector{Sym}:
 CRootOf(x^5 - x + 1, 0)
 CRootOf(x^5 - x + 1, 1)
 CRootOf(x^5 - x + 1, 2)
 CRootOf(x^5 - x + 1, 3)
 CRootOf(x^5 - x + 1, 4)

julia&gt; [r.evalf() for r in rts]          # numeric solutions to quintic
5-element Vector{Sym}:
                       -1.16730397826142
 -0.181232444469875 - 1.08395410131771‚ãÖ‚Öà
 -0.181232444469875 + 1.08395410131771‚ãÖ‚Öà
 0.764884433600585 - 0.352471546031726‚ãÖ‚Öà
 0.764884433600585 + 0.352471546031726‚ãÖ‚Öà

julia&gt; [N(r) for r in rts]
5-element Vector{Number}:
                     -1.167303978261418684256045899854842180720560371525489039140082449275651903429536
 -0.18123244446987538 - 1.0839541013177107im
 -0.18123244446987538 + 1.0839541013177107im
   0.7648844336005847 - 0.35247154603172626im
   0.7648844336005847 + 0.35247154603172626im</code></pre><p><code>N</code> returns the value unchanged when it has free symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/numbers.jl#L75-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.Permutation-Tuple{Any}" href="#SymPy.Permutation-Tuple{Any}"><code>SymPy.Permutation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Permutation(args...)</code></pre><p>This module mostly implements SymPy&#39;s <a href="http://docs.sympy.org/latest/modules/combinatorics/permutations.html">Permutation</a> module.</p><p>A permuation can be represented in different ways. Here a permutation is a reaarangment of the values 0, 1, ..., n. For example, the mapping <code>0-&gt;2, 1-&gt;3, 2-&gt;0, 3-&gt;1</code> can be presented by a vector: <code>sigma = [2,3,0,1]</code> where <code>sigma[i] = j</code> when <code>i -&gt; j</code>. Otheriwse, it can be presented as a product of cycles: <code>(0 2)(1 3)</code> which reads 0 goes to 2 which goes to 0 (wrapping) and 1 goes to 3 and 3 goes to 1.</p><p>Either representation can be passed through the <code>Permutation</code> constructor.</p><p>For the vector notation ‚Äì 0-based ‚Äì it is passed directly to the constructor:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; p = Permutation([2,3,0,1])
(0 2)(1 3)
</code></pre><p>If a range describes a permutation, it can be used as well:</p><pre><code class="language-julia-repl hljs">julia&gt; id = Permutation(10:-1:0)
(0 10)(1 9)(2 8)(3 7)(4 6)
</code></pre><p>Cycle notation can more compactly describe a permuation, it can be passed in as a container of cycles specified through tuples or vectors:</p><pre><code class="language-julia-repl hljs">julia&gt;  p = Permutation([(0,2), (1,3)])
(0 2)(1 3)
</code></pre><p>The latter can be be expresed more quickly as</p><pre><code class="language-julia-repl hljs">julia&gt; p = Permutation(0,2)(1,3)
(0 2)(1 3)
</code></pre><p>This works as a single cycle can be passed to the <code>Permutation</code> constructor with values separated by commas and the &quot;call&quot; method for <code>Permuation</code> objects is overloaded: for a single argument, the mapping <code>i -&gt; j</code> is created (also the notation <code>i^p</code> returns this) <em>but</em> if more than one argument is given, a cycle is created and multiplied on the <em>right</em> by <code>p</code>, so that the above becomes <code>(0,2) * (1,3)</code>.</p><p>Here are two permutations forming the symmetries of square, naturally represented in the two ways:</p><pre><code class="language-julia-repl hljs">julia&gt; flip = Permutation([[0,1],[2,3]])  # or Permutation(0,1)(2,3)
(0 1)(2 3)

julia&gt; rotate = Permutation([1,2,3,0])    # or Permutation(0,1,2,3) in cycle notation
(0 1 2 3)
</code></pre><p>Operations on permutations include:</p><ul><li>a function call, <code>p(i)</code> to recover <code>j</code> where <code>i -&gt; j</code>, also <code>i^p</code>.</li><li><code>*</code> for multiplication. The convention is <code>(p*q)(i) = q(p(i))</code> or with the <code>^</code> notation: <code>i^(p*q) = (i^p)^q</code>.</li><li><code>+</code> for multiplication when <code>p</code> and <code>q</code> commute, where a check on commuting is performed.</li><li><code>inv</code> for the inverse permutation.</li><li><code>/</code>, where <code>p/q</code> is <code>p * inv(q)</code>.</li><li><code>p^n</code> for powers. We have <code>inv(p) = p^(-1)</code> and <code>p^order(p)</code> is the identity.</li><li><code>p^q</code> for conjugate, defined by <code>inv(q) * p * q</code>.</li></ul><p>We can see that a flip is an involution through:</p><pre><code class="language-julia-repl hljs">julia&gt; flip^2  # the identity
()
</code></pre><p>whereas a rotation is not (as it has order 4)</p><pre><code class="language-julia-repl hljs">julia&gt; rotate * rotate
(0 2)(1 3)

julia&gt; rotate.order()
4
</code></pre><p>These two operations do not commute:</p><pre><code class="language-julia-repl hljs">julia&gt; flip * rotate
(0 2)
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rotate * flip  # (1 3)
(1 3)
</code></pre><p>We can see this is the correct mapping <code>1 -&gt; 3</code> with</p><pre><code class="language-julia-repl hljs">julia&gt; (1^rotate)^flip, 1^(rotate*flip), flip(rotate(1))
(3, 3, 3)
</code></pre><p>We can check that <code>flip</code> and <code>rotate^2</code> do commute:</p><pre><code class="language-julia-repl hljs">julia&gt; id = Permutation(3)   # (n) is the identify
()

julia&gt; flip.commutator(rotate^2) == id
true
</code></pre><p>The conjugate for flip and rotate does the inverse of the flip, then rotates, then flips:</p><pre><code class="language-julia-repl hljs">julia&gt; rotate^flip
(0 3 2 1)
</code></pre><p>This is different than <code>flip^rotate</code>. As <code>flip</code> commutes with <code>rotate^2</code> this will return <code>rotate^2</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; (rotate^2)^flip
(0 2)(1 3)
</code></pre><div class="admonition is-info"><header class="admonition-header">Differences</header><div class="admonition-body"><p>There is no support currently for the <code>Cycle</code> class</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/permutations.jl#L6-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.PermutationGroup-Tuple" href="#SymPy.PermutationGroup-Tuple"><code>SymPy.PermutationGroup</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PermutationGroup()</code></pre><p>Create Permutation group from group generators</p><p>A PermutationGroup is one generated by a collection of permutations.</p><p>Some pre-defined groups are built-in:</p><ul><li><code>SymmetricgGroup(n)</code>: S_n or all symmetries of an n-gon</li><li><code>CyclicGroup</code>: the group Z_n</li><li><code>DihedralGroup</code>: Group formed by a flip and rotation</li><li><code>AlternativeGroup</code>: Subgroup of S_n of even elements</li><li><code>AbelianGroup</code>: Returns the direct product of cyclic groups with the given orders.</li></ul><p>Differences:</p><ul><li>use <code>collect(generate(G))</code> in place of <code>list(G.generate())</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/permutations.jl#L210-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.Wild-Tuple{AbstractString}" href="#SymPy.Wild-Tuple{AbstractString}"><code>SymPy.Wild</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wild(x)</code></pre><p>create a &quot;wild card&quot; for pattern matching</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/patternmatch.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.ask-Tuple{Sym, Vararg{Any}}" href="#SymPy.ask-Tuple{Sym, Vararg{Any}}"><code>SymPy.ask</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ask(query)</code></pre><p>Returns <code>true</code>, <code>false</code>, or <code>nothing</code>; <a href="https://docs.sympy.org/dev/modules/assumptions/ask.html">ask</a></p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; @vars x y integer=true
(x, y)

julia&gt; ask(ùëÑ.integer(x*y), And(ùëÑ.integer(x), ùëÑ.integer(y)))
true

julia&gt; ## really slow isprime:
       filter(x -&gt; ask(ùëÑ.prime(x)), 1:10)
4-element Vector{Int64}:
 2
 3
 5
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/assumptions.jl#L12-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.doit-Tuple{T} where T&lt;:SymPy.SymbolicObject" href="#SymPy.doit-Tuple{T} where T&lt;:SymPy.SymbolicObject"><code>SymPy.doit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>doit</code> evaluates objects that are not evaluated by default.</p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; @syms x f()
(x, f)

julia&gt; D = Differential(x)
Differential(x)

julia&gt; df = D(f(x))
d
‚îÄ‚îÄ(f(x))
dx

julia&gt; dfx = subs(df, (f(x), x^2))
d ‚éõ 2‚éû
‚îÄ‚îÄ‚éùx ‚é†
dx

julia&gt; doit(dfx)
2‚ãÖx</code></pre><p>Set <code>deep=true</code> to apply <code>doit</code> recursively to force evaluation of nested expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms g()
(g,)

julia&gt; dgfx = g(dfx)
 ‚éõd ‚éõ 2‚éû‚éû
g‚éú‚îÄ‚îÄ‚éùx ‚é†‚éü
 ‚éùdx    ‚é†

julia&gt; doit(dgfx)
 ‚éõd ‚éõ 2‚éû‚éû
g‚éú‚îÄ‚îÄ‚éùx ‚é†‚éü
 ‚éùdx    ‚é†

julia&gt; doit(dgfx, deep=true)
g(2‚ãÖx)</code></pre><p>There is also a curried form of <code>doit</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; dfx |&gt; doit
2‚ãÖx

julia&gt; dgfx |&gt; doit(deep=true)
g(2‚ãÖx)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L145-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.dsolve-Tuple{Any, Vararg{Any}}" href="#SymPy.dsolve-Tuple{Any, Vararg{Any}}"><code>SymPy.dsolve</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>dsolve(eqn, var, args..,; ics=nothing, kwargs...)</p><p>Call <code>sympy.dsolve</code>.</p><p>The initial conditions are specified with a dictionary.</p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; @syms Œ±, x, f(), g()
(Œ±, x, f, g)

julia&gt; ‚àÇ = Differential(x)
Differential(x)

julia&gt; eqn = ‚àÇ(f(x)) ~ Œ± * x
d
‚îÄ‚îÄ(f(x)) = x‚ãÖŒ±
dx</code></pre><pre><code class="language-julia hljs">julia&gt; dsolve(eqn)
             2
            x ‚ãÖŒ±
f(x) = C‚ÇÅ + ‚îÄ‚îÄ‚îÄ‚îÄ
             2</code></pre><pre><code class="language-julia-repl hljs">julia&gt; dsolve(eqn(Œ±=&gt;2); ics=Dict(f(0)=&gt;1)) |&gt; print # fill in parameter, initial condition
Eq(f(x), x^2 + 1)

julia&gt; eqn = ‚àÇ(‚àÇ(f(x))) ~ -f(x); print(eqn)
Eq(Derivative(f(x), (x, 2)), -f(x))

julia&gt; dsolve(eqn)
f(x) = C‚ÇÅ‚ãÖsin(x) + C‚ÇÇ‚ãÖcos(x)

julia&gt; dsolve(eqn; ics = Dict(f(0)=&gt;1, ‚àÇ(f)(0) =&gt; -1))
f(x) = -sin(x) + cos(x)

julia&gt; eqn = ‚àÇ(‚àÇ(f(x))) - f(x) - exp(x);

julia&gt; dsolve(eqn, ics=Dict(f(0) =&gt; 1, f(1) =&gt; Sym(1//2))) |&gt; print # not just 1//2
Eq(f(x), (x/2 + (-exp(2) - 2 + E)/(-2 + 2*exp(2)))*exp(x) + (-E + 3*exp(2))*exp(-x)/(-2 + 2*exp(2)))</code></pre><p>Systems. Use a tuple, not a vector, of equations, as such are now deprecated by SymPy.</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x() y() t g
(x, y, t, g)

julia&gt; ‚àÇ = Differential(t)
Differential(t)

julia&gt; eqns = (‚àÇ(x(t)) ~ y(t), ‚àÇ(y(t)) ~ x(t))
(Eq(Derivative(x(t), t), y(t)), Eq(Derivative(y(t), t), x(t)))

julia&gt; dsolve(eqns)
2-element Vector{Sym}:
 Eq(x(t), -C1*exp(-t) + C2*exp(t))
  Eq(y(t), C1*exp(-t) + C2*exp(t))

julia&gt; dsolve(eqns, ics = Dict(x(0) =&gt; 1, y(0) =&gt; 2))
2-element Vector{Sym}:
 Eq(x(t), 3*exp(t)/2 - exp(-t)/2)
 Eq(y(t), 3*exp(t)/2 + exp(-t)/2)

julia&gt; eqns = (‚àÇ(‚àÇ(x(t))) ~ 0, ‚àÇ(‚àÇ(y(t))) ~ -g)
(Eq(Derivative(x(t), (t, 2)), 0), Eq(Derivative(y(t), (t, 2)), -g))

julia&gt; dsolve(eqns)  # can&#39;t solve for initial conditions though! (NotAlgebraic)
2-element Vector{Sym}:
           x(t) = C‚ÇÅ + C‚ÇÇ‚ãÖt
 Eq(y(t), C3 + C4*t - g*t^2/2)

julia&gt; @syms t x() y()
(t, x, y)

julia&gt; eq = (‚àÇ(x)(t) ~ x(t)*y(t)*sin(t), ‚àÇ(y)(t) ~ y(t)^2 * sin(t))
(Eq(Derivative(x(t), t), x(t)*y(t)*sin(t)), Eq(Derivative(y(t), t), y(t)^2*sin(t)))</code></pre><pre><code class="language-julia hljs">julia&gt; dsolve(eq)  # returns a set to be `collect`ed:
PyObject {Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}</code></pre><pre><code class="language-julia hljs">julia&gt; dsolve(eq) |&gt; collect
2-element Vector{Any}:
 Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t)))
               Eq(y(t), -1/(C1 - cos(t)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/mathfuns.jl#L145-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.elements-Tuple{Sym}" href="#SymPy.elements-Tuple{Sym}"><code>SymPy.elements</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elements(s)</code></pre><p>return elements of a set s as an array, unlike <code>convert(Set,s)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/sets.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.free_symbols-Union{Tuple{Union{Vector{T}, T}}, Tuple{T}} where T&lt;:SymPy.SymbolicObject" href="#SymPy.free_symbols-Union{Tuple{Union{Vector{T}, T}}, Tuple{T}} where T&lt;:SymPy.SymbolicObject"><code>SymPy.free_symbols</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">free_symbols(ex)
free_symbols(ex::Vector{Sym})</code></pre><p>Return vector of free symbols of expression or vector of expressions. The results are orderded by <code>sortperm(string.(fs))</code>.</p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; @syms x y z a
(x, y, z, a)

julia&gt; free_symbols(2*x + a*y) # [a, x, y]
3-element Vector{Sym}:
 a
 x
 y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L394-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.import_from-Union{Tuple{Any}, Tuple{N}, Tuple{Any, Any}} where N" href="#SymPy.import_from-Union{Tuple{Any}, Tuple{N}, Tuple{Any, Any}} where N"><code>SymPy.import_from</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_from(module, meths; kwargs...)</code></pre><p>Import methods from a python module. Implements functionality  of <code>from module import function</code> in  Python.</p><ul><li><code>module</code>: a python module, such as <code>sympy</code></li><li><code>meths</code>: nothing or a tuple of symbols to import. If <code>nothing</code>, then all member functions of the module are imported (but not constructors or other objects)</li><li><code>Ms</code>: additional Julia Modules to import from. By default, a few base modules are searched for to avoid namespace collisions.</li><li><code>typ</code>: a symbol indicating variable type for first argument that the new function should be restricted to. For most, the default, <code>:SymbolicObject</code> will be appropriate</li><li><code>exclude</code>: when importing all (<code>meths=nothing</code>), this can be used to avoid importing some methods by name. The default has a few to avoid.</li></ul><p>Examples:</p><pre><code class="nohighlight hljs">import_from(sympy)  # bring in functions from sympy (done `import_sympy`)
import_from(sympy, (:sin, :cos))  # just bring in a few methods
import_from(sympy , (:Wild,), typ=:Any) # Allows `Wild(&quot;x&quot;)`
#
import PyCall
PyCall.pyimport_conda(&quot;sympy.physics.wigner&quot;, &quot;sympy&quot;)
import_from(sympy.physics.wigner)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L319-L342">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.import_sympy-Tuple{}" href="#SymPy.import_sympy-Tuple{}"><code>SymPy.import_sympy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_sympy</code></pre><p>This method imports all functions from <code>mpmath</code> and a priviledged set of functions from <code>sympy</code>, as well as the relational operators.</p><p>These functions are narrowed on their first argument being of type <code>SymbolicObject</code>.</p><p>A few modules are checked for namespace collisions.</p><p>If a function naturally takes an non-Symbolic argument as a first argument, then it can be qualified: e.g. <code>sympy.sin(2)</code> (as opposed to <code>sin(Sym(2))</code>).</p><p>If a constructor is needed (which is not a function) then it must be qualified. (E.g. <code>sympy.Function(&quot;F&quot;)</code>, though for this particular case, there is <code>SymFunction</code> defined for convenience.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L226-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.jprint-Tuple{SymPy.SymbolicObject}" href="#SymPy.jprint-Tuple{SymPy.SymbolicObject}"><code>SymPy.jprint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>create basic printed output</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/types.jl#L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.lambdify" href="#SymPy.lambdify"><code>SymPy.lambdify</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lambdify(ex, vars=free_symbols();
         fns=Dict(), values=Dict, use_julia_code=false,
         invoke_latest=true)</code></pre><p>Take a symbolic expression and return a <code>Julia</code> function or expression to build a function.</p><ul><li><p><code>ex::Sym</code> a symbolic expression with 0, 1, or more free symbols</p></li><li><p><code>vars</code> a container of symbols to use for the function arguments. The default is <code>free_symbols</code> which has a specific ordering. Specifying <code>vars</code> allows this default ordering of arguments to be customized. If <code>vars</code> is empty, such as when the symbolic expression has <em>no</em> free symbols, a variable arg constant function is returned.</p></li><li><p><code>fns::Dict</code>, <code>vals::Dict</code>: Dictionaries that allow customization of the function that walks the expression <code>ex</code> and creates the corresponding AST for a Julia expression. See <code>SymPy.fn_map</code> and <code>SymPy.val_map</code> for the default mappings of sympy functions and values into <code>Julia</code>&#39;s AST.</p></li><li><p><code>use_julia_code::Bool</code>: use SymPy&#39;s conversion to an expression, the default is <code>false</code></p></li><li><p><code>invoke_latest=true</code>: if <code>true</code> will call <code>eval</code> and <code>Base.invokelatest</code> to return a function that should not have any world age issue. If <code>false</code> will return a Julia expression that can be <code>eval</code>ed to produce a function.</p></li></ul><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; @syms x y z
(x, y, z)

julia&gt; ex = x^2 * sin(x)
 2
x ‚ãÖsin(x)

julia&gt; fn = lambdify(ex);

julia&gt; fn(pi)
0.0

julia&gt; ex = x + 2y + 3z
x + 2‚ãÖy + 3‚ãÖz

julia&gt; fn = lambdify(ex);

julia&gt; fn(1,2,3) # order is by free_symbols
14

julia&gt; ex(x=&gt;1, y=&gt;2, z=&gt;3)
14

julia&gt; fn = lambdify(ex, (y,x,z));

julia&gt; fn(1,2,3)
13</code></pre><p>!!! Note:</p><p>The default produces slower functions due to the calls to <code>eval</code> and <code>Base.invokelatest</code>.  In the following <code>g2</code> (which, as seen, requires additional work to compute) is as fast as calling <code>f</code> (on non symbolic types), whereas <code>g1</code> is an order of magnitude slower in this example.</p><pre><code class="nohighlight hljs">julia&gt; @vars x
(x,)

julia&gt; f(x) = exp(cot(x))
f (generic function with 1 method)

julia&gt; g1 = lambdify(f(x))
#88 (generic function with 1 method)

julia&gt; ex = lambdify(f(x), invoke_latest=false)
:(function var&quot;##271&quot;(x)
      exp(cot(x))
  end)

julia&gt; @eval g2(x) = ($ex)(x)
g2 (generic function with 1 method)</code></pre><p>An alternative, say, is to use <code>GeneralizedGenerated</code>&#39;s <code>mk_function</code>, as follows:</p><pre><code class="nohighlight hljs">julia&gt; using GeneralizedGenerated

julia&gt; body = convert(Expr, f(x))
:(exp(cot(x)))

julia&gt; g3 = mk_function((:x,), (), body)
function = (x;) -&gt; begin
    (Main).exp((Main).cot(x))
end</code></pre><p>This function will be about 2-3 times slower than <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/lambdify.jl#L150-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.nonlinsolve-Tuple{}" href="#SymPy.nonlinsolve-Tuple{}"><code>SymPy.nonlinsolve</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonlinsolve</code></pre><p>Note: if passing variables in use a tuple (e.g., <code>(x,y)</code>) and <em>not</em> a vector (e.g., <code>[x,y]</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/mathfuns.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.plot_implicit-Tuple{Any, Vararg{Any}}" href="#SymPy.plot_implicit-Tuple{Any, Vararg{Any}}"><code>SymPy.plot_implicit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Plot an implicit equation</p><pre><code class="nohighlight hljs">@syms x y
plot_implicit(Eq(x^2+ y^2,3), (x, -2, 2), (y, -2, 2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/plot_recipes.jl#L246-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.plot_parametric_surface" href="#SymPy.plot_parametric_surface"><code>SymPy.plot_parametric_surface</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Render a parametrically defined surface plot.</p><p>Example:</p><pre><code class="nohighlight hljs">@syms u, v
plot_parametric_surface((u*v,u-v,u+v), (u,0,1), (v,0,1))</code></pre><p>This uses <code>PyPlot</code>, not <code>Plots</code> for now.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/plot_recipes.jl#L219-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.refine-Tuple{Any, Vararg{Any}}" href="#SymPy.refine-Tuple{Any, Vararg{Any}}"><code>SymPy.refine</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> refine</code></pre><p>Simplify an expression using assumptions; <a href="https://docs.sympy.org/dev/modules/assumptions/refine.html">refine</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/assumptions.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.simplify-Tuple{Any, Vararg{Any}}" href="#SymPy.simplify-Tuple{Any, Vararg{Any}}"><code>SymPy.simplify</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify</code></pre><p>SymPy has dozens of functions to perform various kinds of simplification. There is also one general function called <code>simplify</code> that attempts to apply all of these functions in an intelligent way to arrive at the simplest form of an expression. (See <a href="https://docs.sympy.org/latest/tutorial/simplification.html">Simplification</a> for details on <code>simplify</code> and other related functionality).</p><p>For non-symbolic expressions, <code>simplify</code> returns its first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L207-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.subs-Union{Tuple{T}, Tuple{T, Tuple{Any, Any}}} where T&lt;:SymPy.SymbolicObject" href="#SymPy.subs-Union{Tuple{T}, Tuple{T, Tuple{Any, Any}}} where T&lt;:SymPy.SymbolicObject"><code>SymPy.subs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>subs</code> is used to subsitute a value in an expression with another value. Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; x,y = symbols(&quot;x,y&quot;)
(x, y)

julia&gt; ex = (x-y)*(x+2y)
(x - y)‚ãÖ(x + 2‚ãÖy)

julia&gt; subs(ex, (y, y^2))
‚éõ     2‚éû ‚éõ       2‚éû
‚éùx - y ‚é†‚ãÖ‚éùx + 2‚ãÖy ‚é†

julia&gt; subs(ex, (x,1), (y,2))
-5

julia&gt; subs(ex, (x,y^3), (y,2))
72

julia&gt; subs(ex, y, 3)
(x - 3)‚ãÖ(x + 6)</code></pre><p>There is a curried form of <code>subs</code> to use with the chaining <code>|&gt;</code> operator</p><pre><code class="language-julia-repl hljs">julia&gt; ex |&gt; subs(x,‚ÑØ)
(‚ÑØ - y)‚ãÖ(2‚ãÖy + ‚ÑØ)</code></pre><p>The use of pairs gives a convenient alternative:</p><pre><code class="language-julia-repl hljs">julia&gt; subs(ex, x=&gt;1, y=&gt;2)
-5

julia&gt; ex |&gt; subs(x=&gt;1, y=&gt;2)
-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L81-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.symbols-Tuple{AbstractString}" href="#SymPy.symbols-Tuple{AbstractString}"><code>SymPy.symbols</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbols(name(s), assumptions...)</code></pre><p>Calls <code>sympy.symbols</code> to produce symbolic variables and symbolic functions. An alternate to the recommended <code>@syms</code>, (when applicable)</p><p>In sympy <code>sympy.symbols</code> and <code>sympy.Symbol</code> both allow the construction of symbolic variables and functions. The <code>Julia</code> function <code>symbols</code> is an alias for <code>sympy.symbols</code>.</p><ul><li>Variables are created through <code>x=symbols(&quot;x&quot;)</code>;</li><li>Assumptions on variables by <code>x=symbols(&quot;x&quot;, real=true)</code>;</li><li>Multiple symbols <code>x1,x2 = symbols(&quot;x[1:3]&quot;)</code> can be created. Unlike <code>@syms</code>, the number of variables can be specified with a variable through interpolation.</li><li>Symbolic functions can be created py passing <code>cls=sympy.Function</code>, <code>symbols(&quot;F&quot;, cls=sympy.Function, real=true)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/constructors.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.walk_expression-Tuple{Any}" href="#SymPy.walk_expression-Tuple{Any}"><code>SymPy.walk_expression</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">walk_expression(ex; values=Dict(), fns=Dict())</code></pre><p>Convert a symbolic SymPy expression into a <code>Julia</code> expression. This is needed to use functions in external packages in lambdified functions.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using SymPy
@syms x y
ex = sympy.hyper((2,2),(3,3),x) * y</code></pre><p>Calling <code>lambdify(ex)</code> will fail to make a valid function, as <code>hyper</code> is implemented in <code>HypergeometricFunctions.pFq</code>. So, we have:</p><pre><code class="nohighlight hljs">using HypergeometricFunctions
d = Dict(&quot;hyper&quot; =&gt; :pFq)
body = SymPy.walk_expression(ex, fns=d)
syms = Symbol.(free_symbols(ex))
fn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));
fn(1,1) # 1.6015187080185656</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/lambdify.jl#L83-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.False" href="#SymPy.False"><code>SymPy.False</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>False from SymPy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.IM" href="#SymPy.IM"><code>SymPy.IM</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>IM is a symbolic <code>im</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.PI" href="#SymPy.PI"><code>SymPy.PI</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>PI is symbolic <code>pi</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.True" href="#SymPy.True"><code>SymPy.True</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>True from SymPy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.oo" href="#SymPy.oo"><code>SymPy.oo</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>oo is a symbolic infinity. Example: <code>integrate(exp(-x), x, 0, oo)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.sympy" href="#SymPy.sympy"><code>SymPy.sympy</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">sympy</code></pre><p>Variable from <code>pyimport(&quot;sympy&quot;)</code>. Numerous methods are available through Python&#39;s dot-call syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.sympy_core" href="#SymPy.sympy_core"><code>SymPy.sympy_core</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">sympy_core</code></pre><p>Variable from <code>pyimport(&quot;sympy.core&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.sympy_matrices" href="#SymPy.sympy_matrices"><code>SymPy.sympy_matrices</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">sympy_matrices</code></pre><p>Variable from <code>pyimport(&quot;sympy.matrices&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.sympy_plotting" href="#SymPy.sympy_plotting"><code>SymPy.sympy_plotting</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>Plotting of symbolic objects.</p><p>The <code>Plots</code> package provide a uniform interface to many of <code>Julia</code>&#39;s plotting packages. <code>SymPy</code> plugs into <code>Plots</code>&#39; &quot;recipes.&quot;</p><p>The basic goal is that when <code>Plots</code> provides an interface for function objects, this package extends the interface to symbolic expressions.</p><p>In particular:</p><ul><li><code>plot(ex::Sym, a, b; kwargs...)</code> will plot a function evaluating <code>ex</code> over [a,b]</li></ul><p>Example. Here we use the default backend for <code>Plots</code> to make a plot:</p><pre><code class="nohighlight hljs">using Plots
@syms x
plot(x^2 - 2x, 0, 4)</code></pre><ul><li><code>plot(ex1, ex2, a, b; kwargs...)</code> will plot the two expressions in a parametric plot over the interval <code>[a,b]</code>.</li></ul><p>Example:</p><pre><code class="nohighlight hljs">@syms x
plot(sin(2x), cos(3x), 0, 4pi) ## also</code></pre><p>For a few backends (those that support <code>:path3d</code>) a third symbolic expression may be added to have a 3d parametric plot rendered:</p><pre><code class="nohighlight hljs">plot(sin(x), cos(x), x, 0, 4pi) # helix in 3d</code></pre><ul><li><code>plot(xs, ys, expression)</code> will make a contour plot (for many backends).</li></ul><pre><code class="nohighlight hljs">@syms x y
plot(range(0,stop=5, length=50), range(0,stop=5, length=50), x*y)</code></pre><ul><li>To plot the surface  <code>z=ex(x,y)</code> over a region we have <code>Plots.surface</code>. For example,</li></ul><pre><code class="nohighlight hljs">@syms x y
surface(-5:5, -5:5, 25 - x^2 - y^2)</code></pre><ul><li>a vectorfield plot can (inefficiently but directly) be produced following this example:</li></ul><pre><code class="nohighlight hljs">function vfieldplot(fx, fy; xlim=(-5,5), ylim=(-5,5), n=8)
    xs = range(xlim[1], stop=xlim[2], length=n)
    ys = range(ylim[1], stop=ylim[2], length=n)

    us = vec([x for x in xs, y in ys])
    vs = vec([y for x in xs, y in ys])
    fxs = vec([fx(x,y) for x in xs, y in ys])
    fys = vec([fy(x,y) for x in xs, y in ys])

    mxs = maximum(abs.(filter(!isinf, filter(!isnan, fxs))))
    mys = maximum(abs.(filter(!isinf, filter(!isnan, fys))))
    d = 1/2 * max((xlim[2]-xlim[1])/mxs, (ylim[2]-ylim[1])/mys) / n

    quiver(us, vs, quiver=(fxs.*d, fys.*d))

end
fx = (x + y) / sqrt(x^2 + y^2)
fy = (x - y) / sqrt(x^2 + y^2)
vfieldplot(fx, fy)

</code></pre><ul><li>To plot two or more functions at once, the style <code>plot([ex1, ex2], a, b)</code> does not work. Rather, use   <code>plot(ex1, a, b); plot!(ex2)</code>, as in:</li></ul><pre><code class="nohighlight hljs">@syms x
plot(sin(x), 0, 2pi)
plot!(cos(x))</code></pre><hr/><p>Some graphics provided by <code>SymPy</code> are available if <code>PyPlot</code> is installed, such as:</p><ul><li><code>sympy.plotting.plot3d_parametric_surface</code></li><li><code>sympy.plotting.plot_implicit</code></li></ul><p>Plot the parametrically defined surface <code>[exs[1](u,v), exs[2](u,v), exs[3](u,v)]</code> over <code>[a0,a1] x [b0,b1]</code>. The specification of the variables uses a tuple of the form <code>(Sym, Real, Real)</code> following the style of SymPy in <code>integrate</code>, say, where disambiguation of variable names is needed.</p><pre><code class="nohighlight hljs">@syms theta, phi
r = 1
sympy.plotting.plot3d_parametric_surface((r*sin(theta)*sin(phi), r*sin(theta)*cos(phi), r*cos(theta)),
                        (theta, 0, pi), (phi, 0, pi/2))</code></pre><ul><li><code>sympy.plotting.plot_implicit(equation, (xvar, x0, x1), (yvar, y0, y1))</code> will plot implicitly the equation.</li></ul><pre><code class="nohighlight hljs">@syms x y
sympy.plotting.plot_implicit(Eq(x^2+ y^2,3), (x, -2, 2), (y, -2, 2))  # draw a circle</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/plot_recipes.jl#L1-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.zoo" href="#SymPy.zoo"><code>SymPy.zoo</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>zoo complex inifinity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.@symfuns-Tuple" href="#SymPy.@symfuns-Tuple"><code>SymPy.@symfuns</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@symfuns</code></pre><p>Thanks to <code>@alhirzel</code> for the contribution.</p><p>!!! Note:     The <code>@symfuns</code> macro will be deprecated. The more general <a href="#SymPy.@syms-Tuple"><code>@syms</code></a> macro should be used for constructing symbolic functions of type <code>SymFunction</code> and <code>symbols</code> can be used to construct symbolic functions in general.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/symfunction.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.@syms-Tuple" href="#SymPy.@syms-Tuple"><code>SymPy.@syms</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@syms a n::integer x::(real,positive)=&gt;&quot;x‚ÇÄ&quot; y[-1:1] u() v()::real w()::(real,positive) y()[1:3]::real</code></pre><p>Construct symbolic variables or functions along with specified assumptions. Similar to <code>@vars</code>, <code>sympy.symbols</code>, and <code>sympy.Function</code>, but the specification of the assumptions is more immediate than those interfaces which follow sympy&#39;s constructors.</p><p>Allows the specification of assumptions on the variables and functions.</p><ul><li>a type-like annontation, such as <code>n::integer</code> is equivalent to <code>sympy.symbols(&quot;n&quot;, integer=true)</code>. Multiple assumptions are combined using parentheses (e.g., <code>n::(integer,nonnegative)</code>.</li></ul><p>The possible <a href="https://docs.sympy.org/latest/modules/core.html#module-sympy.core.assumptions">values</a> for assumptions are: &quot;commutative&quot;, &quot;complex&quot;, &quot;imaginary&quot;, &quot;real&quot;, &quot;integer&quot;, &quot;odd&quot;, &quot;even&quot;, &quot;prime&quot;, &quot;composite&quot;, &quot;zero&quot;, &quot;nonzero&quot;, &quot;rational&quot;, &quot;algebraic&quot;, &quot;transcendental&quot;, &quot;irrational&quot;, &quot;finite&quot;, &quot;infinite&quot;, &quot;negative&quot;, &quot;nonnegative&quot;, &quot;positive&quot;, &quot;nonpositive&quot;, &quot;hermitian&quot;, &quot;antihermetian&quot;.</p><ul><li><p>a tensor declaration form is provided to define arrays of variables, e.g. <code>x[-1:1]</code> or <code>y[1:4, 2:5]</code>.</p></li><li><p>a symbolic function can be specified using a pair of parentheses after the name, as in <code>u()</code>.</p></li><li><p>The return type of a function can have assumptions specified, as with a variable. E.g., <code>h()::complex</code>. How the symbolic function prints can be set as with a variable, e.g. <code>h()::complex=&gt;&quot;hÃÑ&quot;</code>.</p></li><li><p>multiple definitions can be separated by commas</p></li><li><p>How the symbol prints (the <code>__str__()</code> value) can be specified using the syntax <code>=&gt;&quot;name&quot;</code>, as in <code>x=&gt;&quot;x‚Çí&quot;</code></p></li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; @syms a b::nonnegative
(a, b)

julia&gt; sqrt(a^2), sqrt(b^2)
(sqrt(a^2), b)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @syms x::prime
(x,)

julia&gt; ask(ùëÑ.negative(x)), ask(ùëÑ.integer(x)), ask(ùëÑ.even(x))  # (false, true, nothing)
(false, true, nothing)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @syms a[0:5], x
(Sym[a‚ÇÄ, a‚ÇÅ, a‚ÇÇ, a‚ÇÉ, a‚ÇÑ, a‚ÇÖ], x)

julia&gt; sum( a·µ¢*x^(i) for (i,a·µ¢) ‚àà zip(0:5, a)) |&gt; print
a‚ÇÄ + a‚ÇÅ*x + a‚ÇÇ*x^2 + a‚ÇÉ*x^3 + a‚ÇÑ*x^4 + a‚ÇÖ*x^5</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @syms x u() v()::nonnegative
(x, u, v)

julia&gt; sqrt(u(x)^2), sqrt(v(x)^2) # sqrt(u(x)^2), Abs(v(x))
(sqrt(u(x)^2), Abs(v(x)))</code></pre><p>!!! Note:     Many thanks to <code>@matthieubulte</code> for this contribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/constructors.jl#L59-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.@vars-Tuple" href="#SymPy.@vars-Tuple"><code>SymPy.@vars</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@vars x y z</code></pre><p>Define symbolic values, possibly with names and assumptions</p><p>Examples:</p><pre><code class="nohighlight hljs">@vars x y
@vars a1=&gt;&quot;Œ±‚ÇÅ&quot;
@vars a b real=true</code></pre><p>!!! Note:     The <code>@syms</code> macro is recommended as it has a more flexible syntax</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/constructors.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.Differential" href="#SymPy.Differential"><code>SymPy.Differential</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Differential(x)</code></pre><p>Use to find (partial) derivatives.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">@syms x y u()
Dx = Differential(x)
Dx(u(x,y))  # resolves to diff(u(x,y),x)
Dx(u)       # will evaluate diff(u(x), x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/symfunction.jl#L91-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.Doc" href="#SymPy.Doc"><code>SymPy.Doc</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymPy.Doc(f::Symbol, [module=sympy])</code></pre><p>Return docstring of <code>f</code> found within the specified module.</p><p>Examples</p><pre><code class="nohighlight hljs">SymPy.Doc(:sin)
SymPy.Doc(:det, sympy.matrices)
## add module to query
SymPy.pyimport_conda(&quot;sympy.crypto.crypto&quot;, &quot;sympy&quot;)
SymPy.Doc(:padded_key, sympy.crypto)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L219-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.SymFunction" href="#SymPy.SymFunction"><code>SymPy.SymFunction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymFunction</code></pre><p>A type and constructor to create symbolic functions. Such objects can be used for specifying differential equations. The macro <a href="#SymPy.@syms-Tuple"><code>@syms</code></a> is also available for constructing <code>SymFunction</code>s (<code>@syms f()</code>)</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; u = SymFunction(&quot;u&quot;);

julia&gt; @syms v();
</code></pre><p>Alternatively, we can pass a comma separated string of variable names to create more than one at a time.</p><pre><code class="language-julia-repl hljs">julia&gt; F,G,H = SymFunction(&quot;F, G, H&quot;)
3-element Vector{SymFunction}:
 F
 G
 H</code></pre><p>For symbolic functions <em>not</em> wrapped in the <code>SymFunction</code> type, the <code>sympy.Function</code> constructor can be used, as can the <a href="#SymPy.symbols-Tuple{AbstractString}"><code>symbols</code></a> function to construct symbolic functions (<code>F=sympy.Function(&quot;F&quot;, real=true)</code>; <code>F = sympy.symbols(&quot;F&quot;, cls=sympy.Function, real=true)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; @syms u(), v()::real, t
(u, v, t)

julia&gt; sqrt(u(t)^2), sqrt(v(t)^2) # real values have different simplification rules
(sqrt(u(t)^2), Abs(v(t)))
</code></pre><p>Such functions are undefined functions in SymPy, and can be used symbolically, such as with taking derivatives:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x y u()
(x, y, u)

julia&gt; diff(u(x), x) |&gt; string
&quot;Derivative(u(x), x)&quot;

julia&gt; diff(u(x, y), x) |&gt; string
&quot;Derivative(u(x, y), x)&quot;</code></pre><p>Here is one way to find the second derivative of an inverse function to <code>f</code>, utilizing the <code>SymFunction</code> class and the convenience <code>Differential</code> function:</p><pre><code class="nohighlight hljs">@syms f() f‚Åª¬π() x
D = Differential(x) # ‚àÇ(f) is diff(f(x),x)
D¬≤ = D‚àòD
u1 = solve(diff((f‚Åª¬π‚àòf)(x), x) ~ 1, D(f‚Åª¬π)(f(x)))[1]
u2 = solve(diff((f‚Åª¬π‚àòf)(x), x,2) ~ 0, D¬≤(f‚Åª¬π)(f(x)))[1]
u2(D(f‚Åª¬π)(f(x)) =&gt; u1) # f&#39;&#39;/[f&#39;]^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/symfunction.jl#L3-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.SymMatrix" href="#SymPy.SymMatrix"><code>SymPy.SymMatrix</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymMatrix</code></pre><p>Type to store a SymPy matrix, as created by <code>sympy.ImmutableMatrix</code>.</p><p>These have 0-based indexing defined for them to match SymPy</p><p>The traditional infix mathmatical operations are defined, but no dot broadcasting.</p><p>The <code>convert(Matrix{Sym}, M)</code> call is useful to covert to a Julia matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/types.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.VectorField" href="#SymPy.VectorField"><code>SymPy.VectorField</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>VectorField(fx, fy</code>): create an object that can be <code>plot</code>ted as a vector field.</p><p>A vectorfield plot draws arrows at grid points proportional to <code>[fx(x_i,y_i), fy(x_i,y_i)]</code> to visualize the field generated by <code>[fx, fy]</code>.</p><p>The plot command: <code>plot(VectorField(fx, fy), xlims=(-5,5), ylims=(-5,5), n=8)</code> will draw the vectorfield. This uses the default values, so the same graph would be rendered by <code>plot(VectorField(fx,fy))</code>.</p><p>To faciliate the visualization of solution to the ODE y&#39; = F(x, y(x)), the call <code>plot(VectorField(F))</code> will work. (The order is x then y, though often this is written as F(y(x),x).)</p><p><code>SymPy</code> objects can be passed to <code>VectorField</code>, but this is a bit fragile, as they must each have two variables so that they can be called with two variables.  (E.g., <code>y(1,2)</code> will be <code>1</code> not <code>2</code>, as might be intended.)</p><p>Examples:</p><pre><code class="nohighlight hljs">using Plots

fx(x,y) = sin(y); fy(x,y) = cos(y)
plot(VectorField(fx, fy), xlims=(-2pi, 2pi), ylims=(-2pi,2pi))

# plot field of y&#39; = 3y*x over (-5,5) x (-5,5)
F(x,y) = 3*y*x
plot(VectorField(F))

# plot field and solution u&#39; = u*(1-u)
@syms x u()
F(x,y) = y*(1-y)
out = dsolve(u&#39;(x) - F(x, u(x)), x, (u, 0, 1))
plot(VectorField(F), xlims=(0,5), ylims=(0,2))
plot!(rhs(out))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/plot_recipes.jl#L147-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.SymPy" href="#SymPy.SymPy"><code>SymPy.SymPy</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><p><code>SymPy</code> package to interface with Python&#39;s <a href="http://www.sympy.org">SymPy library</a> through <code>PyCall</code>.</p><p>The basic idea is that a new type ‚Äì <code>Sym</code> ‚Äì is made to hold symbolic objects.  For this type, the basic functions from SymPy and appropriate functions of <code>Julia</code> are overloaded for <code>Sym</code> objects so that the expressions are treated symbolically and not evaluated immediately. Instances of this type are created by the constructor <code>Sym</code>, the function <code>symbols</code> or the macro <code>@vars</code>.</p><p>On loading, a priviledged set of the functions from the <code>sympy</code> module are defined as generic functions with their first argument narrowed to symbolic types. Others may be accessed by qualification, as in <code>sympy.trigsimp</code>. Calling <code>import_from(sympy)</code> will import the rest. SymPy methods are called through Python&#39;s dot-call syntax.  To find documentation on SymPy functions and methods, one should refer to SymPy&#39;s <a href="http://docs.sympy.org/latest/index.html">website</a>.</p><p>Plotting is provided through  <code>Plots</code> recipes. For details, see the help page for <a href="#SymPy.sympy_plotting"><code>sympy_plotting</code></a>.</p><p>The package <a href="https://docs.juliahub.com/SymPy/">documentation</a> provides many examples.</p><p>Access to SymPy&#39;s help system for most functions is available through <code>SymPy.Doc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/SymPy.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.ùëÑ" href="#SymPy.ùëÑ"><code>SymPy.ùëÑ</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ùëÑ
SymPy.Q</code></pre><p>The<code>SymPy.ùëÑ</code> module adds features of the <code>sympy.Q</code> module. Also accesible through <code>SymPy.Q</code>.</p><p>SymPy allows for <a href="https://docs.sympy.org/latest/modules/assumptions/index.html">assumptions</a> on variables. These may be placed on free sympols at construction.</p><p>For example, the following creates a real value variable <code>x</code> and a postive, real variable <code>y</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; @vars x real=true
(x,)

julia&gt; @vars y real=true positive=true
(y,)</code></pre><p>The <code>ùëÑ</code> module exposes a means to <em>q</em>uery the assumptions on a variable. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; ask(ùëÑ.positive(y))  # true
true

julia&gt; ask(ùëÑ.negative(y))  # false
false

julia&gt; ask(SymPy.Q.positive(x))  # `nothing`

julia&gt; ask(SymPy.Q.positive(x^2)) # `nothing` -- might be 0

julia&gt; ask(SymPy.Q.positive(1 + x^2)) # true  -- must be postive now.
true</code></pre><p>The ask function uses tri-state logic, returning one of 3 values: <code>true</code>; <code>false</code>; or <code>nothing</code>, when the query is indeterminate.</p><p>The construction of predicates is done through <code>Q</code> methods. These can be combined logically. For example, this will be <code>true</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; ask(ùëÑ.positive(y) &amp; ùëÑ.negative(-x^2 - 1))
</code></pre><p>The above use <code>&amp;</code> as an infix operation for the binary operator <code>And</code>. Values can also be combined with <code>Or</code>, <code>Not</code>, <code>Xor</code>, <code>Nand</code>, <code>Nor</code>, <code>Implies</code>, <code>Equivalent</code>, and <code>satisfiable</code>.</p><div class="admonition is-info"><header class="admonition-header">typing `ùëÑ`</header><div class="admonition-body"><p>ùëÑ is entered as  [slash]itQ[tab]) or <code>SymPy.Q.query(value)</code> <em>but  not</em> as <code>sympy.Q.query(value)</code></p></div></div><div class="admonition is-info"><header class="admonition-header">Matrix predicates</header><div class="admonition-body"><p>As <code>SymPy.jl</code> converts symbolic matrices into Julia&#39;s <code>Array</code></p></div></div><p>type and not as matrices within Python, the predicate functions from SymPy for matrices are not used, though a replacement is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/assumptions.jl#L52-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.Introspection.args-Tuple{Sym}" href="#SymPy.Introspection.args-Tuple{Sym}"><code>SymPy.Introspection.args</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">args(x)</code></pre><p>Return arguments of <code>x</code>, as a tuple. (Empty if no <code>:args</code> property.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.Introspection.func-Tuple{Sym}" href="#SymPy.Introspection.func-Tuple{Sym}"><code>SymPy.Introspection.func</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>func(x)</p><p>Return function head from an expression</p><p><a href="http://docs.sympy.org/dev/tutorial/manipulation.html">Invariant:</a></p><p>Every well-formed SymPy expression <code>ex</code> must either have <code>length(args(ex)) == 0</code> or <code>func(ex)(args(ex)...) = ex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L454-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPy.Introspection.funcname-Tuple{Sym}" href="#SymPy.Introspection.funcname-Tuple{Sym}"><code>SymPy.Introspection.funcname</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">funcname(x)</code></pre><p>Return name or &quot;&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPy/SymPy.jl/blob/473447b78b41a6359215789d47e0c5e44b8e2025/src/utils.jl#L440-L444">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Tutorial/manipulation/">¬´ Advanced expression  manipulation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Thursday 28 September 2023 14:35">Thursday 28 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
