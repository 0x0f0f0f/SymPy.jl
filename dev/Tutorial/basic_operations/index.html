<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic operations · SymPy</title><meta name="title" content="Basic operations · SymPy"/><meta property="og:title" content="Basic operations · SymPy"/><meta property="twitter:title" content="Basic operations · SymPy"/><meta name="description" content="Documentation for SymPy."/><meta property="og:description" content="Documentation for SymPy."/><meta property="twitter:description" content="Documentation for SymPy."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymPy</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/">Examples</a></li><li><span class="tocitem">SymPy tutorial</span><ul><li><a class="tocitem" href="../">About</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../gotchas/">Gotchas</a></li><li class="is-active"><a class="tocitem" href>Basic operations</a><ul class="internal"><li><a class="tocitem" href="#Substitution"><span>Substitution</span></a></li><li><a class="tocitem" href="#Converting-Strings-to-SymPy-Expressions"><span>Converting Strings to SymPy Expressions</span></a></li><li><a class="tocitem" href="#evalf"><span><code>evalf</code></span></a></li><li><a class="tocitem" href="#N-with-Julia"><span><code>N</code> with <code>Julia</code></span></a></li><li><a class="tocitem" href="#lambdify"><span><code>lambdify</code></span></a></li></ul></li><li><a class="tocitem" href="../simplification/">Simplification</a></li><li><a class="tocitem" href="../calculus/">Calculus</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../matrices/">Matrices</a></li><li><a class="tocitem" href="../manipulation/">Advanced expression  manipulation</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference/API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">SymPy tutorial</a></li><li class="is-active"><a href>Basic operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPy/SymPy.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPy/SymPy.jl/blob/master/docs/src/Tutorial/basic_operations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Operations"><a class="docs-heading-anchor" href="#Basic-Operations">Basic Operations</a><a id="Basic-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Operations" title="Permalink"></a></h1><p><a href="https://docs.sympy.org/latest/tutorial/basic_operations.html">From</a></p><p>Here we discuss some of the most basic operations needed for expression manipulation in SymPy.  Some more advanced operations will be discussed later in the :ref:<code>advanced expression manipulation &lt;tutorial-manipulation&gt;</code> section.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; from sympy import *
    &gt;&gt;&gt; x, y, z = symbols(&quot;x y z&quot;)</code></pre><h5 id="In-Julia:"><a class="docs-heading-anchor" href="#In-Julia:">In <code>Julia</code>:</a><a id="In-Julia:-1"></a><a class="docs-heading-anchor-permalink" href="#In-Julia:" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; x, y, z = symbols(&quot;x y z&quot;)
(x, y, z)</code></pre><ul><li><p>We didn&#39;t replicate <code>from sympy import *</code>, though this is mostly done through the command <code>import_from(sympy)</code>.  By default, <code>SymPy</code> only makes available a priviledged collection of the functions available through the <code>sympy</code> object. The <code>import_from</code> imports most all of the rest.</p></li><li><p>If a function is not imported, it may be referenced through qualification, asin <code>sympy.expand_trig</code>, as will be seen in the following.</p></li><li><p>the use of <code>symbols</code> to construct symbolic values is more easily facilitated with the macro <code>@syms</code>, used as follows</p></li></ul><pre><code class="language-julia-repl hljs">julia&gt; @syms x, y, z
(x, y, z)</code></pre><hr/><h2 id="Substitution"><a class="docs-heading-anchor" href="#Substitution">Substitution</a><a id="Substitution-1"></a><a class="docs-heading-anchor-permalink" href="#Substitution" title="Permalink"></a></h2><p>One of the most common things you might want to do with a mathematical expression is substitution.  Substitution replaces all instances of something in an expression with something else.  It is done using the <code>subs</code> method. For example</p><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = cos(x) + 1
    &gt;&gt;&gt; expr.subs(x, y)
    cos(y) + 1</code></pre><h5 id="In-Julia:-2"><a class="docs-heading-anchor" href="#In-Julia:-2">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-2" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expr = cos(x) + 1
cos(x) + 1

julia&gt; expr.subs(x, y)
cos(y) + 1</code></pre><p>Julia also allows &quot;call&quot; notation using a pairs to indicate the substitution:</p><pre><code class="language-julia-repl hljs">julia&gt; expr(x =&gt; y)
cos(y) + 1</code></pre><hr/><p>Substitution is usually done for one of two reasons:</p><ol><li>Evaluating an expression at a point. For example, if our expression is <code>cos(x) + 1</code> and we want to evaluate it at the point <code>x = 0</code>, so that we get <code>cos(0) + 1</code>, which is 2.</li></ol><pre><code class="language-python hljs">   &gt;&gt;&gt; expr.subs(x, 0)
   2</code></pre><h5 id="In-Julia:-3"><a class="docs-heading-anchor" href="#In-Julia:-3">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-3" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expr(x =&gt; 0)
2</code></pre><hr/><ol><li>Replacing a subexpression with another subexpression.  There are two reasons we might want to do this.  The first is if we are trying to build an expression that has some symmetry, such as <code>x^{x^{x^x}}</code>.  To build this, we might start with <code>x**y</code>, and replace <code>y</code> with <code>x**y</code>.  We would then get <code>x**(x**y)</code>.  If we replaced <code>y</code> in this new expression with <code>x**x</code>, we would get <code>x**(x**(x**x))</code>, the desired expression.</li></ol><pre><code class="language-python hljs">   &gt;&gt;&gt; expr = x**y
   &gt;&gt;&gt; expr
   x**y
   &gt;&gt;&gt; expr = expr.subs(y, x**y)
   &gt;&gt;&gt; expr
   x**(x**y)
   &gt;&gt;&gt; expr = expr.subs(y, x**x)
   &gt;&gt;&gt; expr
   x**(x**(x**x))</code></pre><h5 id="In-Julia:-4"><a class="docs-heading-anchor" href="#In-Julia:-4">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-4" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expr = x^y
 y
x

julia&gt; expr = expr(y =&gt; x^y)
 ⎛ y⎞
 ⎝x ⎠
x

julia&gt; expr = expr(y =&gt; x^x)
 ⎛ ⎛ x⎞⎞
 ⎜ ⎝x ⎠⎟
 ⎝x    ⎠
x
</code></pre><hr/><p>The second is if we want to perform a very controlled simplification, or    perhaps a simplification that SymPy is otherwise unable to do.  For    example, say we have <code>\sin(2x) + \cos(2x)</code>, and we want to replace    <code>\sin(2x)</code> with <code>2\sin(x)\cos(x)</code>.  As we will learn later, the function    <code>expand_trig</code> does this.  However, this function will also expand    <code>\cos(2x)</code>, which we may not want.  While there are ways to perform such    precise simplification, and we will learn some of them in the    :ref:<code>advanced expression manipulation &lt;tutorial-manipulation&gt;</code> section, an    easy way is to just replace <code>\sin(2x)</code> with <code>2\sin(x)\cos(x)</code>.</p><pre><code class="language-python hljs">   &gt;&gt;&gt; expr = sin(2*x) + cos(2*x)
   &gt;&gt;&gt; expand_trig(expr)
   2*sin(x)*cos(x) + 2*cos(x)**2 - 1
   &gt;&gt;&gt; expr.subs(sin(2*x), 2*sin(x)*cos(x))
   2*sin(x)*cos(x) + cos(2*x)</code></pre><h5 id="In-Julia:-5"><a class="docs-heading-anchor" href="#In-Julia:-5">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-5" title="Permalink"></a></h5><ul><li><code>expand_trig</code> is not exported, so we qualify it:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; expr = sin(2*x) + cos(2*x)
sin(2⋅x) + cos(2⋅x)

julia&gt; sympy.expand_trig(expr) |&gt; string
&quot;2*sin(x)*cos(x) + 2*cos(x)^2 - 1&quot;

julia&gt; expr(sin(2*x) =&gt; 2*sin(x)*cos(x))
2⋅sin(x)⋅cos(x) + cos(2⋅x)</code></pre><hr/><p>There are two important things to note about <code>subs</code>.  First, it returns a new expression.  SymPy objects are immutable.  That means that <code>subs</code> does not modify it in-place.  For example</p><pre><code class="language-python hljs">   &gt;&gt;&gt; expr = cos(x)
   &gt;&gt;&gt; expr.subs(x, 0)
   1
   &gt;&gt;&gt; expr
   cos(x)
   &gt;&gt;&gt; x
   x</code></pre><h5 id="In-Julia:-6"><a class="docs-heading-anchor" href="#In-Julia:-6">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-6" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expr = cos(x)
cos(x)

julia&gt; expr(x =&gt; 0)
1

julia&gt; expr
cos(x)

julia&gt; x
x</code></pre><hr/><div class="admonition is-info"><header class="admonition-header">Quick Tip</header><div class="admonition-body"><p>SymPy expressions are immutable.  No function will change them in-place.</p></div></div><p>Here, we see that performing <code>expr.subs(x, 0)</code> leaves <code>expr</code> unchanged. In fact, since SymPy expressions are immutable, no function will change them in-place.  All functions will return new expressions.</p><p>To perform multiple substitutions at once, pass a list of <code>(old, new)</code> pairs to <code>subs</code>.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = x**3 + 4*x*y - z
    &gt;&gt;&gt; expr.subs([(x, 2), (y, 4), (z, 0)])
    40</code></pre><h5 id="In-Julia:-7"><a class="docs-heading-anchor" href="#In-Julia:-7">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-7" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expr = x^3 + 4*x*y - z;  string(expr)
&quot;x^3 + 4*x*y - z&quot;

julia&gt; expr.subs([(x, 2), (y, 4), (z, 0)])
40</code></pre><p>Or, using pairs:</p><pre><code class="language-julia-repl hljs">julia&gt; expr(x=&gt;2, y=&gt;4, z=&gt;0)
40</code></pre><hr/><p>It is often useful to combine this with a list comprehension to do a large set of similar replacements all at once.  For example, say we had <code>x^4 - 4x^3 + 4x^2 - 2x + 3</code> and we wanted to replace all instances of <code>x</code> that have an even power with <code>y</code>, to get <code>y^4 - 4x^3 + 4y^2 - 2x + 3</code>.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = x**4 - 4*x**3 + 4*x**2 - 2*x + 3
    &gt;&gt;&gt; replacements = [(x**i, y**i) for i in range(5) if i % 2 == 0]
    &gt;&gt;&gt; expr.subs(replacements)
    -4*x**3 - 2*x + y**4 + 4*y**2 + 3</code></pre><h5 id="In-Julia:-8"><a class="docs-heading-anchor" href="#In-Julia:-8">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-8" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expr = x^4 - 4*x^3 + 4*x^2 - 2*x + 3
 4      3      2
x  - 4⋅x  + 4⋅x  - 2⋅x + 3

julia&gt; replacements = [(x^i, y^i) for i in 1:5 if iseven(i)]
2-element Vector{Tuple{Sym, Sym}}:
 (x^2, y^2)
 (x^4, y^4)

julia&gt; expr.subs(replacements)
     3          4      2
- 4⋅x  - 2⋅x + y  + 4⋅y  + 3</code></pre><hr/><h2 id="Converting-Strings-to-SymPy-Expressions"><a class="docs-heading-anchor" href="#Converting-Strings-to-SymPy-Expressions">Converting Strings to SymPy Expressions</a><a id="Converting-Strings-to-SymPy-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Strings-to-SymPy-Expressions" title="Permalink"></a></h2><p>The <code>sympify</code> function (that&#39;s <code>sympify</code>, not to be confused with <code>simplify</code>) can be used to convert strings into SymPy expressions.</p><p>For example</p><pre><code class="language-python hljs">    &gt;&gt;&gt; str_expr = &quot;x**2 + 3*x - 1/2&quot;
    &gt;&gt;&gt; expr = sympify(str_expr)
    &gt;&gt;&gt; expr
    x**2 + 3*x - 1/2
    &gt;&gt;&gt; expr.subs(x, 2)
    19/2</code></pre><h5 id="In-Julia:-9"><a class="docs-heading-anchor" href="#In-Julia:-9">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-9" title="Permalink"></a></h5><p>As <code>sympify</code> is not passed a symbolic value, it is qualified:</p><pre><code class="language-julia-repl hljs">julia&gt; str_expr = &quot;x^2 + 3*x - 1/2&quot;
&quot;x^2 + 3*x - 1/2&quot;

julia&gt; expr = sympy.sympify(str_expr)
 2         1
x  + 3⋅x - ─
           2
julia&gt; expr.subs(x, 2)
19/2</code></pre><hr/><div class="admonition is-info"><header class="admonition-header">Alert:</header><div class="admonition-body"><p><code>sympify</code> uses <code>eval</code>.  Don&#39;t use it on unsanitized input.</p></div></div><h2 id="evalf"><a class="docs-heading-anchor" href="#evalf"><code>evalf</code></a><a id="evalf-1"></a><a class="docs-heading-anchor-permalink" href="#evalf" title="Permalink"></a></h2><p>To evaluate a numerical expression into a floating point number, use <code>evalf</code>.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = sqrt(8)
    &gt;&gt;&gt; expr.evalf()
    2.82842712474619</code></pre><h5 id="In-Julia:-10"><a class="docs-heading-anchor" href="#In-Julia:-10">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-10" title="Permalink"></a></h5><ul><li>We must use a symbolic value for <code>8</code>:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; expr = sqrt(Sym(8))
2⋅√2

julia&gt; expr.evalf()
2.82842712474619</code></pre><div class="admonition is-info"><header class="admonition-header">N is different in SymPy.jl</header><div class="admonition-body"><p>More importantly, <code>SymPy.jl</code> treats <code>N</code> differently from <code>evalf</code>. <code>N</code> is used to convert a SymPy numeric (or Boolean) value to a <code>Julia</code>n counterpart. The main difference between <code>N(x)</code> and <code>convert(T, x)</code>, is that rather than specify the <code>Julia</code> type as <code>T</code>, <code>N</code> works to guess the appropriate type for the <code>SymPy</code> object.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; N(sqrt(8))   # brings back as BigFloat
2.8284271247461903</code></pre><pre><code class="language-julia-repl hljs">julia&gt; N(sqrt(9))   # an Int
3.0</code></pre><hr/><p>SymPy can evaluate floating point expressions to arbitrary precision.  By default, 15 digits of precision are used, but you can pass any number as the argument to <code>evalf</code>.  Let&#39;s compute the first 100 digits of <code>\pi</code>.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; pi.evalf(100)
3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068</code></pre><h5 id="In-Julia:-11"><a class="docs-heading-anchor" href="#In-Julia:-11">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-11" title="Permalink"></a></h5><pre><code class="language-julia hljs">julia&gt; PI.evalf(100)
3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068</code></pre><hr/><p>To numerically evaluate an expression with a Symbol at a point, we might use <code>subs</code> followed by <code>evalf</code>, but it is more efficient and numerically stable to pass the substitution to <code>evalf</code> using the <code>subs</code> flag, which takes a dictionary of <code>Symbol: point</code> pairs.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = cos(2*x)
    &gt;&gt;&gt; expr.evalf(subs={x: 2.4})
    0.0874989834394464</code></pre><h5 id="In-Julia:-12"><a class="docs-heading-anchor" href="#In-Julia:-12">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-12" title="Permalink"></a></h5><p>A Dict can be used:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = cos(2*x)
cos(2⋅x)

julia&gt; expr.evalf(subs=Dict(x =&gt; 2.4))
0.0874989834394464</code></pre><hr/><p>Sometimes there are roundoff errors smaller than the desired precision that remain after an expression is evaluated. Such numbers can be removed at the user&#39;s discretion by setting the <code>chop</code> flag to True.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; one = cos(1)**2 + sin(1)**2
    &gt;&gt;&gt; (one - 1).evalf()
    -0.e-124
    &gt;&gt;&gt; (one - 1).evalf(chop=True)
    0</code></pre><h5 id="In-Julia:-13"><a class="docs-heading-anchor" href="#In-Julia:-13">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-13" title="Permalink"></a></h5><ul><li>we need to use symbolic values for <code>1</code> in defining  <code>_one</code>:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; _one = cos(Sym(1))^2 + sin(Sym(1))^2
   2         2
cos (1) + sin (1)

julia&gt; (_one - 1).evalf()
-0.e-124</code></pre><pre><code class="language-julia-repl hljs">julia&gt; (_one - 1).evalf(chop=true)
0</code></pre><hr/><h2 id="N-with-Julia"><a class="docs-heading-anchor" href="#N-with-Julia"><code>N</code> with <code>Julia</code></a><a id="N-with-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#N-with-Julia" title="Permalink"></a></h2><p>The <code>N</code> function is used to convert a symbolic number or boolean into a <code>Julia</code> counterpart.</p><pre><code class="language-julia-repl hljs">julia&gt; two = Sym(2)
2

julia&gt; a,b,c,d = two, sqrt(two), two^20, two^100
(2, sqrt(2), 1048576, 1267650600228229401496703205376)

julia&gt; N.((a,b,c,d))
(2, 1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1048576, 1267650600228229401496703205376)</code></pre><h2 id="lambdify"><a class="docs-heading-anchor" href="#lambdify"><code>lambdify</code></a><a id="lambdify-1"></a><a class="docs-heading-anchor-permalink" href="#lambdify" title="Permalink"></a></h2><p><code>subs</code> and <code>evalf</code> are good if you want to do simple evaluation, but if you intend to evaluate an expression at many points, there are more efficient ways.  For example, if you wanted to evaluate an expression at a thousand points, using SymPy would be far slower than it needs to be, especially if you only care about machine precision.  Instead, you should use libraries like <code>NumPy &lt;http://www.numpy.org/&gt;</code>_ and <code>SciPy &lt;http://www.scipy.org/&gt;</code>_.</p><p>The easiest way to convert a SymPy expression to an expression that can be numerically evaluated is to use the <code>lambdify</code> function.  <code>lambdify</code> acts like a <code>lambda</code> function, except it converts the SymPy names to the names of the given numerical library, usually NumPy.  For example</p><pre><code class="language-python hljs">    &gt;&gt;&gt; import numpy # doctest:+SKIP
    &gt;&gt;&gt; a = numpy.arange(10) # doctest:+SKIP
    &gt;&gt;&gt; expr = sin(x)
    &gt;&gt;&gt; f = lambdify(x, expr, &quot;numpy&quot;) # doctest:+SKIP
    &gt;&gt;&gt; f(a) # doctest:+SKIP
    [ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427
     -0.2794155   0.6569866   0.98935825  0.41211849]</code></pre><div class="admonition is-info"><header class="admonition-header">Alert</header><div class="admonition-body"><p><code>lambdify</code> uses <code>eval</code>.  Don&#39;t use it on unsanitized input.</p></div></div><h5 id="In-Julia:-14"><a class="docs-heading-anchor" href="#In-Julia:-14">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-14" title="Permalink"></a></h5><ul><li><code>lambdify</code> is defined seperately and with a different argument order: <code>lambdify(ex, vars=free_symbols(ex))</code>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; a = 0:10
0:10

julia&gt; @syms x
(x,)

julia&gt; expr = sin(x)
sin(x)

julia&gt; fn = lambdify(expr);

julia&gt; fn.(a)
11-element Vector{Float64}:
  0.0
  0.8414709848078965
  0.9092974268256817
  0.1411200080598672
 -0.7568024953079282
 -0.9589242746631385
 -0.27941549819892586
  0.6569865987187891
  0.9893582466233818
  0.4121184852417566
 -0.5440211108893698</code></pre><div class="admonition is-info"><header class="admonition-header">Technical note</header><div class="admonition-body"><p>The <code>lambdify</code>  function converts a symbolic  expression into  a <code>Julia</code>  expression, and then creates a function using <code>invokelatest</code>  to avoid  world  age issues.</p></div></div><p>More performant functions can be produced using the following pattern:</p><pre><code class="language-julia-repl hljs">julia&gt; ex = sin(x)^2 + x^2
 2      2
x  + sin (x)

julia&gt; body = convert(Expr, ex)
:(x ^ 2 + sin(x) ^ 2)

julia&gt; syms = Symbol.(free_symbols(ex))
1-element Vector{Symbol}:
 :x

julia&gt; fn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));

julia&gt; fn(pi)
9.869604401089358</code></pre><hr/><p>You can use other libraries than NumPy. For example, to use the standard library math module, use <code>&quot;math&quot;</code>.</p><pre><code class="language-python hljs">    &gt;&gt;&gt; f = lambdify(x, expr, &quot;math&quot;)
    &gt;&gt;&gt; f(0.1)
    0.0998334166468</code></pre><h5 id="In-Julia:-15"><a class="docs-heading-anchor" href="#In-Julia:-15">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-15" title="Permalink"></a></h5><ul><li>this doesn&#39;t apply, so is not implemented.</li></ul><hr/><p>To use lambdify with numerical libraries that it does not know about, pass a dictionary of <code>sympy_name:numerical_function</code> pairs.  For example</p><pre><code class="language-python hljs">    &gt;&gt;&gt; def mysin(x):
    ...     &quot;&quot;&quot;
    ...     My sine. Note that this is only accurate for small x.
    ...     &quot;&quot;&quot;
    ...     return x
    &gt;&gt;&gt; f = lambdify(x, expr, {&quot;sin&quot;:mysin})
    &gt;&gt;&gt; f(0.1)
    0.1</code></pre><h5 id="In-Julia:-16"><a class="docs-heading-anchor" href="#In-Julia:-16">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-16" title="Permalink"></a></h5><ul><li>The <code>fns</code> dictionary coud be used to do this, though due to the call of <code>eval</code>, we must do this in the proper module:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; mysin(x) = cos(x)
mysin (generic function with 1 method)

julia&gt; ex = sin(x)
sin(x)

julia&gt; body = SymPy.walk_expression(ex, fns=Dict(&quot;sin&quot; =&gt; :mysin))
:(mysin(x))

julia&gt; syms = (:x,)
(:x,)

julia&gt; fn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));

julia&gt; fn(0)
1.0</code></pre><hr/><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>Write an advanced numerics section</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gotchas/">« Gotchas</a><a class="docs-footer-nextpage" href="../simplification/">Simplification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Thursday 28 September 2023 14:56">Thursday 28 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
