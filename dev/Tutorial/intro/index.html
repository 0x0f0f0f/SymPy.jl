<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · SymPy</title><meta name="title" content="Introduction · SymPy"/><meta property="og:title" content="Introduction · SymPy"/><meta property="twitter:title" content="Introduction · SymPy"/><meta name="description" content="Documentation for SymPy."/><meta property="og:description" content="Documentation for SymPy."/><meta property="twitter:description" content="Documentation for SymPy."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymPy</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/">Examples</a></li><li><span class="tocitem">SymPy tutorial</span><ul><li><a class="tocitem" href="../">About</a></li><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#What-is-Symbolic-Computation?"><span>What is Symbolic Computation?</span></a></li><li><a class="tocitem" href="#A-More-Interesting-Example"><span>A More Interesting Example</span></a></li><li><a class="tocitem" href="#The-Power-of-Symbolic-Computation"><span>The Power of Symbolic Computation</span></a></li><li><a class="tocitem" href="#Why-SymPy?"><span>Why SymPy?</span></a></li></ul></li><li><a class="tocitem" href="../gotchas/">Gotchas</a></li><li><a class="tocitem" href="../basic_operations/">Basic operations</a></li><li><a class="tocitem" href="../simplification/">Simplification</a></li><li><a class="tocitem" href="../calculus/">Calculus</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../matrices/">Matrices</a></li><li><a class="tocitem" href="../manipulation/">Advanced expression  manipulation</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference/API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">SymPy tutorial</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPy/SymPy.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPy/SymPy.jl/blob/master/docs/src/Tutorial/intro.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>Taken <a href="https://docs.sympy.org/latest/tutorial/intro.html">from</a> the  SymPy tutorial (version 1.3).</p><h2 id="What-is-Symbolic-Computation?"><a class="docs-heading-anchor" href="#What-is-Symbolic-Computation?">What is Symbolic Computation?</a><a id="What-is-Symbolic-Computation?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-Symbolic-Computation?" title="Permalink"></a></h2><p>Symbolic computation deals with the computation of mathematical objects symbolically.  This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.</p><p>Let&#39;s take an example. Say we wanted to use the built-in Python functions to compute square roots. We might do something like this</p><pre><code class="language-python hljs">   &gt;&gt;&gt; import math
   &gt;&gt;&gt; math.sqrt(9)
   3.0</code></pre><h5 id="In-Julia:"><a class="docs-heading-anchor" href="#In-Julia:">In <code>Julia</code>:</a><a id="In-Julia:-1"></a><a class="docs-heading-anchor-permalink" href="#In-Julia:" title="Permalink"></a></h5><ul><li>Of course, <code>sqrt</code> is already there:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; sqrt(9)
3.0</code></pre><hr/><p>9 is a perfect square, so we got the exact answer, 3. But suppose we computed the square root of a number that isn&#39;t a perfect square</p><pre><code class="language-python hljs">   &gt;&gt;&gt; math.sqrt(8)
   2.82842712475</code></pre><h5 id="In-Julia:-2"><a class="docs-heading-anchor" href="#In-Julia:-2">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-2" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; sqrt(8)
2.8284271247461903</code></pre><hr/><p>Here we got an approximate result. 2.82842712475 is not the exact square root of 8 (indeed, the actual square root of 8 cannot be represented by a finite decimal, since it is an irrational number).  If all we cared about was the decimal form of the square root of 8, we would be done.</p><p>But suppose we want to go further. Recall that <span>$\sqrt{8} = \sqrt{4\cdot 2} = 2\sqrt{2}$</span>.  We would have a hard time deducing this from the above result. This is where symbolic computation comes in.  With a symbolic computation system like SymPy, square roots of numbers that are not perfect squares are left unevaluated by default</p><pre><code class="language-python hljs">   &gt;&gt;&gt; import sympy
   &gt;&gt;&gt; sympy.sqrt(3)
   sqrt(3)</code></pre><h5 id="In-Julia:-3"><a class="docs-heading-anchor" href="#In-Julia:-3">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-3" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; using SymPy

julia&gt; sympy.sqrt(3)
√3</code></pre><ul><li>When <code>SymPy</code> is loaded, the <code>sqrt</code> function is overloaded for symbolic objects, so this could also be done through:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; sqrt(Sym(3))
√3</code></pre><hr/><p>Furthermore–-and this is where we start to see the real power of symbolic computation–-symbolic results can be symbolically simplified.</p><pre><code class="language-python hljs">   &gt;&gt;&gt; sympy.sqrt(8)
   2*sqrt(2)</code></pre><h5 id="In-Julia:-4"><a class="docs-heading-anchor" href="#In-Julia:-4">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-4" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; sympy.sqrt(8)
2⋅√2</code></pre><hr/><h2 id="A-More-Interesting-Example"><a class="docs-heading-anchor" href="#A-More-Interesting-Example">A More Interesting Example</a><a id="A-More-Interesting-Example-1"></a><a class="docs-heading-anchor-permalink" href="#A-More-Interesting-Example" title="Permalink"></a></h2><p>The above example starts to show how we can manipulate irrational numbers exactly using SymPy.  But it is much more powerful than that.  Symbolic computation systems (which by the way, are also often called computer algebra systems, or just CASs) such as SymPy are capable of computing symbolic expressions with variables.</p><p>As we will see later, in SymPy, variables are defined using <code>symbols</code>. Unlike many symbolic manipulation systems, variables in SymPy must be defined before they are used (the reason for this will be discussed in the :ref:<code>next section &lt;tutorial-gotchas-symbols&gt;</code>).</p><p>Let us define a symbolic expression, representing the mathematical expression <code>x + 2y</code>.</p><pre><code class="language-python hljs">   &gt;&gt;&gt; from sympy import symbols
   &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;)
   &gt;&gt;&gt; expr = x + 2*y
   &gt;&gt;&gt; expr
   x + 2*y</code></pre><h5 id="In-Julia:-5"><a class="docs-heading-anchor" href="#In-Julia:-5">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-5" title="Permalink"></a></h5><ul><li>the command <code>from sympy import *</code> is <em>essentially</em> run (only functions are &quot;imported&quot;, not all objects), so this becomes the same after adjusting the quotes:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; @syms x, y
(x, y)

julia&gt; expr = x + 2*y
x + 2⋅y</code></pre><hr/><p>Note that we wrote <code>x + 2*y</code> just as we would if <code>x</code> and <code>y</code> were ordinary Python variables. But in this case, instead of evaluating to something, the expression remains as just <code>x + 2*y</code>.  Now let us play around with it:</p><pre><code class="language-python hljs">   &gt;&gt;&gt; expr + 1
   x + 2*y + 1
   &gt;&gt;&gt; expr - x
   2*y</code></pre><h5 id="In-Julia:-6"><a class="docs-heading-anchor" href="#In-Julia:-6">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-6" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expr + 1
x + 2⋅y + 1</code></pre><pre><code class="language-julia-repl hljs">julia&gt; expr - x
2⋅y</code></pre><hr/><p>Notice something in the above example.  When we typed <code>expr - x</code>, we did not get <code>x + 2*y - x</code>, but rather just <code>2*y</code>.  The <code>x</code> and the <code>-x</code> automatically canceled one another.  This is similar to how <code>sqrt(8)</code> automatically turned into <code>2*sqrt(2)</code> above.  This isn&#39;t always the case in SymPy, however:</p><pre><code class="language-python hljs">   &gt;&gt;&gt; x*expr
   x*(x + 2*y)</code></pre><h5 id="In-Julia:-7"><a class="docs-heading-anchor" href="#In-Julia:-7">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-7" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; x*expr
x⋅(x + 2⋅y)</code></pre><hr/><p>Here, we might have expected <code>x(x + 2y)</code> to transform into <code>x^2 + 2xy</code>, but instead we see that the expression was left alone.  This is a common theme in SymPy.  Aside from obvious simplifications like <code>x - x = 0</code> and <code>\sqrt{8} = 2\sqrt{2}</code>, most simplifications are not performed automatically.  This is because we might prefer the factored form <code>x(x + 2y)</code>, or we might prefer the expanded form <code>x^2 + 2xy</code>.  Both forms are useful in different circumstances. In SymPy, there are functions to go from one form to the other</p><pre><code class="language-python hljs">   &gt;&gt;&gt; from sympy import expand, factor
   &gt;&gt;&gt; expanded_expr = expand(x*expr)
   &gt;&gt;&gt; expanded_expr
   x**2 + 2*x*y
   &gt;&gt;&gt; factor(expanded_expr)
   x*(x + 2*y)</code></pre><h5 id="In-Julia:-8"><a class="docs-heading-anchor" href="#In-Julia:-8">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-8" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; expanded_expr = expand(x*expr)
 2
x  + 2⋅x⋅y</code></pre><pre><code class="language-julia-repl hljs">julia&gt; factor(expanded_expr)
x⋅(x + 2⋅y)</code></pre><hr/><h2 id="The-Power-of-Symbolic-Computation"><a class="docs-heading-anchor" href="#The-Power-of-Symbolic-Computation">The Power of Symbolic Computation</a><a id="The-Power-of-Symbolic-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-of-Symbolic-Computation" title="Permalink"></a></h2><p>The real power of a symbolic computation system such as SymPy is the ability to do all sorts of computations symbolically.  SymPy can simplify expressions, compute derivatives, integrals, and limits, solve equations, work with matrices, and much, much more, and do it all symbolically.  It includes modules for plotting, printing (like 2D pretty printed output of math formulas, or <code>\LaTeX</code>), code generation, physics, statistics, combinatorics, number theory, geometry, logic, and more. Here is a small sampling of the sort of symbolic power SymPy is capable of, to whet your appetite.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; from sympy import *
 &gt;&gt;&gt; x, t, z, nu = symbols(&#39;x t z nu&#39;)</code></pre><h5 id="In-Julia:-9"><a class="docs-heading-anchor" href="#In-Julia:-9">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-9" title="Permalink"></a></h5><ul><li>again, the functions in the <code>sympy</code> module are already imported:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; @syms x, t, z, nu
(x, t, z, nu)</code></pre><hr/><p>This will make all further examples pretty print with unicode characters.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; init_printing(use_unicode=True)</code></pre><h5 id="In-Julia:-10"><a class="docs-heading-anchor" href="#In-Julia:-10">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-10" title="Permalink"></a></h5><ul><li>The printing in <code>Julia</code> is controlled by <code>show</code> and the appropriate MIME type.</li></ul><hr/><p>Take the derivative of <span>$\sin{(x)}e^x$</span>.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; diff(sin(x)*exp(x), x)
  x           x
 ℯ ⋅sin(x) + ℯ ⋅cos(x)</code></pre><h5 id="In-Julia:-11"><a class="docs-heading-anchor" href="#In-Julia:-11">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-11" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; diff(sin(x)*exp(x), x)
 x           x
ℯ ⋅sin(x) + ℯ ⋅cos(x)</code></pre><hr/><p>Compute <span>$\int(e^x\sin{(x)} + e^x\cos{(x)})\,dx$</span>.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; integrate(exp(x)*sin(x) + exp(x)*cos(x), x)
  x
 ℯ ⋅sin(x)</code></pre><h5 id="In-Julia:-12"><a class="docs-heading-anchor" href="#In-Julia:-12">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-12" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; integrate(exp(x)*sin(x) + exp(x)*cos(x), x)
 x
ℯ ⋅sin(x)</code></pre><hr/><p>Compute <span>$\int_{-\infty}^\infty \sin{(x^2)}\,dx$</span>.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; integrate(sin(x**2), (x, -oo, oo))
 √2⋅√π
 ─────
   2</code></pre><h5 id="In-Julia:-13"><a class="docs-heading-anchor" href="#In-Julia:-13">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-13" title="Permalink"></a></h5><ul><li>In <code>Julia</code> <code>**</code> is <code>^</code>:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; integrate(sin(x^2), (x, -oo, oo))
√2⋅√π
─────
  2</code></pre><hr/><p>Find <span>$\lim_{x\to 0}\frac{\sin{(x)}}{x}$</span>.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; limit(sin(x)/x, x, 0)
 1</code></pre><h5 id="In-Julia:-14"><a class="docs-heading-anchor" href="#In-Julia:-14">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-14" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; limit(sin(x)/x, x, 0)
1</code></pre><hr/><p>Solve <span>$x^2 - 2 = 0$</span>.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; solve(x**2 - 2, x)
 [-√2, √2]</code></pre><h5 id="In-Julia:-15"><a class="docs-heading-anchor" href="#In-Julia:-15">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-15" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; solve(x^2 - 2, x)
2-element Vector{Sym}:
 -√2
  √2</code></pre><hr/><p>Solve the differential equation <code>y&#39;&#39; - y = e^t</code>.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; y = Function(&#39;y&#39;)
 &gt;&gt;&gt; dsolve(Eq(y(t).diff(t, t) - y(t), exp(t)), y(t))
            -t   ⎛     t⎞  t
 y(t) = C₂⋅ℯ   + ⎜C₁ + ─⎟⋅ℯ
                 ⎝     2⎠</code></pre><h5 id="In-Julia:-16"><a class="docs-heading-anchor" href="#In-Julia:-16">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-16" title="Permalink"></a></h5><ul><li><code>Function</code> is not a function, so is not exported. We must qualify its use:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; y = sympy.Function(&quot;y&quot;)
PyObject y

julia&gt; dsolve(Eq(y(t).diff(t, t) - y(t), exp(t)), y(t)) |&gt; string # work around formatting issue
&quot;Eq(y(t), C2*exp(-t) + (C1 + t/2)*exp(t))&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Why `string`?</header><div class="admonition-body"><p>The uses of <code>|&gt; string</code> above and elsewhere throughout  this translation  of  the SymPy tutorial is only for technical reasons  related to  how <code>Documenter.jl</code> parses  the output. It is not idiomatic, or suggested; it  only allows the cell  to  be tested programatically for  regressions.</p></div></div><ul><li>This is made more familiar looking with the <code>SymFunction</code> class:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; y = SymFunction(&quot;y&quot;)
y

julia&gt; D = Differential(t);

julia&gt; dsolve(D(D(y))(t) - y(t) - exp(t), y(t)) |&gt; string
&quot;Eq(y(t), C2*exp(-t) + (C1 + t/2)*exp(t))&quot;</code></pre><p>Even more so, <code>@syms</code> allows the specification of symbolic functions, as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms y()::real t
(y, t)

julia&gt; dsolve(D(D(y))(t) - y(t) - exp(t), y(t)) |&gt; string
&quot;Eq(y(t), C2*exp(-t) + (C1 + t/2)*exp(t))&quot;</code></pre><hr/><p>Find the eigenvalues of <code>\left[\begin{smallmatrix}1 &amp; 2\\2 &amp; 2\end{smallmatrix}\right]</code>.</p><pre><code class="language-python hljs"> &gt;&gt;&gt; Matrix([[1, 2], [2, 2]]).eigenvals()
 ⎧3   √17       √17   3   ⎫
 ⎨─ + ───: 1, - ─── + ─: 1⎬
 ⎩2    2         2    2   ⎭</code></pre><h5 id="In-Julia:-17"><a class="docs-heading-anchor" href="#In-Julia:-17">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-17" title="Permalink"></a></h5><ul><li>Like <code>Function</code>, <code>Matrix</code> is not imported and its use must by qualified (<code>Julia</code> matrix conventions  are used):</li></ul><pre><code class="language-julia-repl hljs">julia&gt; out = sympy.Matrix([1 2; 2 2]).eigenvals();

julia&gt; sort(collect(keys(out)))
2-element Vector{Any}:
 3/2 - sqrt(17)/2
 3/2 + sqrt(17)/2</code></pre><p>(The keys are returned  as type  <code>Any</code>, they may format more nicely if converted, say, through  <code>convert(Dict{Sym,Sym},out)</code>.)</p><hr/><p>Rewrite the Bessel function <span>$J_{\nu}\left(z\right)$</span> in terms of the spherical Bessel function <span>$j_\nu(z)$</span>.</p><pre><code class="language-python hljs">  &gt;&gt;&gt; besselj(nu, z).rewrite(jn)
  √2⋅√z⋅jn(ν - 1/2, z)
  ────────────────────
           √π</code></pre><h5 id="In-Julia:-18"><a class="docs-heading-anchor" href="#In-Julia:-18">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-18" title="Permalink"></a></h5><ul><li>we need to call in <code>SpecialFunctions</code></li><li><code>jn</code> is imported as a function object and this is not what SymPy expects, instead we pass in the object <code>sympy.jn</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; using SpecialFunctions


julia&gt; @syms ν z
(ν, z)

julia&gt; besselj(ν, z).rewrite(sympy.jn)
√2⋅√z⋅jn(ν - 1/2, z)
────────────────────
         √π</code></pre><hr/><p>Print <span>$\int_{0}^{\pi} \cos^{2}{\left (x \right )}\, dx$</span> using <span>$\LaTeX$</span>.</p><pre><code class="language-python hljs">  &gt;&gt;&gt; latex(Integral(cos(x)**2, (x, 0, pi)))
  \int_{0}^{\pi} \cos^{2}{\left (x \right )}\, dx</code></pre><h5 id="In-Julia:-19"><a class="docs-heading-anchor" href="#In-Julia:-19">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-19" title="Permalink"></a></h5><ul><li><p>Latex printing occurs when the mime type is requested. However, the <code>latex</code> function can be called directly. However, this is not imported by default to avoid name collisions, and so must be qualified. Below, the latex is output as a string, though</p></li><li><p><code>Integral</code>, like <code>Function</code> and <code>Matrix</code> is not a function and must be qualified</p></li><li><p><code>**</code> must become <code>^</code></p></li><li><p>and we use  <code>PI</code>, an alias for <code>sympy.pi</code>, the symbolic value for <span>$\pi$</span>:</p></li></ul><pre><code class="language-julia-repl hljs">julia&gt; sympy.latex(sympy.Integral(cos(x)^2, (x, 0, PI)))
&quot;\\int\\limits_{0}^{\\pi} \\cos^{2}{\\left(x \\right)}\\, dx&quot;</code></pre><hr/><h2 id="Why-SymPy?"><a class="docs-heading-anchor" href="#Why-SymPy?">Why SymPy?</a><a id="Why-SymPy?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-SymPy?" title="Permalink"></a></h2><p>There are many computer algebra systems out there.  <code>This &lt;http://en.wikipedia.org/wiki/List_of_computer_algebra_systems&gt;</code>_ Wikipedia article lists many of them.  What makes SymPy a better choice than the alternatives?</p><p>First off, SymPy is completely free. It is open source, and licensed under the liberal BSD license, so you can modify the source code and even sell it if you want to.  This contrasts with popular commercial systems like Maple or Mathematica that cost hundreds of dollars in licenses.</p><p>Second, SymPy uses Python.  Most computer algebra systems invent their own language. Not SymPy. SymPy is written entirely in Python, and is executed entirely in Python. This means that if you already know Python, it is much easier to get started with SymPy, because you already know the syntax (and if you don&#39;t know Python, it is really easy to learn).  We already know that Python is a well-designed, battle-tested language.  The SymPy developers are confident in their abilities in writing mathematical software, but programming language design is a completely different thing.  By reusing an existing language, we are able to focus on those things that matter: the mathematics.</p><p>Another computer algebra system, Sage also uses Python as its language.  But Sage is large, with a download of over a gigabyte.  An advantage of SymPy is that it is lightweight.  In addition to being relatively small, it has no dependencies other than Python, so it can be used almost anywhere easily. Furthermore, the goals of Sage and the goals of SymPy are different.  Sage aims to be a full featured system for mathematics, and aims to do so by compiling all the major open source mathematical systems together into one. When you call some function in Sage, such as <code>integrate</code>, it calls out to one of the open source packages that it includes.  In fact, SymPy is included in Sage.  SymPy on the other hand aims to be an independent system, with all the features implemented in SymPy itself.</p><p>A final important feature of SymPy is that it can be used as a library. Many computer algebra systems focus on being usable in interactive environments, but if you wish to automate or extend them, it is difficult to do.  With SymPy, you can just as easily use it in an interactive Python environment or import it in your own Python application.  SymPy also provides APIs to make it easy to extend it with your own custom functions.</p><h5 id="In-Julia:-20"><a class="docs-heading-anchor" href="#In-Julia:-20">In <code>Julia</code>:</a><a class="docs-heading-anchor-permalink" href="#In-Julia:-20" title="Permalink"></a></h5><p>There are other symbolic packages for <code>Julia</code>:</p><ul><li><a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a></li><li><a href="https://github.com/chakravala/Reduce.jl">Reduce.jl</a></li><li><a href="https://github.com/jlapeyre/Symata.jl">Symata.jl</a></li><li><a href="https://github.com/symengine/SymEngine.jl">SymEngine.jl</a></li><li><a href="https://github.com/Nemocas/Nemo.jl">Nemo.jl</a></li><li><a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils</a></li></ul><p>SymPy is an attractive alternative as <code>PyCall</code> makes most all of its functinality directly available and SymPy is fairly feature rich.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« About</a><a class="docs-footer-nextpage" href="../gotchas/">Gotchas »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 15 November 2023 20:22">Wednesday 15 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
