var documenterSearchIndex = {"docs":
[{"location":"Tutorial/calculus/#Calculus","page":"Calculus","title":"Calculus","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"From","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"This section covers how to do basic calculus tasks such as derivatives, integrals, limits, and series expansions in SymPy.  If you are not familiar with the math of any part of this section, you may safely skip it.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> from sympy import *\n    >>> x, y, z = symbols('x y z')\n    >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"using SymPy\nsympy.init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/calculus/#In-Julia","page":"Calculus","title":"In Julia","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"we have","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"all functions from sympy are imported by default\nunicode printing is enabled by default\ndouble quotes are for strings","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"so the above can be:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> using SymPy\n\njulia> x, y, z = symbols(\"x y z\")\n(x, y, z)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"We primarily will use the convenient @syms macro, as with","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> @syms x y z\n(x, y, z)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/#Derivatives","page":"Calculus","title":"Derivatives","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To take derivatives, use the diff function.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> diff(cos(x), x)\n    -sin(x)\n    >>> diff(exp(x**2), x)\n         ⎛ 2⎞\n         ⎝x ⎠\n    2⋅x⋅ℯ","category":"page"},{"location":"Tutorial/calculus/#In-Julia-2","page":"Calculus","title":"In  Julia","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"save for ** becoming ^ this is the same","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> diff(cos(x), x)\n-sin(x)\n\njulia> diff(exp(x^2), x)\n     ⎛ 2⎞\n     ⎝x ⎠\n2⋅x⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"diff can take multiple derivatives at once.  To take multiple derivatives, pass the variable as many times as you wish to differentiate, or pass a number after the variable.  For example, both of the following find the third derivative of x^4.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> diff(x**4, x, x, x)\n    24⋅x\n    >>> diff(x**4, x, 3)\n    24⋅x","category":"page"},{"location":"Tutorial/calculus/#In-Julia-3","page":"Calculus","title":"In Julia","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> diff(x^4, x, x, x)\n24⋅x\n\njulia> diff(x^4, x, 3)\n24⋅x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"You can also take derivatives with respect to many variables at once.  Just pass each derivative in order, using the same syntax as for single variable derivatives.  For example, each of the following will compute fracpartial^7partial xpartial y^2partial z^4 e^x y z.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = exp(x*y*z)\n    >>> diff(expr, x, y, y, z, z, z, z)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ\n    >>> diff(expr, x, y, 2, z, 4)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ\n    >>> diff(expr, x, y, y, z, 4)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/#In-Julia:","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr = exp(x*y*z)\n x⋅y⋅z\nℯ\n\njulia> diff(expr, x, y, y, z, z, z, z)\n 3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\nx ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ\n\njulia> diff(expr, x, y, 2, z, 4)\n 3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\nx ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ\n\njulia> diff(expr, x, y, y, z, 4)\n 3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\nx ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"diff can also be called as a method.  The two ways of calling diff are exactly the same, and are provided only for convenience.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr.diff(x, y, y, z, 4)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-2","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr.diff(x, y, y, z, 4)\n 3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\nx ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To create an unevaluated derivative, use the Derivative class.  It has the same syntax as diff.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> deriv = Derivative(expr, x, y, y, z, 4)\n    >>> deriv\n         7\n        ∂     ⎛ x⋅y⋅z⎞\n    ──────────⎝ℯ    ⎠\n        4   2\n      ∂z  ∂y  ∂x","category":"page"},{"location":"Tutorial/calculus/#In-Julia,","page":"Calculus","title":"In Julia,","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"classes are not exported, so we use sympy.Derivative:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> deriv = sympy.Derivative(expr, x, y, y, z, 4)\n     7\n    ∂     ⎛ x⋅y⋅z⎞\n──────────⎝ℯ     ⎠\n  4   2\n∂z  ∂y  ∂x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To evaluate an unevaluated derivative, use the doit method.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> deriv.doit()\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-3","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> deriv.doit()\n 3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\nx ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"These unevaluated objects are useful for delaying the evaluation of the derivative, or for printing purposes.  They are also used when SymPy does not know how to compute the derivative of an expression (for example, if it contains an undefined function, which are described in the :ref:Solving Differential Equations <tutorial-dsolve> section).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"Derivatives of unspecified order can be created using tuple (x, n) where n is the order of the derivative with respect to x.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> m, n, a, b = symbols('m n a b')\n    >>> expr = (a*x + b)**m\n    >>> expr.diff((x, n))\n      n\n     ∂ ⎛         m⎞\n    ───⎝(a⋅x + b) ⎠\n      n\n    ∂x","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-4","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> @syms m n a b\n(m, n, a, b)\n\njulia> expr = (a*x + b)^m;  string(expr)\n         m\nm\n\njulia> expr.diff((x, n)) |> string\n\"Derivative((a*x + b)^m, (x, n))\"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/#Integrals","page":"Calculus","title":"Integrals","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To compute an integral, use the integrate function.  There are two kinds of integrals, definite and indefinite.  To compute an indefinite integral, that is, an antiderivative, or primitive, just pass the variable after the expression.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integrate(cos(x), x)\n    sin(x)","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-5","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> integrate(cos(x), x)\nsin(x)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"Note that SymPy does not include the constant of integration.  If you want it, you can add one yourself, or rephrase your problem as a differential equation and use dsolve to solve it, which does add the constant (see :ref:tutorial-dsolve).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"note: Quick tip\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"infty in SymPy is oo (that's the lowercase letter \"oh\" twice).  This    is because oo looks like infty, and is easy to type.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To compute a definite integral, pass the argument (integration_variable, lower_limit, upper_limit).  For example, to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"\n\n   int_0^infty e^-xdx\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"we would do","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integrate(exp(-x), (x, 0, oo))\n    1","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-6","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> integrate(exp(-x), (x, 0, oo))\n1","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"As with indefinite integrals, you can pass multiple limit tuples to perform a multiple integral.  For example, to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"\n   int_-infty^inftyint_-infty^infty e^- x^2 - y^2 dx dy\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"do","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integrate(exp(-x**2 - y**2), (x, -oo, oo), (y, -oo, oo))\n    π","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-7","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> integrate(exp(-x^2 - y^2), (x, -oo, oo), (y, -oo, oo))\nπ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If integrate is unable to compute an integral, it returns an unevaluated Integral object.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = integrate(x**x, x)\n    >>> print(expr)\n    Integral(x**x, x)\n    >>> expr\n    ⌠\n    ⎮  x\n    ⎮ x  dx\n    ⌡","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-8","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr = integrate(x^x, x)\n⌠\n⎮  x\n⎮ x  dx\n⌡","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"As with Derivative, you can create an unevaluated integral using Integral.  To later evaluate this integral, call doit.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = Integral(log(x)**2, x)\n    >>> expr\n    ⌠\n    ⎮    2\n    ⎮ log (x) dx\n    ⌡\n    >>> expr.doit()\n             2\n    x⋅log (x) - 2⋅x⋅log(x) + 2⋅x","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-9","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"the Integral class is not exported, so it must be qualified:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr = sympy.Integral(log(x)^2, x)\n⌠\n⎮    2\n⎮ log (x) dx\n⌡","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr.doit()\n     2\nx⋅log (x) - 2⋅x⋅log(x) + 2⋅x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"integrate uses powerful algorithms that are always improving to compute both definite and indefinite integrals, including heuristic pattern matching type algorithms, a partial implementation of the Risch algorithm <http://en.wikipedia.org/wiki/Risch_algorithm>, and an algorithm using Meijer G-functions <http://en.wikipedia.org/wiki/Meijer_g-function> that is useful for computing integrals in terms of special functions, especially definite integrals.  Here is a sampling of some of the power of integrate.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integ = Integral((x**4 + x**2*exp(x) - x**2 - 2*x*exp(x) - 2*x -\n    ...     exp(x))*exp(x)/((x - 1)**2*(x + 1)**2*(exp(x) + 1)), x)\n    >>> integ\n    ⌠\n    ⎮ ⎛ 4    2  x    2        x          x⎞  x\n    ⎮ ⎝x  + x ⋅ℯ  - x  - 2⋅x⋅ℯ  - 2⋅x - ℯ ⎠⋅ℯ\n    ⎮ ──────────────────────────────────────── dx\n    ⎮               2        2 ⎛ x    ⎞\n    ⎮        (x - 1) ⋅(x + 1) ⋅⎝ℯ  + 1⎠\n    ⌡\n    >>> integ.doit()\n                     x\n       ⎛ x    ⎞     ℯ\n    log⎝ℯ  + 1⎠ + ──────\n                   2\n                  x  - 1\n\n    >>> integ = Integral(sin(x**2), x)\n    >>> integ\n    ⌠\n    ⎮    ⎛ 2⎞\n    ⎮ sin⎝x ⎠ dx\n    ⌡\n    >>> integ.doit()\n                    ⎛√2⋅x⎞\n    3⋅√2⋅√π⋅fresnels⎜────⎟⋅Γ(3/4)\n                    ⎝ √π ⎠\n    ─────────────────────────────\n               8⋅Γ(7/4)\n\n    >>> integ = Integral(x**y*exp(-x), (x, 0, oo))\n    >>> integ\n    ∞\n    ⌠\n    ⎮  y  -x\n    ⎮ x ⋅ℯ   dx\n    ⌡\n    0\n    >>> integ.doit()\n    ⎧ Γ(y + 1)    for -re(y) < 1\n    ⎪\n    ⎪∞\n    ⎪⌠\n    ⎨⎮  y  -x\n    ⎪⎮ x ⋅ℯ   dx    otherwise\n    ⎪⌡\n    ⎪0\n    ⎩","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-10","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> integ = sympy.Integral((x^4 + x^2*exp(x) - x^2 - 2*x*exp(x) - 2*x - exp(x))*exp(x)/((x - 1)^2*(x + 1)^2*(exp(x) + 1)), x)\n⌠\n⎮ ⎛ 4    2  x    2        x          x⎞  x\n⎮ ⎝x  + x ⋅ℯ  - x  - 2⋅x⋅ℯ  - 2⋅x - ℯ ⎠⋅ℯ\n⎮ ──────────────────────────────────────── dx\n⎮               2        2 ⎛ x    ⎞\n⎮        (x - 1) ⋅(x + 1) ⋅⎝ℯ  + 1⎠\n⌡\n\njulia> integ.doit()  |> string\n\"log(exp(x) + 1) + exp(x)/(x^2 - 1)\"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> integ = sympy.Integral(sin(x^2), x)\n⌠\n⎮    ⎛ 2⎞\n⎮ sin⎝x ⎠ dx\n⌡\n\njulia> integ.doit() |> string\n\"3*sqrt(2)*sqrt(pi)*fresnels(sqrt(2)*x/sqrt(pi))*gamma(3/4)/(8*gamma(7/4))\"\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> integ = sympy.Integral(x^y*exp(-x), (x, 0, oo))\n∞\n⌠\n⎮  y  -x\n⎮ x ⋅ℯ   dx\n⌡\n0\n\njulia> integ.doit()\n⎧ Γ(y + 1)    for re(y) > -1\n⎪\n⎪∞\n⎪⌠\n⎨⎮  y  -x\n⎪⎮ x ⋅ℯ   dx    otherwise\n⎪⌡\n⎪0\n⎩","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"This last example returned a Piecewise expression because the integral does not converge unless Re(y)  1","category":"page"},{"location":"Tutorial/calculus/#Limits","page":"Calculus","title":"Limits","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"SymPy can compute symbolic limits with the limit function.  The syntax to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"\n   lim_xto x_0 f(x)\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"is limit(f(x), x, x0).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> limit(sin(x)/x, x, 0)\n    1","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-11","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> limit(sin(x)/x, x, 0)\n1","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"In Julia, a pair can be used to indicate the limit:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> limit(sin(x)/x, x=>0)\n1","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"Sometimes, a  symbolic value  is  needed to have a  proper limit:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> limit((pi/2-x-acos(x))/x^3, x=>0)\n∞\n\njulia> limit((PI/2-x-acos(x))/x^3, x=>0)\n1/6\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"(In the  first case, the numerator is not 0  when x=0 due  to  roundoff error  in  computing  pi/2.)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"limit should be used instead of subs whenever the point of evaluation is a singularity.  Even though SymPy has objects to represent infty, using them for evaluation is not reliable because they do not keep track of things like rate of growth.  Also, things like infty - infty and fracinftyinfty return mathrmnan (not-a-number).  For example","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = x**2/exp(x)\n    >>> expr.subs(x, oo)\n    nan\n    >>> limit(expr, x, oo)\n    0","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-12","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr = x^2/exp(x)\n 2  -x\nx ⋅ℯ\n\njulia> expr.subs(x, oo)\nnan\n\njulia> limit(expr, x, oo)\n0","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"Like Derivative and Integral, limit has an unevaluated counterpart, Limit.  To evaluate it, use doit.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = Limit((cos(x) - 1)/x, x, 0)\n    >>> expr\n         ⎛cos(x) - 1⎞\n     lim ⎜──────────⎟\n    x─→0⁺⎝    x     ⎠\n    >>> expr.doit()\n    0","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-13","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr = sympy.Limit((cos(x) - 1)/x, x, 0)\n     ⎛cos(x) - 1⎞\n lim ⎜──────────⎟\nx─→0⁺⎝    x     ⎠\n\njulia> expr.doit()\n0","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To evaluate a limit at one side only, pass '+' or '-' as a third argument to limit.  For example, to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"\n   lim_xto 0^+frac1x\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"do","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> limit(1/x, x, 0, '+')\n    ∞","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-14","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> limit(1/x, x => 0, \"+\")\n∞","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"As opposed to","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> limit(1/x, x, 0, '-')\n    -∞","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-15","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> limit(1/x, x, 0, \"-\")\n-∞","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/#Series-Expansion","page":"Calculus","title":"Series Expansion","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"SymPy can compute asymptotic series expansions of functions around a point. To compute the expansion of f(x) around the point x = x_0 terms of order x^n, use f(x).series(x, x0, n).  x0 and n can be omitted, in which case the defaults x0=0 and n=6 will be used.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = exp(sin(x))\n    >>> expr.series(x, 0, 4)\n             2\n            x     ⎛ 4⎞\n    1 + x + ── + O⎝x ⎠\n            2","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-16","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr = exp(sin(x))\n sin(x)\nℯ\n\njulia> expr.series(x, 0, 4) |> string\n\"1 + x + x^2/2 + O(x^4)\"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"The O\\left (x^4\\right ) term at the end represents the Landau order term at x=0 (not to be confused with big O notation used in computer science, which generally represents the Landau order term at x=infty).  It means that all x terms with power greater than or equal to x^4 are omitted.  Order terms can be created and manipulated outside of series.  They automatically absorb higher order terms.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> x + x**3 + x**6 + O(x**4)\n         3    ⎛ 4⎞\n    x + x  + O⎝x ⎠\n    >>> x*O(1)\n    O(x)","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-17","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"O is not exported, so we must qualify it:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> x + x^3 + x^6 + sympy.O(x^4)\n     3    ⎛ 4⎞\nx + x  + O⎝x ⎠\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> x*sympy.O(1)\nO(x)\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If you do not want the order term, use the removeO method.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr.series(x, 0, 4).removeO()\n     2\n    x\n    ── + x + 1\n    2","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-18","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> expr.series(x, 0, 4).removeO()\n 2\nx\n── + x + 1\n2\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"The O notation supports arbitrary limit points (other than 0):","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> exp(x - 6).series(x, x0=6)\n                2          3          4          5\n         (x - 6)    (x - 6)    (x - 6)    (x - 6)         ⎛       6       ⎞\n    -5 + ──────── + ──────── + ──────── + ──────── + x + O⎝(x - 6) ; x → 6⎠\n            2          6          24        120","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-19","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> exp(x - 6).series(x, x0=6) |> string\n\"-5 + (x - 6)^2/2 + (x - 6)^3/6 + (x - 6)^4/24 + (x - 6)^5/120 + x + O((x - 6)^6, (x, 6))\"\n","category":"page"},{"location":"Tutorial/calculus/#Finite-differences","page":"Calculus","title":"Finite differences","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"So far we have looked at expressions with analytic derivatives and primitive functions respectively. But what if we want to have an expression to estimate a derivative of a curve for which we lack a closed form representation, or for which we don't know the functional values for yet. One approach would be to use a finite difference approach.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"The simplest way the differentiate using finite differences is to use the differentiate_finite function:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> f, g = symbols('f g', cls=Function)\n    >>> differentiate_finite(f(x)*g(x))\n    -f(x - 1/2)⋅g(x - 1/2) + f(x + 1/2)⋅g(x + 1/2)","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-20","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"differentiate_finite is not exported","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> @syms f(), g()\n(f, g)\n\njulia> sympy.differentiate_finite(f(x)*g(x))\n-f(x - 1/2)⋅g(x - 1/2) + f(x + 1/2)⋅g(x + 1/2)\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"(The functions f and g can also be created with SymFunction.)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"This form however does not respect the product rule.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If you already have a Derivative instance, you can use the as_finite_difference method to generate approximations of the derivative to arbitrary order:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> f = Function('f')\n    >>> dfdx = f(x).diff(x)\n    >>> dfdx.as_finite_difference()\n    -f(x - 1/2) + f(x + 1/2)","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-21","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> f = sympy.Function(\"f\")\nPyObject f\n\njulia> dfdx = f(x).diff(x)\nd\n──(f(x))\ndx\n\njulia> dfdx.as_finite_difference()\n-f(x - 1/2) + f(x + 1/2)\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"here the first order derivative was approximated around x using a minimum number of points (2 for 1st order derivative) evaluated equidistantly using a step-size of 1. We can use arbitrary steps (possibly containing symbolic expressions):","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> f = Function('f')\n    >>> d2fdx2 = f(x).diff(x, 2)\n    >>> h = Symbol('h')\n    >>> d2fdx2.as_finite_difference([-3*h,-h,2*h])\n    f(-3⋅h)   f(-h)   2⋅f(2⋅h)\n    ─────── - ───── + ────────\n         2        2        2\n      5⋅h      3⋅h     15⋅h","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-22","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> f = sympy.Function(\"f\")\nPyObject f\n\njulia> d2fdx2 = f(x).diff(x, 2)\n  2\n d\n───(f(x))\n  2\ndx\n\njulia> h = sympy.Symbol(\"h\")\nh","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> d2fdx2.as_finite_difference([-3*h,-h,2*h])\nf(-3⋅h)   f(-h)   2⋅f(2⋅h)\n─────── - ───── + ────────\n     2        2        2\n  5⋅h      3⋅h     15⋅h\n","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If you are just interested in evaluating the weights, you can do so manually:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> finite_diff_weights(2, [-3, -1, 2], 0)[-1][-1]\n    [1/5, -1/3, 2/15]","category":"page"},{"location":"Tutorial/calculus/#In-Julia:-23","page":"Calculus","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"the finite_diff_weights function that is not exported:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> sympy.finite_diff_weights(2, [-3, -1, 2], 0)[end][end]\n-2/15","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"note that we only need the last element in the last sublist returned from finite_diff_weights. The reason for this is that the function also generates weights for lower derivatives and using fewer points (see the documentation of finite_diff_weights for more details).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If using finite_diff_weights directly looks complicated, and the as_finite_difference method of Derivative instances is not flexible enough, you can use apply_finite_diff which takes order, x_list, y_list and x0 as parameters:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> x_list = [-3, 1, 2]\n    >>> y_list = symbols('a b c')\n    >>> apply_finite_diff(1, x_list, y_list, 0)\n      3⋅a   b   2⋅c\n    - ─── - ─ + ───\n       20   4    5","category":"page"},{"location":"Tutorial/calculus/#In-Julia,-2","page":"Calculus","title":"In Julia,","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"apply_finite_diff is not exported:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> xs = [-3, 1, 2]\n3-element Vector{Int64}:\n -3\n  1\n  2\n\njulia> @syms ys[1:3]\n(Sym[ys₁, ys₂, ys₃],)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"julia> sympy.apply_finite_diff(1, xs, ys, 0)\n  3⋅ys₁   ys₂   2⋅ys₃\n- ───── - ─── + ─────\n    20     4      5","category":"page"},{"location":"Tutorial/manipulation/#Advanced-Expression-Manipulation","page":"Advanced expression  manipulation","title":"Advanced Expression Manipulation","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"From  (version 1.3)","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"using SymPy\nsympy.init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"In this section, we discuss some ways that we can perform advanced manipulation of expressions.","category":"page"},{"location":"Tutorial/manipulation/#Understanding-Expression-Trees","page":"Advanced expression  manipulation","title":"Understanding Expression Trees","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"note: Quick Tip\nTo play with the srepr form of expressions in the SymPy Live shell, change the output format to Repr in the settings.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Before we can do this, we need to understand how expressions are represented in SymPy.  A mathematical expression is represented as a tree.  Let us take the expression 2^x + xy, i.e., 2**x + x*y.  We can see what this expression looks like internally by using srepr","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> from sympy import *\n    >>> x, y, z = symbols('x y z')\n\n    >>> expr = 2**x + x*y\n    >>> srepr(expr)\n    \"Add(Pow(Integer(2), Symbol('x')), Mul(Symbol('x'), Symbol('y')))\"","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"We replace the import command with a using command, as this will import functions (not Classes though) from sympy","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> using SymPy\n\njulia> @syms x, y, z\n(x, y, z)\n\njulia> expr = 2^x + x*y\n x\n2  + x⋅y\n\njulia> srepr(expr)\n\"Add(Pow(Integer(2), Symbol('x')), Mul(Symbol('x'), Symbol('y')))\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"The easiest way to tear this apart is to look at a diagrm of the expression tree. Here is a diagram.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"note: Note\nThis comes from dotprint(2**x + x*y, labelfunc=srepr). But we don't render digraph objects here","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"First, let's look at the leaves of this tree.  Symbols are instances of the class Symbol.  While we have been doing","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> x = symbols('x')","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-2","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> x = symbols(\"x\")\nx\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"we could have also done","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> x = Symbol('x')","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-3","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"this can be done, but @syms would be suggested:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> x = sympy.Symbol(\"x\")\nx\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> @syms x\n(x,)\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Either way, we get a Symbol with the name \"x\" [#symbols-fn]_.  For the number in the expression, 2, we got Integer(2).  Integer is the SymPy class for integers.  It is similar to the Python built-in type int, except that Integer plays nicely with other SymPy types.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"When we write 2**x, this creates a Pow object.  Pow is short for \"power\".","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> srepr(2**x)\n    \"Pow(Integer(2), Symbol('x'))\"","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-4","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"we replace ** by ^","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> srepr(2^x)\n\"Pow(Integer(2), Symbol('x'))\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"We could have created the same object by calling Pow(2, x)","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> Pow(2, x)\n    2**x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-5","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Pow is not a function, rather a managed property, so we must qualify it, as it wasn't brought in when loading the package","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> sympy.Pow(2, x)\n x\n2\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Note that in the srepr output, we see Integer(2), the SymPy version of integers, even though technically, we input 2, a Python int.  In general, whenever you combine a SymPy object with a non-SymPy object via some function or operation, the non-SymPy object will be converted into a SymPy object.  The function that does this is sympify [#sympify-fn]_.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> type(2)\n    <... 'int'>\n    >>> type(sympify(2))\n    <class 'sympy.core.numbers.Integer'>","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-6","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> typeof(2)\nInt64\n\njulia> typeof(sympify(2))\nSym\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"We have seen that 2**x is represented as Pow(2, x).  What about x*y?  As we might expect, this is the multiplication of x and y. The SymPy class for multiplication is Mul.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> srepr(x*y)\n    \"Mul(Symbol('x'), Symbol('y'))\"","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-7","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> srepr(x*y)\n\"Mul(Symbol('x'), Symbol('y'))\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Thus, we could have created the same object by writing Mul(x, y).","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> Mul(x, y)\n    x*y","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-8","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Again, Mul is not a function, so it must be qualified","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> sympy.Mul(x, y)\nx⋅y\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Now we get to our final expression, 2**x + x*y.  This is the addition of our last two objects, Pow(2, x), and Mul(x, y).  The SymPy class for addition is Add, so, as you might expect, to create this object, we use Add(Pow(2, x), Mul(x, y)).","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> Add(Pow(2, x), Mul(x, y))\n    2**x + x*y","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-9","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"We can import these operations to avoid qualifying them as done here:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> import_from(sympy, (:Add, :Mul, :Pow), typ=:Any)\n\njulia> Add(Pow(2, x), Mul(x, y))\n x\n2  + x⋅y\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"SymPy expression trees can have many branches, and can be quite deep or quite broad.  Here is a more complicated example","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr = sin(x*y)/2 - x**2 + 1/y\n    >>> srepr(expr)\n    \"Add(Mul(Integer(-1), Pow(Symbol('x'), Integer(2))), Mul(Rational(1, 2),\n    sin(Mul(Symbol('x'), Symbol('y')))), Pow(Symbol('y'), Integer(-1)))\"","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-10","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr = sin(x*y)/2 - x^2 + 1/y\n   2   sin(x⋅y)   1\n- x  + ──────── + ─\n          2       y\n\njulia> srepr(expr)\n\"Add(Mul(Integer(-1), Pow(Symbol('x'), Integer(2))), Mul(Rational(1, 2), sin(Mul(Symbol('x'), Symbol('y')))), Pow(Symbol('y'), Integer(-1)))\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Here is a diagram","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"note: Note\nproduced with dotprint(sin(x*y)/2 - x**2 + 1/y, labelfunc=srepr), but not rendered here","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"This expression reveals some interesting things about SymPy expression trees. Let's go through them one by one.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Let's first look at the term x**2.  As we expected, we see Pow(x, 2). One level up, we see we have Mul(-1, Pow(x, 2)).  There is no subtraction class in SymPy.  x - y is represented as x + -y, or, more completely, x + -1*y, i.e., Add(x, Mul(-1, y)).","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> srepr(x - y)\n    \"Add(Symbol('x'), Mul(Integer(-1), Symbol('y')))\"","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-11","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> srepr(x - y)\n\"Add(Symbol('x'), Mul(Integer(-1), Symbol('y')))\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Next, look at 1/y.  We might expect to see something like Div(1, y), but similar to subtraction, there is no class in SymPy for division.  Rather, division is represented by a power of -1.  Hence, we have Pow(y, -1). What if we had divided something other than 1 by y, like x/y?  Let's see.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr = x/y\n    >>> srepr(expr)\n    \"Mul(Symbol('x'), Pow(Symbol('y'), Integer(-1)))\"","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-12","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr = x/y\nx\n─\ny\n\njulia> srepr(expr)\n\"Mul(Symbol('x'), Pow(Symbol('y'), Integer(-1)))\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"We see that x/y is represented as x*y**-1, i.e., Mul(x, Pow(y, -1)).","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Finally, let's look at the sin(x*y)/2 term.  Following the pattern of the previous example, we might expect to see Mul(sin(x*y), Pow(Integer(2), -1)).  But instead, we have Mul(Rational(1, 2), sin(x*y)).  Rational numbers are always combined into a single term in a multiplication, so that when we divide by 2, it is represented as multiplying by 1/2.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Finally, one last note.  You may have noticed that the order we entered our expression and the order that it came out from srepr or in the graph were different.  You may have also noticed this phenomenon earlier in the tutorial.  For example","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"     >>> 1 + x\n     x + 1","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-13","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> 1 + x\nx + 1\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"This because in SymPy, the arguments of the commutative operations Add and Mul are stored in an arbitrary (but consistent!) order, which is independent of the order inputted (if you're worried about noncommutative multiplication, don't be.  In SymPy, you can create noncommutative Symbols using Symbol('A', commutative=False), and the order of multiplication for noncommutative Symbols is kept the same as the input).  Furthermore, as we shall see in the next section, the printing order and the order in which things are stored internally need not be the same either.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"note: Quick Tip\nThe way an expression is represented internally and the way it is printed are often not the same.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"In general, an important thing to keep in mind when working with SymPy expression trees is this:  the internal representation of an expression and the way it is printed need not be the same.  The same is true for the input form.   If some expression manipulation algorithm is not working in the way you expected it to, chances are, the internal representation of the object is different from what you thought it was.","category":"page"},{"location":"Tutorial/manipulation/#Recursing-through-an-Expression-Tree","page":"Advanced expression  manipulation","title":"Recursing through an Expression Tree","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Now that you know how expression trees work in SymPy, let's look at how to dig our way through an expression tree.  Every object in SymPy has two very important attributes, func, and args.","category":"page"},{"location":"Tutorial/manipulation/#func","page":"Advanced expression  manipulation","title":"func","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"func is the head of the object. For example, (x*y).func is Mul. Usually it is the same as the class of the object (though there are exceptions to this rule).","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Two notes about func.  First, the class of an object need not be the same as the one used to create it.  For example","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr = Add(x, x)\n    >>> expr.func\n    <class 'sympy.core.mul.Mul'>","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-14","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr = Add(x, x)\n2⋅x\n\njulia> expr.func\nPyObject <class 'sympy.core.mul.Mul'>\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"The output isn't as desired, as PyObjects don't show nicely here. We can ask for the name, which does display as desired:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr.func.__name__\n\"Mul\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"In SymPy the func and args properties are exported as functions in the module SymPy.Introspection.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"We created Add(x, x), so we might expect expr.func to be Add, but instead we got Mul.  Why is that?  Let's take a closer look at expr.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr\n    2*x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-15","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr\n2⋅x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Add(x, x), i.e., x + x, was automatically converted into Mul(2, x), i.e., 2*x, which is a Mul.   SymPy classes make heavy use of the __new__ class constructor, which, unlike __init__, allows a different class to be returned from the constructor.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Second, some classes are special-cased, usually for efficiency reasons [#singleton-fn]_.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> Integer(2).func\n    <class 'sympy.core.numbers.Integer'>\n    >>> Integer(0).func\n    <class 'sympy.core.numbers.Zero'>\n    >>> Integer(-1).func\n    <class 'sympy.core.numbers.NegativeOne'>","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-16","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> sympy.Integer(2).func.__name__\n\"Integer\"\n\njulia> sympy.Integer(0).func.__name__\n\"Zero\"\n\njulia> sympy.Integer(-1).func.__name__\n\"NegativeOne\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"For the most part, these issues will not bother us.  The special classes Zero, One, NegativeOne, and so on are subclasses of Integer, so as long as you use isinstance, it will not be an issue.","category":"page"},{"location":"Tutorial/manipulation/#args","page":"Advanced expression  manipulation","title":"args","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"args are the top-level arguments of the object.  (x*y).args would be (x, y).  Let's look at some examples","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr = 3*y**2*x\n    >>> expr.func\n    <class 'sympy.core.mul.Mul'>\n    >>> expr.args\n    (3, x, y**2)","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-17","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"The args property can be accessed exactly as func","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr = 3*y^2*x\n     2\n3⋅x⋅y\n\njulia> expr.func.__name__\n\"Mul\"\n\njulia> expr.args\n(3, x, y^2)\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"From this, we can see that expr == Mul(3, y**2, x).  In fact, we can see that we can completely reconstruct expr from its func and its args.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr.func(*expr.args)\n    3*x*y**2\n    >>> expr == expr.func(*expr.args)\n    True","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-18","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr.func(expr.args...)\n     2\n3⋅x⋅y\n\njulia> expr == expr.func(expr.args...)\ntrue\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Note that although we entered 3*y**2*x, the args are (3, x, y**2). In a Mul, the Rational coefficient will come first in the args, but other than that, the order of everything else follows no special pattern.  To be sure, though, there is an order.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr = y**2*3*x\n    >>> expr.args\n    (3, x, y**2)","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-19","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr = y^2*3*x\n     2\n3⋅x⋅y\n\njulia> expr.args\n(3, x, y^2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Mul's args are sorted, so that the same Mul will have the same args.  But the sorting is based on some criteria designed to make the sorting unique and efficient that has no mathematical significance.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"The srepr form of our expr is Mul(3, x, Pow(y, 2)).  What if we want to get at the args of Pow(y, 2).  Notice that the y**2 is in the third slot of expr.args, i.e., expr.args[2].","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr.args[2]\n    y**2","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-20","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr.args[2]\nx\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"So to get the args of this, we call expr.args[2].args.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr.args[2].args\n    (y, 2)","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-21","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Python uses 0-based indexing, so we bump the index by 1","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr.args[3].args\n(y, 2)\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Now what if we try to go deeper.  What are the args of y.  Or 2. Let's see.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> y.args\n    ()\n    >>> Integer(2).args\n    ()","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-22","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> y.args\n()\n\njulia> sympy.Integer(2).args\n()\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"They both have empty args.  In SymPy, empty args signal that we have hit a leaf of the expression tree.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"So there are two possibilities for a SymPy expression. Either it has empty args, in which case it is a leaf node in any expression tree, or it has args, in which case, it is a branch node of any expression tree.  When it has args, it can be completely rebuilt from its func and its args. This is expressed in the key invariant.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"note: Key Invariant\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Every well-formed SymPy expression must either have empty args or    satisfy expr == expr.func(expr.args...).","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"(Recall that in Python if a is a tuple, then f(*a) means to call f with arguments from the elements of a, e.g., f(*(1, 2, 3)) is the same as f(1, 2, 3).)","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"This key invariant allows us to write simple algorithms that walk expression trees, change them, and rebuild them into new expressions.","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-23","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Splatting replaces the *a term above, or f(a...).","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/#Walking-the-Tree","page":"Advanced expression  manipulation","title":"Walking the Tree","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"With this knowledge, let's look at how we can recurse through an expression tree.  The nested nature of args is a perfect fit for recursive functions. The base case will be empty args.  Let's write a simple function that goes through an expression and prints all the args at each level.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> def pre(expr):\n    ...     print(expr)\n    ...     for arg in expr.args:\n    ...         pre(arg)","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-24","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> function pre(expr)\n       @show expr\n       for arg in expr.args\n         pre(arg)\n       end\n       end\npre (generic function with 1 method)","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"See how nice it is that () signals leaves in the expression tree.  We don't even have to write a base case for our recursion; it is handled automatically by the for loop.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Let's test our function.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr = x*y + 1\n    >>> pre(expr)\n    x*y + 1\n    1\n    x*y\n    x\n    y","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-25","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Here we see the output:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr = x*y + 1\nx⋅y + 1\n\njulia> pre(expr)\nexpr = x*y + 1\nexpr = 1\nexpr = x*y\nexpr = x\nexpr = y\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Can you guess why we called our function pre?  We just wrote a pre-order traversal function for our expression tree.   See if you can write a post-order traversal function.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Such traversals are so common in SymPy that the generator functions preorder_traversal and postorder_traversal are provided to make such traversals easy.  We could have also written our algorithm as","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> for arg in preorder_traversal(expr):\n    ...     print(arg)\n    x*y + 1\n    1\n    x*y\n    x\n    y","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-26","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"The preorder_traversal function is not a function, so needs to be qualified:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> for arg in sympy.preorder_traversal(expr)\n         @show arg\n       end\narg = x*y + 1\narg = 1\narg = x*y\narg = x\narg = y\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/#Prevent-expression-evaluation","page":"Advanced expression  manipulation","title":"Prevent expression evaluation","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"There are generally two ways to prevent the evaluation, either pass an evaluate=False parameter while constructing the expression, or create an evaluation stopper by wrapping the expression with UnevaluatedExpr.","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"For example:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> from sympy import Add\n    >>> from sympy.abc import x, y, z\n    >>> x + x\n    2*x\n    >>> Add(x, x)\n    2*x\n    >>> Add(x, x, evaluate=False)\n    x + x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-27","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> @syms x y z\n(x, y, z)\n\njulia> x + x\n2⋅x\n\njulia> Add(x, x)\n2⋅x\n\njulia> Add(x, x, evaluate=False)\nx + x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"If you don't remember the class corresponding to the expression you want to build (operator overloading usually assumes evaluate=True), just use sympify and pass a string:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> from sympy import sympify\n    >>> sympify(\"x + x\", evaluate=False)\n    x + x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-28","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> sympify(\"x + x\", evaluate=false)\n2⋅x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Note that evaluate=False won't prevent future evaluation in later usages of the expression:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr = Add(x, x, evaluate=False)\n    >>> expr\n    x + x\n    >>> expr + x\n    3*x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-29","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr = Add(x, x, evaluate=false)\nx + x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr + x\n3⋅x","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"That's why the class UnevaluatedExpr comes handy. UnevaluatedExpr is a method provided by SymPy which lets the user keep an expression unevaluated. By unevaluated it is meant that the value inside of it will not interact with the expressions outside of it to give simplified outputs. For example:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> from sympy import UnevaluatedExpr\n    >>> expr = x + UnevaluatedExpr(x)\n    >>> expr\n    x + x\n    >>> x + expr\n    2*x + x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-30","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> import_from(sympy, (:UnevaluatedExpr,))\n\njulia> expr\nx + x\n\njulia> x + expr\n3⋅x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"The x remaining alone is the x wrapped by UnevaluatedExpr. To release it:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> (x + expr).doit()\n    3*x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-31","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> (x + expr).doit()\n3⋅x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Other examples:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> from sympy import *\n    >>> from sympy.abc import x, y, z\n    >>> uexpr = UnevaluatedExpr(S.One*5/7)*UnevaluatedExpr(S.One*3/4)\n    >>> uexpr\n    (5/7)*(3/4)\n    >>> x*UnevaluatedExpr(1/x)\n    x*1/x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-32","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> @syms x y z\n(x, y, z)\n\njulia> const S = sympy.S\nPyObject S\n\njulia> uexpr = UnevaluatedExpr(S.One * 5/7) * UnevaluatedExpr(S.One * 3/4)\n5/7⋅3/4\n\njulia> x * UnevaluatedExpr(1/x)\n  1\nx⋅─\n  x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"A point to be noted is that  UnevaluatedExpr cannot prevent the evaluation of an expression which is given as argument. For example:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> expr1 = UnevaluatedExpr(x + x)\n    >>> expr1\n    2*x\n    >>> expr2 = sympify('x + x', evaluate=False)\n    >>> expr2\n    x + x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-33","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> expr1 = UnevaluatedExpr(x + x)\n2⋅x\n\njulia> expr2 = sympify(\"x + x\", evaluate=False)\n2⋅x\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"Remember that expr2 will be evaluated if included into another expression. Combine both of the methods to prevent both inside and outside evaluations:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> UnevaluatedExpr(sympify(\"x + x\", evaluate=False)) + y\n    y + x + x","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-34","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> UnevaluatedExpr(sympify(\"x + x\", evaluate=False)) + y\ny + 2⋅x","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"UnevalutedExpr is supported by SymPy printers and can be used to print the result in different output forms. For example","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> from sympy import latex\n    >>> uexpr = UnevaluatedExpr(S.One*5/7)*UnevaluatedExpr(S.One*3/4)\n    >>> print(latex(uexpr))\n    \\frac{5}{7} \\frac{3}{4}","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-35","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"The printing support is through show, but we can use SymPy's:","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> uexpr = UnevaluatedExpr(S.One*5/7)*UnevaluatedExpr(S.One*3/4)\n5/7⋅3/4\n\njulia> sympy.latex(uexpr)\n\"\\\\frac{5}{7} \\\\frac{3}{4}\"\n\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"In order to release the expression and get the evaluated LaTeX form, just use .doit():","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"    >>> print(latex(uexpr.doit()))\n    \\frac{15}{28}","category":"page"},{"location":"Tutorial/manipulation/#In-Julia:-36","page":"Advanced expression  manipulation","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"julia> sympy.latex(uexpr.doit())\n\"\\\\frac{15}{28}\"\n","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Advanced expression  manipulation","title":"Advanced expression  manipulation","text":"note: Footnotes\n[#symbols-fn] We have been using symbols instead of Symbol because it automatically splits apart strings into multiple Symbol\\ s.    symbols('x y z') returns a tuple of three Symbol\\ s.  Symbol('x y  z') returns a single Symbol called x y z.\n[#sympify-fn] Technically, it is an internal function called _sympify, which differs from sympify in that it does not convert strings.  x + '2' is not allowed.\n[#singleton-fn] Classes like One and Zero are singletonized, meaning that only one object is ever created, no matter how many times the class is called.  This is done for space efficiency, as these classes are very  common.  For example, Zero might occur very often in a sparse matrix represented densely.  As we have seen, NegativeOne occurs any time we  have -x or 1/x.  It is also done for speed efficiency because singletonized objects can be compared by is.  The unique objects for each singletonized class can be accessed from the S object.","category":"page"},{"location":"Tutorial/gotchas/#Gotchas","page":"Gotchas","title":"Gotchas","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"using SymPy\nsympy.init_printing(pretty_print=False, use_unicode=False)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"From","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To begin, we should make something about SymPy clear.  SymPy is nothing more than a Python library, like NumPy, Django, or even modules in the Python standard library sys or re.  What this means is that SymPy does not add anything to the Python language.  Limitations that are inherent in the Python language are also inherent in SymPy.  It also means that SymPy tries to use Python idioms whenever possible, making programming with SymPy easy for those already familiar with programming with Python.  As a simple example, SymPy uses Python syntax to build expressions.  Implicit multiplication (like 3x or 3 x) is not allowed in Python, and thus not allowed in SymPy. To multiply 3 and x, you must type 3*x with the *.","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"implicit multiplication by a literal is supported, unlike Python","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/#Symbols","page":"Gotchas","title":"Symbols","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"One consequence of this fact is that SymPy can be used in any environment where Python is available.  We just import it, like we would any other library:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> from sympy import *","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-2","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"the functions from the sympy module are loaded with the package:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> using SymPy","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This imports all the functions and classes from SymPy into our interactive Python session.  Now, suppose we start to do a computation.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + 1\n    Traceback (most recent call last):\n    ...\n    NameError: name 'x' is not defined","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-3","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"the error output may differ, but an UndefVarError is thrown","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x + 1\nERROR: UndefVarError: x not defined\nStacktrace:\n [1] top-level scope at REPL[86]:1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Oops! What happened here?  We tried to use the variable x, but it tells us that x is not defined.  In Python, variables have no meaning until they are defined.  SymPy is no different.  Unlike many symbolic manipulation systems you may have used, in SymPy, variables are not defined automatically. To define variables, we must use symbols.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = symbols('x')\n    >>> x + 1\n    x + 1","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-4","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"We can use symbols, as here:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x = symbols(\"x\")\nx\n\njulia> x + 1\nx + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"but the recommended way is to use @syms:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> @syms x\n(x,)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"symbols takes a string of variable names separated by spaces or commas, and creates Symbols out of them.  We can then assign these to variable names. Later, we will investigate some convenient ways we can work around this issue. For now, let us just define the most common variable names, x, y, and z, for use through the rest of this section","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x, y, z = symbols('x y z')","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-5","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Again, we use the @syms macro:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x + 1\nx + 1\n\njulia> @syms x, y, z\n(x, y, z)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"As a final note, we note that the name of a Symbol and the name of the variable it is assigned to need not have anything to do with one another.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> a, b = symbols('b a')\n    >>> a\n    b\n    >>> b\n    a","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-6","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"The  same  holds:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia>  a, b = symbols(\"b a\")\n(b, a)\n\njulia> a\nb","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> b\na","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This can also be done with the @syms macro:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> @syms a=>\"b\" b=>\"c\"\n(b, c)\n\njulia> a + b\nb + c","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Here we have done the very confusing thing of assigning a Symbol with the name a to the variable b, and a Symbol of the name b to the variable a.  Now the Python variable named a points to the SymPy Symbol named b, and visa versa.  How confusing.  We could have also done something like","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> crazy = symbols('unrelated')\n    >>> crazy + 1\n    unrelated + 1","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-7","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> crazy = symbols(\"unrelated\")\nunrelated\n\njulia> crazy + 1\nunrelated + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This also shows that Symbols can have names longer than one character if we want.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Usually, the best practice is to assign Symbols to Python variables of the same name, although there are exceptions:  Symbol names can contain characters that are not allowed in Python variable names, or may just want to avoid typing long names by assigning Symbols with long names to single letter Python variables.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To avoid confusion, throughout this tutorial, Symbol names and Python variable names will always coincide.  Furthermore, the word \"Symbol\" will refer to a SymPy Symbol and the word \"variable\" will refer to a Python variable.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Finally, let us be sure we understand the difference between SymPy Symbols and Python variables.  Consider the following::","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"  x = symbols('x')\n  expr = x + 1\n  x = 2\n  print(expr)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"What do you think the output of this code will be?  If you thought 3, you're wrong.  Let's see what really happens","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = symbols('x')\n    >>> expr = x + 1\n    >>> x = 2\n    >>> print(expr)\n    x + 1","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-8","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"we must change to double quotes (or, as recommended, use @syms x)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x = symbols(\"x\")\nx\n\njulia> expr = x + 1\nx + 1\n\njulia> x = 2\n2\n\njulia> expr\nx + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Changing x to 2 had no effect on expr.  This is because x = 2 changes the Python variable x to 2, but has no effect on the SymPy Symbol x, which was what we used in creating expr.  When we created expr, the Python variable x was a Symbol.  After we created, it, we changed the Python variable x to 2.  But expr remains the same.  This behavior is not unique to SymPy.  All Python programs work this way: if a variable is changed, expressions that were already created with that variable do not change automatically.  For example","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = 'abc'\n    >>> expr = x + 'def'\n    >>> expr\n    'abcdef'\n    >>> x = 'ABC'\n    >>> expr\n    'abcdef'","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-9","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"The * infix operator is used for string concatenation","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x = \"abc\"\n\"abc\"\n\njulia> expr = x * \"def\"\n\"abcdef\"\n\njulia> expr\n\"abcdef\"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x = \"ABC\"\n\"ABC\"\n\njulia> expr\n\"abcdef\"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"note: Quick Tip\nTo change the value of a Symbol in an expression, use subs","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"     >>> x = symbols('x')\n     >>> expr = x + 1\n     >>> expr.subs(x, 2)\n     3","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-10","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> @syms x\n(x,)\n\njulia> expr = x + 1\nx + 1\n\njulia> expr.subs(x, 2)\n3","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Or use the \"call\" form of subs: expr(x => 2)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"In this example, if we want to know what expr is with the new value of x, we need to reevaluate the code that created expr, namely, expr = x + 1.  This can be complicated if several lines created expr.  One advantage of using a symbolic computation system like SymPy is that we can build a symbolic representation for expr, and then substitute x with values.  The correct way to do this in SymPy is to use subs, which will be discussed in more detail later.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = symbols('x')\n    >>> expr = x + 1\n    >>> expr.subs(x, 2)\n    3","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-11","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> @syms x\n(x,)\n\njulia> expr = x + 1\nx + 1\n\njulia> expr.subs(x, 2)\n3","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"note: TODO\nAdd link to basic operations section","category":"page"},{"location":"Tutorial/gotchas/#Equals-signs","page":"Gotchas","title":"Equals signs","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Another very important consequence of the fact that SymPy does not extend Python syntax is that = does not represent equality in SymPy.  Rather it is Python variable assignment.  This is hard-coded into the Python language, and SymPy makes no attempts to change that.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"You may think, however, that ==, which is used for equality testing in Python, is used for SymPy as equality.  This is not quite correct either.  Let us see what happens when we use ==.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + 1 == 4\n    False","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-12","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"== is similar as in Python:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x + 1 == 4\nfalse","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Recall == promotes values, so we have a Julia object may be \"equal\" to a SymPy one:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> 0 == zero(Sym)  ## or Sym(0)\ntrue","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Instead of treating x + 1 == 4 symbolically, we just got False.  In SymPy, == represents exact structural equality testing.  This means that a == b means that we are asking if a = b.  We always get a bool as the result of ==.  There is a separate object, called Eq, which can be used to create symbolic equalities","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> Eq(x + 1, 4)\n    Eq(x + 1, 4)","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-13","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> Eq(x + 1, 4)\nx + 1 = 4","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"There is one additional caveat about == as well.  Suppose we want to know if (x + 1)^2 = x^2 + 2x + 1.  We might try something like this:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> (x + 1)**2 == x**2 + 2*x + 1\n    False","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-14","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> (x + 1)^2 == x^2 + 2*x + 1\nfalse","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"We got False again. However, (x + 1)^2 does equal x^2 + 2x + 1. What is going on here?  Did we find a bug in SymPy, or is it just not powerful enough to recognize this basic algebraic fact?","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Recall from above that == represents exact structural equality testing. \"Exact\" here means that two expressions will compare equal with == only if they are exactly equal structurally.  Here, (x + 1)^2 and x^2 + 2x + 1 are not the same symbolically. One is the power of an addition of two terms, and the other is the addition of three terms.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"It turns out that when using SymPy as a library, having == test for exact structural equality is far more useful than having it represent symbolic equality, or having it test for mathematical equality.  However, as a new user, you will probably care more about the latter two.  We have already seen an alternative to representing equalities symbolically, Eq.  To test if two things are equal, it is best to recall the basic fact that if a = b, then a - b = 0.  Thus, the best way to check if a = b is to take a - b and simplify it, and see if it goes to 0.  We will learn :ref:later <tutorial-simplify> that the function to do this is called simplify. This method is not infallible–-in fact, it can be theoretically proven <http://en.wikipedia.org/wiki/Richardson%27s_theorem>_ that it is impossible to determine if two symbolic expressions are identically equal in general–-but for most common expressions, it works quite well.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> a = (x + 1)**2\n    >>> b = x**2 + 2*x + 1\n    >>> simplify(a - b)\n    0\n    >>> c = x**2 - 2*x + 1\n    >>> simplify(a - c)\n    4*x","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-15","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> @syms x\n(x,)\n\njulia> a = (x + 1)^2; string(a)\n\"(x + 1)^2\"\n\njulia> b = x^2 + 2*x + 1; string(b)\n\"x^2 + 2*x + 1\"\n\njulia> simplify(a - b)\n0\n\njulia> c = x^2 - 2*x + 1; string(c)\n\"x^2 - 2*x + 1\"\n\njulia> simplify(a - c)\n4⋅x","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"There is also a method called equals that tests if two expressions are equal by evaluating them numerically at random points.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> a = cos(x)**2 - sin(x)**2\n    >>> b = cos(2*x)\n    >>> a.equals(b)\n    True","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-16","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> a = cos(x)^2 - sin(x)^2\n     2         2\n- sin (x) + cos (x)\n\njulia> b = cos(2*x)\ncos(2⋅x)\n\njulia> a.equals(b)\ntrue","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/#Two-Final-Notes:-and-/","page":"Gotchas","title":"Two Final Notes: ^ and /","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"You may have noticed that we have been using ** for exponentiation instead of the standard ^.  That's because SymPy follows Python's conventions.  In Python, ^ represents logical exclusive or.  SymPy follows this convention:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"     >>> True ^ False\n     True\n     >>> True ^ True\n     False\n     >>> x^y\n     Xor(x, y)","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-17","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"we export True and False for symbolic Boolean values\nThis does not apply, as we use ^ for exponentiation.\nUse the prefix Or for logical","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> Or(True, False)\nTrue","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> Or(True, True)\nTrue","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> Or(x, y)\nx ∨ y","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Finally, a small technical discussion on how SymPy works is in order.  When you type something like x + 1, the SymPy Symbol x is added to the Python int 1.  Python's operator rules then allow SymPy to tell Python that SymPy objects know how to be added to Python ints, and so 1 is automatically converted to the SymPy Integer object.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This sort of operator magic happens automatically behind the scenes, and you rarely need to even know that it is happening.  However, there is one exception.  Whenever you combine a SymPy object and a SymPy object, or a SymPy object and a Python object, you get a SymPy object, but whenever you combine two Python objects, SymPy never comes into play, and so you get a Python object.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> type(Integer(1) + 1)\n    <class 'sympy.core.numbers.Integer'>\n    >>> type(1 + 1)\n    <... 'int'>","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-18","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"In Julia, most operations between SymPy objects and Julia objects will promote to a SymPy objects, but of course Julia objects combined will produce Julia Objects:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> typeof(sympy.Integer(1) + 1)\nSym","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> typeof(1 + 1)\nInt64","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To convert a Julia object to a SymPy object, the Sym constructor may be useful:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> Sym(1)\n1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To convert a SymPy object to a Julia object, the N function is useful for numbers and booleans:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> N(Sym(1)), N(True)\n(1, true)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"And the lambdify function can produce a function from an expression:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> ex = x^2 - 2x + 2\n 2\nx  - 2⋅x + 2\n\njulia> fn = lambdify(ex);\n\njulia> fn(1) - ex(1)\n0","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"note: Note\nOn running the example above in SymPy Live, (1+1) is wrapped by Integer, so it does not show the correct output.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This is usually not a big deal. Python ints work much the same as SymPy Integers, but there is one important exception:  division.  In SymPy, the division of two Integers gives a Rational:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> Integer(1)/Integer(3)\n    1/3\n    >>> type(Integer(1)/Integer(3))\n    <class 'sympy.core.numbers.Rational'>","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-19","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> sympy.Integer(1)/sympy.Integer(3)\n1/3","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> typeof(sympy.Integer(1)/sympy.Integer(3))\nSym","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"And to get the Python, type, we can use __class__:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> (sympy.Integer(1)/sympy.Integer(3)).__class__\nPyObject <class 'sympy.core.numbers.Rational'>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"But in Python / represents either integer division or floating point division, depending on whether you are in Python 2 or Python 3, and depending on whether or not you have run from __future__ import division:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> from __future__ import division\n    >>> 1/2 #doctest: +SKIP\n    0.5","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-20","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This does not apply, as / is not integer division.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To avoid this, we can construct the rational object explicitly","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> Rational(1, 2)\n    1/2","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-21","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Rational from sympy is not exported, it would conflict with Julia's Rational costructor. We must qualify it:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> Rational(1, 2)\n1//2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> sympy.Rational(1, 2)\n1/2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This problem also comes up whenever we have a larger symbolic expression with int/int in it.  For example:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + 1/2 #doctest: +SKIP\n    x + 0.5","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-22","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Int/Int will produce a floating point value, whereas Int//Int will produce a rational, which can then be promoted without loss to a symbolic object:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x + 1/2\nx + 0.5","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"note: Note\n","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"On running the example above in SymPy Live, (1/2) is wrapped    by Integer, so it does not show the correct output.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This happens because Python first evaluates 1/2 into 0.5, and then that is cast into a SymPy type when it is added to x.  Again, we can get around this by explicitly creating a Rational:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + Rational(1, 2)\n    x + 1/2","category":"page"},{"location":"Tutorial/gotchas/#In-Julia:-23","page":"Gotchas","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"julia> x + 1//2\nx + 1/2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"There are several tips on avoiding this situation in the :ref:gotchas document.","category":"page"},{"location":"Tutorial/gotchas/#Further-Reading","page":"Gotchas","title":"Further Reading","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"For more discussion on the topics covered in this section, see :ref:gotchas.","category":"page"},{"location":"Tutorial/#The-SymPy-tutorial-(1.3)-in-Julia","page":"About","title":"The SymPy tutorial (1.3) in Julia","text":"","category":"section"},{"location":"Tutorial/","page":"About","title":"About","text":"Here the  tutorial for  SymPy 1.3 is re-expressed using Julia commands and SymPy.jl. It attempts to show the similarities and differences in using SymPy under Python and Julia.","category":"page"},{"location":"Tutorial/","page":"About","title":"About","text":"","category":"page"},{"location":"Tutorial/","page":"About","title":"About","text":"The SymPy package for Julia allows Julia users to interact with python's SymPy module in a mostly seamless manner, thanks to the power of the PyCall package for Julia. The following pages reexpress the SymPy tutorial also illustrating the associated Julia commands. There are some changes, but mostly modest ones. To create these pages, the .rst files were downloaded and modfied. There is only hand sychronization available with new versions of the SymPy tutorial for Python.","category":"page"},{"location":"Tutorial/","page":"About","title":"About","text":"","category":"page"},{"location":"Tutorial/","page":"About","title":"About","text":"Pages  = [\"intro.md\",\"gotchas.md\", \"basic_operations.md\", \"simplification.md\",  \"calculus.md\", \"solvers.md\",\n\"matrices.md\", \"manipulation.md\"]","category":"page"},{"location":"Tutorial/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"From","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> from sympy import *\n    >>> x, y, z = symbols(\"x y z\")\n    >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"using SymPy\nsympy.init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/solvers/#In-Julia:","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> using SymPy\n\njulia> @syms x, y, z\n(x, y, z)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/#A-Note-about-Equations","page":"Solvers","title":"A Note about Equations","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Recall from the :ref:gotchas <tutorial_gotchas_equals> section of this tutorial that symbolic equations in SymPy are not represented by = or ==, but by Eq.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> Eq(x, y)\n    x = y","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-2","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> Eq(x, y)\nx = y\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"However, there is an even easier way.  In SymPy, any expression not in an Eq is automatically assumed to equal 0 by the solving functions.  Since a = b if and only if a - b = 0, this means that instead of using x == y, you can just use x - y.  For example","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(Eq(x**2, 1), x)\n    {-1, 1}\n    >>> solveset(Eq(x**2 - 1, 0), x)\n    {-1, 1}\n    >>> solveset(x**2 - 1, x)\n    {-1, 1}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-3","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> solveset(Eq(x^2, 1), x)\n{-1, 1}\n\njulia> solveset(Eq(x^2 - 1, 0), x)\n{-1, 1}\n\njulia> solveset(x^2 - 1, x)\n{-1, 1}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"This is particularly useful if the equation you wish to solve is already equal to 0. Instead of typing solveset(Eq(expr, 0), x), you can just use solveset(expr, x).","category":"page"},{"location":"Tutorial/solvers/#Solving-Equations-Algebraically","page":"Solvers","title":"Solving Equations Algebraically","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The main function for solving algebraic equations is solveset. The syntax for solveset is solveset(equation, variable=None, domain=S.Complexes) Where equations may be in the form of Eq instances or expressions that are assumed to be equal to zero.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Please note that there is another function called solve which can also be used to solve equations. The syntax is solve(equations, variables) However, it is recommended to use solveset instead.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When solving a single equation, the output of solveset is a FiniteSet or an Interval or ImageSet of the solutions.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(x**2 - x, x)\n    {0, 1}\n    >>> solveset(x - x, x, domain=S.Reals)\n    ℝ\n    >>> solveset(sin(x) - 1, x, domain=S.Reals)\n    ⎧        π        ⎫\n    ⎨2⋅n⋅π + ─ | n ∊ ℤ⎬\n    ⎩        2        ⎭","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-4","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"S is not exported, as it is not a function, so we create an alias:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> const S = sympy.S\nPyObject S\n\njulia> solveset(x^2 - x, x)\n{0, 1}\n\njulia> solveset(x - x, x, domain=S.Reals)\nℝ\n\njulia> solveset(sin(x) - 1, x, domain=S.Reals)\n⎧        π │      ⎫\n⎨2⋅n⋅π + ─ │ n ∊ ℤ⎬\n⎩        2 │      ⎭","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"If there are no solutions, an EmptySet is returned and if it is not able to find solutions then a ConditionSet is returned.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(exp(x), x)     # No solution exists\n    ∅\n    >>> solveset(cos(x) - x, x)  # Not able to find solution\n    {x | x ∊ ℂ ∧ -x + cos(x) = 0}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-5","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> solveset(exp(x), x)     # No solution exists\n∅\n\njulia> solveset(cos(x) - x, x)  # Not able to find solution\n{x │ x ∊ ℂ ∧ (-x + cos(x) = 0)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"In the solveset module, the linear system of equations is solved using linsolve. In future we would be able to use linsolve directly from solveset. Following is an example of the syntax of linsolve.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"List of Equations Form:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> linsolve([x + y + z - 1, x + y + 2*z - 3 ], (x, y, z))","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-6","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Rather than a vector,  we  pass  a tuple:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> linsolve((x + y + z - 1, x + y + 2*z - 3), (x, y, z))\n{(-y - 1, y, 2)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"A  tuple","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"note: Tuples\nThe linsolve function  expects a list of equations, whereas  PyCall  is instructed to promote the syntax  to   produce  a  list  in  Python into a Array{Sym} object. As  such, we pass  the equations in a tuple above. Similar considerations  are necessary at times for the  sympy.Matrix  constructor. It is suggested, as in the next example, to work around this by passing Julian arrays to the constructor or bypassing it  altogether.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Augmented","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Matrix Form:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":">>> M = Matrix(((1, 1, 1, 1), (1, 1, 2, 3)))\n>>> system = A, b = M[:, :-1], M[:, -1]\n>>> linsolve(system, x, y, z)\n{(-y - 1, y, 2)}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-7","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"We use Julian syntax for matrices:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> A =  [1 1 1; 1  1  2];  b =  [1,3]\n2-element Vector{Int64}:\n 1\n 3","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The augmented form is not available","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> aug = [A b]\n2×4 Array{Int64,2}:\n 1  1  1  1\n 1  1  2  3\n\njulia> linsolve(sympy.Matrix(aug), (x,y,z)) # not {(-y - 1, y, 2)}!\n∅\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"In lieu of using sympy.Matrix, the matrix can be created  symbolically,   as:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> A =  Sym[1 1 1; 1  1  2];  b =  [1,3]\n2-element Vector{Int64}:\n 1\n 3\n\njulia> aug = [A b]\n2×4 Matrix{Sym}:\n 1  1  1  1\n 1  1  2  3\n\njulia> linsolve(aug, (x,y,z)) # {(-y - 1, y, 2)};\n{(-y - 1, y, 2)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Finally,  linear equations  are  solved in Julia  with  the \\ (backslash) operator:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"A \\ b","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The variables are generated  within \\ in  the  sequence  x1, x2,  ...","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"A*x = b Form","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"\t>>> M = Matrix(((1, 1, 1, 1), (1, 1, 2, 3)))\n\t>>> system = A, b = M[:, :-1], M[:, -1]\n\t>>> linsolve(system, x, y, z)\n\t{(-y - 1, y, 2)}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-8","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"We  follow the syntax  above to   construct the matrix (tuple of tuples), but  not  the Julian  matrix  construtor  would be  recommended:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> M = sympy.Matrix(((1, 1, 1, 1), (1, 1, 2, 3)))\n2×4 Matrix{Sym}:\n 1  1  1  1\n 1  1  2  3\n\njulia> system = A, b = M[:, 1:end-1], M[:, end]\n(Sym[1 1 1; 1 1 2], Sym[1, 3])\n\njulia> linsolve(system, x, y, z)\n{(-y - 1, y, 2)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"note: Note\nThe order of solution corresponds the order of given symbols.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"In the solveset module, the non linear system of equations is solved using nonlinsolve. Following are examples of nonlinsolve.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When only real solution is present:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"\t>>> a, b, c, d = symbols('a, b, c, d', real=True)\n\t>>> nonlinsolve([a**2 + a, a - b], [a, b])\n\t{(-1, -1), (0, 0)}\n\t>>> nonlinsolve([x*y - 1, x - 2], x, y)\n\t{(2, 1/2)}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-9","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"we pass [a,b] as either a, b or using a tuple, as in (a,b), but not as a vector, as this gets mapped into a vector of symbolic objects which causes issues with nonlinsolve:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> @syms a::real, b::real, c::real, d::real\n(a, b, c, d)\n\njulia> nonlinsolve([a^2 + a, a - b], a, b)\n{(-1, -1), (0, 0)}\n\njulia> nonlinsolve([x*y - 1, x - 2], x, y)\n{(2, 1/2)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When only complex solution is present:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"\t>>> nonlinsolve([x**2 + 1, y**2 + 1], [x, y])\n\t{(-ⅈ, -ⅈ), (-ⅈ, ⅈ), (ⅈ, -ⅈ), (ⅈ, ⅈ)}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-10","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> nonlinsolve([x^2 + 1, y^2 + 1], (x, y))\n{(-ⅈ, -ⅈ), (-ⅈ, ⅈ), (ⅈ, -ⅈ), (ⅈ, ⅈ)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When both real and complex solution is present:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"\t>>> from sympy import sqrt\n\t>>> system = [x**2 - 2*y**2 -2, x*y - 2]\n\t>>> vars = [x, y]\n\t>>> nonlinsolve(system, vars)\n\t{(-2, -1), (2, 1), (-√2⋅ⅈ, √2⋅ⅈ), (√2⋅ⅈ, -√2⋅ⅈ)}\n\n\t>>> n = Dummy('n')\n\t>>> system = [exp(x) - sin(y), 1/y - 3]\n\t>>> real_soln = (log(sin(S(1)/3)), S(1)/3)\n\t>>> img_lamda = Lambda(n, 2*n*I*pi + Mod(log(sin(S(1)/3)), 2*I*pi))\n\t>>> complex_soln = (ImageSet(img_lamda, S.Integers), S(1)/3)\n\t>>> soln = FiniteSet(real_soln, complex_soln)\n\t>>> nonlinsolve(system, [x, y]) == soln\n\tTrue","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-11","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"we must remove the spaces within []\nwe must pass vars as a tuple:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> system = [x^2-2*y^2-2, x*y-2]\n2-element Vector{Sym}:\n x^2 - 2*y^2 - 2\n         x⋅y - 2\n\njulia> vars = (x, y)\n(x, y)\n\njulia> nonlinsolve(system, vars)\n{(-2, -1), (2, 1), (-√2⋅ⅈ, √2⋅ⅈ), (√2⋅ⅈ, -√2⋅ⅈ)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"However, the next bit requires some modifications to run:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"the system array definition must have extra spaces removed\nDummy,  Mod, ImageSet, FiniteSet aren't exported\nwe need PI, not pi to have a symbolic value\nwe compare manually","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> n = sympy.Dummy(\"n\")\nn\n\njulia> system = [exp(x)-sin(y), 1/y-3]\n2-element Vector{Sym}:\n exp(x) - sin(y)\n        -3 + 1/y\n\njulia> real_soln = (log(sin(S(1)/3)), S(1)/3)\n(log(sin(1/3)), 1/3)\n\njulia> img_lamda = Lambda(n, 2*n*IM*PI + sympy.Mod(sin(S(1)/3), 2*IM*PI))\nn ↦ 2⋅n⋅ⅈ⋅π + (sin(1/3) mod 2⋅ⅈ⋅π)\n\njulia> complex_soln = (sympy.ImageSet(img_lamda, S.Integers), S(1)/3)\n(ImageSet(Lambda(_n, 2*_n*I*pi + Mod(sin(1/3), 2*I*pi)), Integers), 1/3)\n\njulia> soln = sympy.FiniteSet(real_soln, complex_soln)\n{(log(sin(1/3)), 1/3), ({2⋅n⋅ⅈ⋅π + (sin(1/3) mod 2⋅ⅈ⋅π) │ n ∊ ℤ}, 1/3)}\n\njulia> nonlinsolve(system, (x, y))\n{({2⋅n⋅ⅈ⋅π + log(sin(1/3)) │ n ∊ ℤ}, 1/3)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"If non linear system of equations is Positive dimensional system (A system with","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"infinitely many solutions is said to be positive-dimensional):","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"\t>>> nonlinsolve([x*y, x*y - x], [x, y])\n\t{(0, y)}\n\n\t>>> system = [a**2 + a*c, a - b]\n\t>>> nonlinsolve(system, [a, b])\n\t{(0, 0), (-c, -c)}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-12","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"again, we use a tuple for the variables:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> nonlinsolve([x*y, x*y-x], (x, y))\n{(0, y)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> system = [a^2+a*c, a-b]\n2-element Vector{Sym}:\n a^2 + a*c\n     a - b\n\njulia> nonlinsolve(system, (a, b))\n{(0, 0), (-c, -c)}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Note:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The order of solution corresponds the order of given symbols.\nCurrently nonlinsolve doesn't return solution in form of LambertW (if there is solution present in the form of LambertW).","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solve can be used for such cases:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"   >>> solve([x**2 - y**2/exp(x)], [x, y], dict=True)\n   ⎡⎧             ⎛y⎞⎫⎤\n   ⎢⎨x: 2⋅LambertW⎜─⎟⎬⎥\n   ⎣⎩             ⎝2⎠⎭⎦","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-13","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"it is similar","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> u = solve([x^2 - y^2/exp(x)], [x, y], dict=true)\n2-element Vector{Dict{Any, Any}}:\n Dict(y => -x*sqrt(exp(x)))\n Dict(y => x*sqrt(exp(x)))\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To get prettier output, the dict may be converted to have one with symbolic keys:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> convert(Dict{SymPy.Sym, Any}, first(u))\nDict{Sym, Any} with 1 entry:\n  y => -x*sqrt(exp(x))\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Currently nonlinsolve is not properly capable of solving the system of equations","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"having trigonometric functions.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solve can be used for such cases(not all solution):","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"   >>> solve([sin(x + y), cos(x - y)], [x, y])\n   ⎡⎛-3⋅π   3⋅π⎞  ⎛-π   π⎞  ⎛π  3⋅π⎞  ⎛3⋅π  π⎞⎤\n   ⎢⎜─────, ───⎟, ⎜───, ─⎟, ⎜─, ───⎟, ⎜───, ─⎟⎥\n   ⎣⎝  4     4 ⎠  ⎝ 4   4⎠  ⎝4   4 ⎠  ⎝ 4   4⎠⎦","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-14","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> solve([sin(x + y), cos(x - y)], [x, y])\n4-element Vector{Tuple{Sym, Sym}}:\n (-3*pi/4, 3*pi/4)\n (-pi/4, pi/4)\n (pi/4, 3*pi/4)\n (3*pi/4, pi/4)\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solveset reports each solution only once.  To get the solutions of a polynomial including multiplicity use roots.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(x**3 - 6*x**2 + 9*x, x)\n    {0, 3}\n    >>> roots(x**3 - 6*x**2 + 9*x, x)\n    {0: 1, 3: 2}","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-15","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> solveset(x^3 - 6*x^2 + 9*x, x)\n{0, 3}\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> roots(x^3 - 6*x^2 + 9*x, x)  |>  d -> convert(Dict{Sym, Any}, d) # prettier priting\nDict{Sym, Any} with 2 entries:\n  0 => 1\n  3 => 2","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The output {0: 1, 3: 2} of roots means that 0 is a root of multiplicity 1 and 3 is a root of multiplicity 2.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Note:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Currently solveset is not capable of solving the following types of equations:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Equations solvable by LambertW (Transcendental equation solver).","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solve can be used for such cases:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"   >>> solve(x*exp(x) - 1, x )\n   [LambertW(1)]","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-16","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> solve(x*exp(x) - 1, x )\n1-element Vector{Sym}:\n W(1)\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/#Solving-Differential-Equations","page":"Solvers","title":"Solving Differential Equations","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To solve differential equations, use dsolve.  First, create an undefined function by passing cls=Function to the symbols function.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> f, g = symbols('f g', cls=Function)","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-17","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> @syms f() g()\n(f, g)\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"f and g are now undefined functions.  We can call f(x), and it will represent an unknown function.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> f(x)\n    f(x)","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-18","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> f(x)\nf(x)\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Derivatives of f(x) are unevaluated.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> f(x).diff(x)\n    d\n    ──(f(x))\n    dx","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-19","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> f(x).diff(x)\nd\n──(f(x))\ndx\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"(see the :ref:Derivatives <tutorial-derivatives> section for more on derivatives).","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To represent the differential equation f(x) - 2f(x) + f(x) = sin(x), we would thus use","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> diffeq = Eq(f(x).diff(x, x) - 2*f(x).diff(x) + f(x), sin(x))\n    >>> diffeq\n                          2\n             d           d\n    f(x) - 2⋅──(f(x)) + ───(f(x)) = sin(x)\n             dx           2\n                        dx","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-20","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> diffeq = Eq(f(x).diff(x, x) - 2*f(x).diff(x) + f(x), sin(x)); string(diffeq)\n\"Eq(f(x) - 2*Derivative(f(x), x) + Derivative(f(x), (x, 2)), sin(x))\"\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To solve the ODE, pass it and the function to solve for to dsolve.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> dsolve(diffeq, f(x))\n                        x   cos(x)\n    f(x) = (C₁ + C₂⋅x)⋅ℯ  + ──────\n                              2","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-21","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"we use dsolve for initial value proplems","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> dsolve(diffeq, f(x)) |> string\n\"Eq(f(x), (C1 + C2*x)*exp(x) + cos(x)/2)\"\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"dsolve returns an instance of Eq.  This is because in general, solutions to differential equations cannot be solved explicitly for the function.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> dsolve(f(x).diff(x)*(1 - sin(f(x))), f(x))\n    f(x) + cos(f(x)) = C₁","category":"page"},{"location":"Tutorial/solvers/#In-Julia:-22","page":"Solvers","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> dsolve(f(x).diff(x)*(1 - sin(f(x))), f(x))\nf(x) = C₁\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The arbitrary constants in the solutions from dsolve are symbols of the form C1, C2, C3, and so on.","category":"page"},{"location":"Tutorial/solvers/#Julia-alternative-interface","page":"Solvers","title":"Julia alternative interface","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"SymPy.jl adds a SymFunction class, that makes it a bit easier to set up a differential equation, though not as general.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"We use either the SymFunction constructor","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> f = SymFunction(\"f\")\nf\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"or the @syms macro, as in @syms f() to define symbolic functions. The Differential function (who's functionality is lifted from ModelingToolkit). Can simplify things:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> D = Differential(x);\n\njulia> diffeq = Eq(D(D(f))(x) - 2*D(f)(x) + f(x), sin(x)); string(diffeq)\n\"Eq(f(x) - 2*Derivative(f(x), x) + Derivative(f(x), (x, 2)), sin(x))\"\n\njulia> dsolve(diffeq, f(x))  |> string\n\"Eq(f(x), (C1 + C2*x)*exp(x) + cos(x)/2)\"\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Or:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> dsolve(D(f)(x)*(1 - sin(f(x))), f(x))\nf(x) = C₁\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Initial conditions can be specified using a dictionary.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"For the initial condition f'(x0) = y0, this would be specified as Dict(D(f)(x0) => y0).","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"For example, to solve the exponential equation f(x) = f(x) f(0) = a we would have:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> @syms x, a, f()\n(x, a, f)\n\njulia> dsolve(D(f)(x) - f(x), f(x), ics = Dict(f(0) => a)) |>  string\n\"Eq(f(x), a*exp(x))\"\n","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To solve the simple harmonic equation, where two initial conditions are specified, we combine the tuple for each within another tuple:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"julia> ics = Dict(f(0) => 1, D(f)(0) => 2);\n\njulia> dsolve(D(D(f))(x) - f(x), f(x), ics=ics) |> string\n\"Eq(f(x), 3*exp(x)/2 - exp(-x)/2)\"\n","category":"page"},{"location":"Tutorial/simplification/#Simplification","page":"Simplification","title":"Simplification","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"From","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To make this document easier to read, we are going to enable pretty printing.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> from sympy import *\n    >>> x, y, z = symbols('x y z')\n    >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"using SymPy\nsympy.init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"\" not ' are used for strings:\npretty printing si enable by default\nwe will deliberatately  input extra functions from the sympy module such as powsimp, ...","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> using SymPy\n\njulia> import_from(sympy)\n\njulia> @syms x, y, z\n(x, y, z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#simplify","page":"Simplification","title":"simplify","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Now let's jump in and do some interesting mathematics.  One of the most useful features of a symbolic manipulation system is the ability to simplify mathematical expressions.  SymPy has dozens of functions to perform various kinds of simplification.  There is also one general function called simplify() that attempts to apply all of these functions in an intelligent way to arrive at the simplest form of an expression.  Here are some examples","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> simplify(sin(x)**2 + cos(x)**2)\n    1\n    >>> simplify((x**3 + x**2 - x - 1)/(x**2 + 2*x + 1))\n    x - 1\n    >>> simplify(gamma(x)/gamma(x - 2))\n    (x - 2)⋅(x - 1)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-2","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"we need to load in SpecialFunctions to have access to gamma:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> simplify(sin(x)^2 + cos(x)^2)\n1\n\njulia> simplify((x^3 + x^2 - x - 1)/(x^2 + 2*x + 1))\nx - 1\n\njulia> using SpecialFunctions\n\n\njulia> simplify(gamma(x)/gamma(x - 2))\n(x - 2)⋅(x - 1)\n","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Here, gamma(x) is Gamma(x), the gamma function <http://en.wikipedia.org/wiki/Gamma_function>_.  We see that simplify() is capable of handling a large class of expressions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"But simplify() has a pitfall.  It just applies all the major simplification operations in SymPy, and uses heuristics to determine the simplest result. But \"simplest\" is not a well-defined term.  For example, say we wanted to \"simplify\" x^2 + 2x + 1 into (x + 1)^2:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> simplify(x**2 + 2*x + 1)\n     2\n    x  + 2⋅x + 1","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-3","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> simplify(x^2 + 2*x + 1) |> string\n\"x^2 + 2*x + 1\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"We did not get what we want.  There is a function to perform this simplification, called factor(), which will be discussed below.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Another pitfall to simplify() is that it can be unnecessarily slow, since it tries many kinds of simplifications before picking the best one.  If you already know exactly what kind of simplification you are after, it is better to apply the specific simplification function(s) that apply those simplifications.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Applying specific simplification functions instead of simplify() also has the advantage that specific functions have certain guarantees about the form of their output.  These will be discussed with each function below.  For example, factor(), when called on a polynomial with rational coefficients, is guaranteed to factor the polynomial into irreducible factors. simplify() has no guarantees.  It is entirely heuristical, and, as we saw above, it may even miss a possible type of simplification that SymPy is capable of doing.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"simplify() is best when used interactively, when you just want to whittle down an expression to a simpler form.  You may then choose to apply specific functions once you see what simplify() returns, to get a more precise result.  It is also useful when you have no idea what form an expression will take, and you need a catchall function to simplify it.","category":"page"},{"location":"Tutorial/simplification/#Polynomial/Rational-Function-Simplification","page":"Simplification","title":"Polynomial/Rational Function Simplification","text":"","category":"section"},{"location":"Tutorial/simplification/#expand","page":"Simplification","title":"expand","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand() is one of the most common simplification functions in SymPy. Although it has a lot of scopes, for now, we will consider its function in expanding polynomial expressions. For example:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand((x + 1)**2)\n     2\n    x  + 2⋅x + 1\n    >>> expand((x + 2)*(x - 3))\n     2\n    x  - x - 6","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-4","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand((x + 1)^2) |> string\n\"x^2 + 2*x + 1\"\n\njulia> expand((x + 2)*(x - 3)) |> string\n\"x^2 - x - 6\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Given a polynomial, expand() will put it into a canonical form of a sum of monomials.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand() may not sound like a simplification function.  After all, by its very name, it makes expressions bigger, not smaller.  Usually this is the case, but often an expression will become smaller upon calling expand() on it due to cancellation.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand((x + 1)*(x - 2) - (x - 1)*x)\n    -2","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-5","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand((x + 1)*(x - 2) - (x - 1)*x)\n-2","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#factor","page":"Simplification","title":"factor","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"factor() takes a polynomial and factors it into irreducible factors over the rational numbers.  For example:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factor(x**3 - x**2 + x - 1)\n            ⎛ 2    ⎞\n    (x - 1)⋅⎝x  + 1⎠\n    >>> factor(x**2*z + 4*x*y*z + 4*y**2*z)\n               2\n    z⋅(x + 2⋅y)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-6","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> factor(x^3 - x^2 + x - 1) |> string\n\"(x - 1)*(x^2 + 1)\"\njulia> factor(x^2*z + 4*x*y*z + 4*y^2*z) |>  string\n\"z*(x + 2*y)^2\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"For polynomials, factor() is the opposite of expand().  factor() uses a complete multivariate factorization algorithm over the rational numbers, which means that each of the factors returned by factor() is guaranteed to be irreducible.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"If you are interested in the factors themselves, factor_list returns a more structured output.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factor_list(x**2*z + 4*x*y*z + 4*y**2*z)\n    (1, [(z, 1), (x + 2⋅y, 2)])","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-7","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> factor_list(x^2*z + 4*x*y*z + 4*y^2*z)\n(1, Tuple{Sym, Int64}[(z, 1), (x + 2*y, 2)])","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that the input to factor and expand need not be polynomials in the strict sense.  They will intelligently factor or expand any kind of expression (though note that the factors may not be irreducible if the input is no longer a polynomial over the rationals).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand((cos(x) + sin(x))**2)\n       2                           2\n    sin (x) + 2⋅sin(x)⋅cos(x) + cos (x)\n    >>> factor(cos(x)**2 + 2*cos(x)*sin(x) + sin(x)**2)\n                     2\n    (sin(x) + cos(x))","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-8","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand((cos(x) + sin(x))^2) |> string\n\"sin(x)^2 + 2*sin(x)*cos(x) + cos(x)^2\"\n\njulia> factor(cos(x)^2 + 2*cos(x)*sin(x) + sin(x)^2) |> string\n\"(sin(x) + cos(x))^2\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#collect","page":"Simplification","title":"collect","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"collect() collects common powers of a term in an expression.  For example","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expr = x*y + x - 3 + 2*x**2 - z*x**2 + x**3\n    >>> expr\n     3    2        2\n    x  - x ⋅z + 2⋅x  + x⋅y + x - 3\n    >>> collected_expr = collect(expr, x)\n    >>> collected_expr\n     3    2\n    x  + x ⋅(-z + 2) + x⋅(y + 1) - 3","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-9","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expr = x*y + x - 3 + 2*x^2 - z*x^2 + x^3\n 3    2        2\nx  - x ⋅z + 2⋅x  + x⋅y + x - 3\n\njulia> collected_expr = collect(expr, x)\n 3    2\nx  + x ⋅(2 - z) + x⋅(y + 1) - 3","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"collect() is particularly useful in conjunction with the .coeff() method.  expr.coeff(x, n) gives the coefficient of x**n in expr:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> collected_expr.coeff(x, 2)\n    -z + 2","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-10","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> collected_expr.coeff(x, 2)\n2 - z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO\nDiscuss coeff method in more detail in some other section (maybe basic expression manipulation tools)","category":"page"},{"location":"Tutorial/simplification/#cancel","page":"Simplification","title":"cancel","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"cancel() will take any rational function and put it into the standard canonical form, fracpq, where p and q are expanded polynomials with no common factors, and the leading coefficients of p and q do not have denominators (i.e., are integers).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> cancel((x**2 + 2*x + 1)/(x**2 + x))\n    x + 1\n    ─────\n      x\n\n    >>> expr = 1/x + (3*x/2 - 2)/(x - 4)\n    >>> expr\n    3⋅x\n    ─── - 2\n     2        1\n    ─────── + ─\n     x - 4    x\n    >>> cancel(expr)\n       2\n    3⋅x  - 2⋅x - 8\n    ──────────────\n         2\n      2⋅x  - 8⋅x\n\n    >>> expr = (x*y**2 - 2*x*y*z + x*z**2 + y**2 - 2*y*z + z**2)/(x**2 - 1)\n    >>> expr\n       2                2    2            2\n    x⋅y  - 2⋅x⋅y⋅z + x⋅z  + y  - 2⋅y⋅z + z\n    ───────────────────────────────────────\n                      2\n                     x  - 1\n    >>> cancel(expr)\n     2            2\n    y  - 2⋅y⋅z + z\n    ───────────────\n         x - 1","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-11","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> cancel((x^2 + 2*x + 1)/(x^2 + x))\nx + 1\n─────\n  x\n\njulia> expr = 1/x + (3*x/2 - 2)/(x - 4)\n3⋅x\n─── - 2\n 2        1\n─────── + ─\n x - 4    x\n\njulia> cancel(expr) |>  string\n\"(3*x^2 - 2*x - 8)/(2*x^2 - 8*x)\"\n\njulia> expr = (x*y^2 - 2*x*y*z + x*z^2 + y^2 - 2*y*z + z^2)/(x^2 - 1)\n   2                2    2            2\nx⋅y  - 2⋅x⋅y⋅z + x⋅z  + y  - 2⋅y⋅z + z\n───────────────────────────────────────\n                  2\n                 x  - 1\n\njulia> cancel(expr)\n 2            2\ny  - 2⋅y⋅z + z\n───────────────\n     x - 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that since factor() will completely factorize both the numerator and the denominator of an expression, it can also be used to do the same thing:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factor(expr)\n           2\n    (y - z)\n    ────────\n     x - 1","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-12","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> factor(expr)  |> string\n\"(y - z)^2/(x - 1)\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"However, if you are only interested in making sure that the expression is in canceled form, cancel() is more efficient than factor().","category":"page"},{"location":"Tutorial/simplification/#apart","page":"Simplification","title":"apart","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"apart() performs a partial fraction decomposition <http://en.wikipedia.org/wiki/Partial_fraction_decomposition>_ on a rational function.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expr = (4*x**3 + 21*x**2 + 10*x + 12)/(x**4 + 5*x**3 + 5*x**2 + 4*x)\n    >>> expr\n       3       2\n    4⋅x  + 21⋅x  + 10⋅x + 12\n    ────────────────────────\n      4      3      2\n     x  + 5⋅x  + 5⋅x  + 4⋅x\n    >>> apart(expr)\n     2⋅x - 1       1     3\n    ────────── - ───── + ─\n     2           x + 4   x\n    x  + x + 1","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-13","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expr = (4*x^3 + 21*x^2 + 10*x + 12)/(x^4 + 5*x^3 + 5*x^2 + 4*x);  string(expr)\n\"(4*x^3 + 21*x^2 + 10*x + 12)/(x^4 + 5*x^3 + 5*x^2 + 4*x)\"\n\njulia> apart(expr)\n 2⋅x - 1       1     3\n────────── - ───── + ─\n 2           x + 4   x\nx  + x + 1\n","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Trigonometric-Simplification","page":"Simplification","title":"Trigonometric Simplification","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Note\nSymPy follows Python's naming conventions for inverse trigonometric functions, which is to append an a to the front of the function's name.  For example, the inverse cosine, or arc cosine, is called acos().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> acos(x)\n   acos(x)\n   >>> cos(acos(x))\n   x\n   >>> asin(1)\n   π\n   ─\n   2","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-14","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> acos(x)\nacos(x)\n\njulia> cos(acos(x))\nx\n\njulia> asin(1)\n1.5707963267948966\n\njulia> sympy.asin(1)\nπ\n─\n2","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO\nCan we actually do anything with inverse trig functions, simplification wise?","category":"page"},{"location":"Tutorial/simplification/#trigsimp","page":"Simplification","title":"trigsimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To simplify expressions using trigonometric identities, use trigsimp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> trigsimp(sin(x)^2 + cos(x)**2)\n    1\n    >>> trigsimp(sin(x)**4 - 2*cos(x)**2*sin(x)**2 + cos(x)**4)\n    cos(4⋅x)   1\n    ──────── + ─\n       2       2\n    >>> trigsimp(sin(x)*tan(x)/sec(x))\n       2\n    sin (x)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-15","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> trigsimp(sin(x)^2 + cos(x)^2)\n1\n\njulia> trigsimp(sin(x)^4 - 2*cos(x)^2*sin(x)^2 + cos(x)^4)\ncos(4⋅x)   1\n──────── + ─\n   2       2\n\njulia> trigsimp(sin(x)*tan(x)/sec(x)) |> string\n\"sin(x)^2\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"trigsimp() also works with hyperbolic trig functions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> trigsimp(cosh(x)**2 + sinh(x)**2)\n    cosh(2⋅x)\n    >>> trigsimp(sinh(x)/tanh(x))\n    cosh(x)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-16","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> trigsimp(cosh(x)^2 + sinh(x)^2)\ncosh(2⋅x)\n\njulia> trigsimp(sinh(x)/tanh(x))\ncosh(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Much like simplify(), trigsimp() applies various trigonometric identities to the input expression, and then uses a heuristic to return the \"best\" one.","category":"page"},{"location":"Tutorial/simplification/#expand_trig","page":"Simplification","title":"expand_trig","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To expand trigonometric functions, that is, apply the sum or double angle identities, use expand_trig().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_trig(sin(x + y))\n    sin(x)⋅cos(y) + sin(y)⋅cos(x)\n    >>> expand_trig(tan(2*x))\n       2⋅tan(x)\n    ─────────────\n         2\n    - tan (x) + 1","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-17","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_trig(sin(x + y))\nsin(x)⋅cos(y) + sin(y)⋅cos(x)\n\njulia> expand_trig(tan(2*x))\n  2⋅tan(x)\n───────────\n       2\n1 - tan (x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Because expand_trig() tends to make trigonometric expressions larger, and trigsimp() tends to make them smaller, these identities can be applied in reverse using trigsimp()","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> trigsimp(sin(x)*cos(y) + sin(y)*cos(x))\n    sin(x + y)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-18","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> trigsimp(sin(x)*cos(y) + sin(y)*cos(x))\nsin(x + y)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO\nIt would be much better to teach individual trig rewriting functions here, but they don't exist yet.  See https://github.com/sympy/sympy/issues/3456.","category":"page"},{"location":"Tutorial/simplification/#Powers","page":"Simplification","title":"Powers","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Before we introduce the power simplification functions, a mathematical discussion on the identities held by powers is in order.  There are three kinds of identities satisfied by exponents","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"x^ax^b = x^{a + b}\nx^ay^a = (xy)^a\n(x^a)^b = x^{ab}","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Identity 1 is always true.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Identity 2 is not always true.  For example, if x = y = -1 and a = frac12, then x^ay^a = sqrt-1sqrt-1 = icdot i = -1, whereas (xy)^a = sqrt-1cdot-1 = sqrt1 = 1.  However, identity 2 is true at least if x and y are nonnegative and a is real (it may also be true under other conditions as well).  A common consequence of the failure of identity 2 is that sqrtxsqrty neq sqrtxy.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Identity 3 is not always true.  For example, if x = -1, a = 2, and b = frac12, then (x^a)^b = left ((-1)^2right )^12 = sqrt1 = 1 and x^ab = (-1)^2cdot12 = (-1)^1 = -1.  However, identity 3 is true when b is an integer (again, it may also hold in other cases as well).  Two common consequences of the failure of identity 3 are that sqrtx^2neq x and that sqrtfrac1x neq frac1sqrtx.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To summarize","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"This: x^ax^b = x^a + b is always true\nThis: x^ay^a = (xy)^a is true when  x y geq 0 and a in mathbbR; but note (-1)^12(-1)^12 neq (-1cdot-1)^12       and sqrtxsqrty neq sqrtxy in general\nThis: (x^a)^b = x^ab  when b in mathbbZ;                  but note left((-1)^2right )^12 neq (-1)^2cdot12 and sqrtx^2neq x and sqrtfrac1xneqfrac1sqrtx in general","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"This is important to remember, because by default, SymPy will not perform simplifications if they are not true in general.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"In order to make SymPy perform simplifications involving identities that are only true under certain assumptions, we need to put assumptions on our Symbols.  We will undertake a full discussion of the assumptions system later, but for now, all we need to know are the following.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"By default, SymPy Symbols are assumed to be complex (elements of mathbbC).  That is, a simplification will not be applied to an expression with a given Symbol unless it holds for all complex numbers.\nSymbols can be given different assumptions by passing the assumption to symbols().  For the rest of this section, we will be assuming that x and y are positive, and that a and b are real.  We will leave z, t, and c as arbitrary complex Symbols to demonstrate what happens in that case.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> x, y = symbols('x y', positive=True)\n    >>> a, b = symbols('a b', real=True)\n    >>> z, t, c = symbols('z t c')","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-19","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The same notation can be used:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> x, y = symbols(\"x y\", positive=true)\n(x, y)\n\njulia> a, b = symbols(\"a b\", real=true)\n(a, b)\n\njulia> z, t, c = symbols(\"z t c\")\n(z, t, c)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"However, the recommended way is to use @syms for symbol construction with assumptions:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> @syms x::positive, y::positive\n(x, y)\n\njulia> @syms a::real, b::real\n(a, b)\n\njulia> @syms z, t, c\n(z, t, c)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO:\nRewrite this using the new assumptions","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Note\nIn SymPy, sqrt(x) is just a shortcut to x**Rational(1, 2).  They are exactly the same object.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"     >>> sqrt(x) == x**Rational(1, 2)\n     True","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-20","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"we can construction rational numbers with //","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> sqrt(x) == x^(1//2)\ntrue","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#powsimp","page":"Simplification","title":"powsimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"powsimp() applies identities 1 and 2 from above, from left to right.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> powsimp(x**a*x**b)\n     a + b\n    x\n   >>> powsimp(x**a*y**a)\n        a\n   (x⋅y)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-21","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> powsimp(x^a*x^b)\n a + b\nx\n\njulia> powsimp(x^a*y^a) |> string\n\"(x*y)^a\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Notice that powsimp() refuses to do the simplification if it is not valid.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powsimp(t**c*z**c)\n     c  c\n    t ⋅z","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-22","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> powsimp(t^c*z^c)\n c  c\nt ⋅z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"If you know that you want to apply this simplification, but you don't want to mess with assumptions, you can pass the force=True flag.  This will force the simplification to take place, regardless of assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powsimp(t**c*z**c, force=True)\n         c\n    (t⋅z)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-23","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> powsimp(t^c*z^c, force=true)  |>  string\n\"(t*z)^c\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that in some instances, in particular, when the exponents are integers or rational numbers, and identity 2 holds, it will be applied automatically.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> (z*t)**2\n     2  2\n    t ⋅z\n   >>> sqrt(x*y)\n    √x⋅√y","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-24","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> (z*t)^2\n 2  2\nt ⋅z\n\njulia> sqrt(x*y)\n√x⋅√y","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"This means that it will be impossible to undo this identity with powsimp(), because even if powsimp() were to put the bases together, they would be automatically split apart again.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> powsimp(z**2*t**2)\n     2  2\n    t ⋅z\n   >>> powsimp(sqrt(x)*sqrt(y))\n    √x⋅√y","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-25","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> powsimp(z^2*t^2)\n 2  2\nt ⋅z\n\njulia> powsimp(sqrt(x)*sqrt(y))\n√x⋅√y","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#expand_power_exp-/-expand_power_base","page":"Simplification","title":"expand_power_exp / expand_power_base","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand_power_exp() and expand_power_base() apply identities 1 and 2 from right to left, respectively.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_power_exp(x**(a + b))\n     a  b\n    x ⋅x\n\n    >>> expand_power_base((x*y)**a)\n     a  a\n    x ⋅y","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-26","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_power_exp(x^(a + b))\n a  b\nx ⋅x\n\njulia> expand_power_base((x*y)^a)\n a  a\nx ⋅y","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As with powsimp(), identity 2 is not applied if it is not valid.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_power_base((z*t)**c)\n         c\n    (t⋅z)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-27","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_power_base((z*t)^c) |> string\n\"(t*z)^c\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"And as with powsimp(), you can force the expansion to happen without fiddling with assumptions by using force=True.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> expand_power_base((z*t)**c, force=True)\n     c  c\n    t ⋅z","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-28","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_power_base((z*t)^c, force=true)\n c  c\nt ⋅z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As with identity 2, identity 1 is applied automatically if the power is a number, and hence cannot be undone with expand_power_exp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> x**2*x**3\n     5\n    x\n   >>> expand_power_exp(x**5)\n     5\n    x","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-29","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> x^2*x^3  |> string\n\"x^5\"\n\njulia> expand_power_exp(x^5) |> string\n\"x^5\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#powdenest","page":"Simplification","title":"powdenest","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"powdenest() applies identity 3, from left to right.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powdenest((x**a)**b)\n     a⋅b\n    x","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-30","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> powdenest((x^a)^b)\n a⋅b\nx","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As before, the identity is not applied if it is not true under the given assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powdenest((z**a)**b)\n        b\n    ⎛ a⎞\n    ⎝z ⎠","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-31","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> powdenest((z^a)^b) |> string\n\"(z^a)^b\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"And as before, this can be manually overridden with force=True.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powdenest((z**a)**b, force=True)\n     a⋅b\n    z","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-32","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> powdenest((z^a)^b, force=true)\n a⋅b\nz","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Exponentials-and-logarithms","page":"Simplification","title":"Exponentials and logarithms","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Note\nIn SymPy, as in Python and most programming languages, log is the natural logarithm, also known as ln.  SymPy automatically provides an alias ln = log in case you forget this.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> ln(x)\n    log(x)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-33","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"ln is exported","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> ln(x)\nlog(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Logarithms have similar issues as powers.  There are two main identities","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"log(xy) = log(x) + log(y)\nlog(x^n) = nlog(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Neither identity is true for arbitrary complex x and y, due to the branch cut in the complex plane for the complex logarithm.  However, sufficient conditions for the identities to hold are if x and y are positive and n is real.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> x, y = symbols('x y', positive=True)\n    >>> n = symbols('n', real=True)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-34","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> @syms x::positive, y::positive\n(x, y)\n\njulia> @syms n::real\n(n,)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As before, z and t will be Symbols with no additional assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that the identity logleft (fracxyright ) = log(x) - log(y) is a special case of identities 1 and 2 by logleft (fracxyright ) = logleft (xcdotfrac1yright ) = log(x) + logleft( y^-1right ) = log(x) - log(y), and thus it also holds if x and y are positive, but may not hold in general.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"We also see that logleft( e^x right) = x comes from logleft ( e^x right) = xlog(e) = x, and thus holds when x is real (and it can be verified that it does not hold in general for arbitrary complex x, for example, logleft (e^x + 2pi iright) = logleft (e^xright ) = x neq x + 2pi i).","category":"page"},{"location":"Tutorial/simplification/#expand_log","page":"Simplification","title":"expand_log","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To apply identities 1 and 2 from left to right, use expand_log().  As always, the identities will not be applied unless they are valid.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_log(log(x*y))\n    log(x) + log(y)\n    >>> expand_log(log(x/y))\n    log(x) - log(y)\n    >>> expand_log(log(x**2))\n    2⋅log(x)\n    >>> expand_log(log(x**n))\n    n⋅log(x)\n    >>> expand_log(log(z*t))\n    log(t⋅z)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-35","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_log(log(x*y))\nlog(x) + log(y)\n\njulia> expand_log(log(x/y))\nlog(x) - log(y)\n\njulia> expand_log(log(x^2))\n2⋅log(x)\n\njulia> expand_log(log(x^n))\nn⋅log(x)\n\njulia> expand_log(log(z*t))\nlog(t⋅z)\n","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As with powsimp() and powdenest(), expand_log() has a force option that can be used to ignore assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_log(log(z**2))\n       ⎛ 2⎞\n    log⎝z ⎠\n    >>> expand_log(log(z**2), force=True)\n    2⋅log(z)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-36","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_log(log(z^2))\n   ⎛ 2⎞\nlog⎝z ⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_log(log(z^2), force=true)\n2⋅log(z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#logcombine","page":"Simplification","title":"logcombine","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To apply identities 1 and 2 from right to left, use logcombine().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> logcombine(log(x) + log(y))\n    log(x⋅y)\n    >>> logcombine(n*log(x))\n       ⎛ n⎞\n    log⎝x ⎠\n    >>> logcombine(n*log(z))\n    n⋅log(z)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-37","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> logcombine(log(x) + log(y))\nlog(x⋅y)\n\njulia> logcombine(n*log(x))\n   ⎛ n⎞\nlog⎝x ⎠\n\njulia> logcombine(n*log(z))\nn⋅log(z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"logcombine() also has a force option that can be used to ignore assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> logcombine(n*log(z), force=True)\n       ⎛ n⎞\n    log⎝z ⎠","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-38","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> logcombine(n*log(z), force=true)\n   ⎛ n⎞\nlog⎝z ⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Special-Functions","page":"Simplification","title":"Special Functions","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"SymPy implements dozens of special functions, ranging from functions in combinatorics to mathematical physics.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"An extensive list of the special functions included with SymPy and their documentation is at the :ref:Functions Module <functions-contents> page.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"For the purposes of this tutorial, let's introduce a few special functions in SymPy.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Let's define x, y, and z as regular, complex Symbols, removing any assumptions we put on them in the previous section.  We will also define k, m, and n.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> x, y, z = symbols('x y z')\n    >>> k, m, n = symbols('k m n')","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-39","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> @syms x, y, z\n(x, y, z)\n\njulia> @syms k, m, n\n(k, m, n)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The factorial <http://en.wikipedia.org/wiki/Factorial>_ function is factorial.  factorial(n) represents n= 1cdot2cdots(n - 1)cdot n. n! represents the number of permutations of n distinct items.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factorial(n)\n    n!","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-40","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> factorial(n)\nn!","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The binomial coefficient <http://en.wikipedia.org/wiki/Binomial_coefficient>_ function is binomial.  binomial(n, k) represents binomnk, the number of ways to choose k items from a set of n distinct items.  It is also often written as nCk, and is pronounced \"n choose k\".","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> binomial(n, k)\n    ⎛n⎞\n    ⎜ ⎟\n    ⎝k⎠","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-41","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> binomial(n, k)\n⎛n⎞\n⎜ ⎟\n⎝k⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The factorial function is closely related to the gamma  function. Gamma(z) = int_0^infty t^z - 1e^-tdt is implemented in  gamma(z), which for positive integer has: z is the same as (z - 1)!.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> gamma(z)\n    Γ(z)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-42","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"recall, we need to load SpecialFunctions for gamma to be available","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> gamma(z)\nΓ(z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The generalized hypergeometric function <http://en.wikipedia.org/wiki/Generalized_hypergeometric_function> is hyper.  hyper([a_1, ..., a_p], [b_1, ..., b_q], z) represents _pF_qleft(beginmatrix a_1 cdots a_p  b_1 cdots b_q endmatrix middle z right).  The most common case is _2F_1, which is often referred to as the ordinary hypergeometric function <http://en.wikipedia.org/wiki/Hypergeometric_function>.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> hyper([1, 2], [3], z)\n     ┌─  ⎛1, 2 │  ⎞\n     ├─  ⎜     │ z⎟\n    2╵ 1 ⎝ 3   │  ⎠","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-43","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"as [1,2] is not symbolic, we qualify hyper","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> sympy.hyper([1, 2], [3], z)\n ┌─  ⎛1, 2 │  ⎞\n ├─  ⎜     │ z⎟\n2╵ 1 ⎝ 3   │  ⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#rewrite","page":"Simplification","title":"rewrite","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"A common way to deal with special functions is to rewrite them in terms of one another.  This works for any function in SymPy, not just special functions. To rewrite an expression in terms of a function, use expr.rewrite(function).  For example,","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> tan(x).rewrite(sin)\n         2\n    2⋅sin (x)\n    ─────────\n     sin(2⋅x)\n    >>> factorial(x).rewrite(gamma)\n    Γ(x + 1)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-44","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> tan(x).rewrite(sin) |> string\n\"2*sin(x)^2/sin(2*x)\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> factorial(x).rewrite(gamma)\nΓ(x + 1)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"For some tips on applying more targeted rewriting, see the :ref:tutorial-manipulation section.","category":"page"},{"location":"Tutorial/simplification/#expand_func","page":"Simplification","title":"expand_func","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To expand special functions in terms of some identities, use expand_func().  For example","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_func(gamma(x + 3))\n    x⋅(x + 1)⋅(x + 2)⋅Γ(x)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-45","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expand_func(gamma(x + 3))\nx⋅(x + 1)⋅(x + 2)⋅Γ(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#hyperexpand","page":"Simplification","title":"hyperexpand","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To rewrite hyper in terms of more standard functions, use hyperexpand().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> hyperexpand(hyper([1, 1], [2], z))\n    -log(-z + 1)\n    ─────────────\n         z","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-46","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As [1,1] is not symbolic, we qualify hyperexpand:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> sympy.hyperexpand(sympy.hyper([1, 1], [2], z))\n-log(1 - z)\n────────────\n     z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"hyperexpand() also works on the more general Meijer G-function (see :py:meth:its documentation <sympy.functions.special.hyper.meijerg> for more information).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expr = meijerg([[1],[1]], [[1],[]], -z)\n    >>> expr\n    ╭─╮1, 1 ⎛1  1 │   ⎞\n    │╶┐     ⎜     │ -z⎟\n    ╰─╯2, 1 ⎝1    │   ⎠\n    >>> hyperexpand(expr)\n     1\n     ─\n     z\n    ℯ","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-47","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"again, we qualify meijerg","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> expr = sympy.meijerg([[1],[1]], [[1],[]], -z)\n╭─╮1, 1 ⎛1  1 │   ⎞\n│╶┐     ⎜     │ -z⎟\n╰─╯2, 1 ⎝1    │   ⎠\njulia> hyperexpand(expr) |> string\n\"exp(1/z)\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#combsimp","page":"Simplification","title":"combsimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To simplify combinatorial expressions, use combsimp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> n, k = symbols('n k', integer = True)\n    >>> combsimp(factorial(n)/factorial(n - 3))\n    n⋅(n - 2)⋅(n - 1)\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\n    n + 1\n    ─────\n    k + 1","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-48","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> @syms n::integer, k::integer\n(n, k)\n\njulia> combsimp(factorial(n)/factorial(n - 3))\nn⋅(n - 2)⋅(n - 1)\n\njulia> combsimp(binomial(n+1, k+1)/binomial(n, k))\nn + 1\n─────\nk + 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#gammasimp","page":"Simplification","title":"gammasimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To simplify expressions with gamma functions or combinatorial functions with non-integer argument, use gammasimp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> gammasimp(gamma(x)*gamma(1 - x))\n       π\n    ────────\n    sin(π⋅x)","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-49","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> gammasimp(gamma(x)*gamma(1 - x)) |> string\n\"pi/sin(pi*x)\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Example:-Continued-Fractions","page":"Simplification","title":"Example: Continued Fractions","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Let's use SymPy to explore continued fractions.  A continued fraction <http://en.wikipedia.org/wiki/Continued_fraction>_ is an expression of the form","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"\n   a_0 + cfrac1a_1 + cfrac1a_2 + cfrac1 ddots + cfrac1a_n\n   \n   ","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"where a_0 ldots a_n are integers, and a_1 ldots a_n are positive. Acontinued fraction can also be infinite, but infinite objects are more difficult to represent in computers, so we will only examine the finite case here.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"A continued fraction of the above form is often represented as a list a_0 a_1 ldots a_n.  Let's write a simple function that converts such a list to its continued fraction form.  The easiest way to construct a continued fraction from a list is to work backwards.  Note that despite the apparent symmetry of the definition, the first element, a_0, must usually be handled differently from the rest.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> def list_to_frac(l):\n    ...     expr = Integer(0)\n    ...     for i in reversed(l[1:]):\n    ...         expr += i\n    ...         expr = 1/expr\n    ...     return l[0] + expr\n    >>> list_to_frac([x, y, z])\n          1\n    x + ─────\n            1\n        y + ─\n            z","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-50","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia>  function list_to_frac(l)\n         expr = Sym(0)\n         for i in reverse(l[2:end])\n           expr += i\n           expr =  1/expr\n         end\n         l[1] + expr\n       end\nlist_to_frac (generic function with 1 method)\n\njulia> list_to_frac([x, y, z]) |> string\n\"x + 1/(y + 1/z)\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"We use Integer(0) in list_to_frac so that the result will always be a SymPy object, even if we only pass in Python ints.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> list_to_frac([1, 2, 3, 4])\n    43\n    ──\n    30","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-51","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> list_to_frac([1, 2, 3, 4]) |> N\n43//30","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Every finite continued fraction is a rational number, but we are interested in symbolics here, so let's create a symbolic continued fraction.  The symbols() function that we have been using has a shortcut to create numbered symbols.  symbols('a0:5') will create the symbols a0, a1, ..., a4.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> syms = symbols('a0:5')\n    >>> syms\n    (a₀, a₁, a₂, a₃, a₄)\n    >>> a0, a1, a2, a3, a4 = syms\n    >>> frac = list_to_frac(syms)\n    >>> frac\n                 1\n    a₀ + ─────────────────\n                   1\n         a₁ + ────────────\n                      1\n              a₂ + ───────\n                        1\n                   a₃ + ──\n                        a₄","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-52","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"We can pass tensor-like notation to @syms to create containers of indexed variables","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> @syms a[0:4]\n(Sym[a₀, a₁, a₂, a₃, a₄],)\n\njulia> frac = list_to_frac(a); string(frac)\n\"a₀ + 1/(a₁ + 1/(a₂ + 1/(a₃ + 1/a₄)))\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"This form is useful for understanding continued fractions, but lets put it into standard rational function form using cancel().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> frac = cancel(frac)\n    >>> frac\n    a₀⋅a₁⋅a₂⋅a₃⋅a₄ + a₀⋅a₁⋅a₂ + a₀⋅a₁⋅a₄ + a₀⋅a₃⋅a₄ + a₀ + a₂⋅a₃⋅a₄ + a₂ + a₄\n    ─────────────────────────────────────────────────────────────────────────\n                     a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-53","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> frac = cancel(frac)\na₀⋅a₁⋅a₂⋅a₃⋅a₄ + a₀⋅a₁⋅a₂ + a₀⋅a₁⋅a₄ + a₀⋅a₃⋅a₄ + a₀ + a₂⋅a₃⋅a₄ + a₂ + a₄\n─────────────────────────────────────────────────────────────────────────\n                 a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Now suppose we were given frac in the above canceled form. In fact, we might be given the fraction in any form, but we can always put it into the above canonical form with cancel().  Suppose that we knew that it could be rewritten as a continued fraction.  How could we do this with SymPy?  A continued fraction is recursively c + frac1f, where c is an integer and f is a (smaller) continued fraction.  If we could write the expression in this form, we could pull out each c recursively and add it to a list.  We could then get a continued fraction with our list_to_frac() function.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The key observation here is that we can convert an expression to the form c + \\frac{1}{f} by doing a partial fraction decomposition with respect to c. This is because f does not contain c.  This means we need to use the apart() function.  We use apart() to pull the term out, then subtract it from the expression, and take the reciprocal to get the f part.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> l = []\n    >>> frac = apart(frac, a0)\n    >>> frac\n                    a₂⋅a₃⋅a₄ + a₂ + a₄\n    a₀ + ───────────────────────────────────────\n         a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n    >>> l.append(a0)\n    >>> frac = 1/(frac - a0)\n    >>> frac\n    a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n    ───────────────────────────────────────\n               a₂⋅a₃⋅a₄ + a₂ + a₄","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-54","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> l = Sym[]\nSym[]\n\njulia> a0,a1,a2,a3,a4 = a; # destructure\n\n\njulia> frac = apart(frac, a0); string(frac)\n\"a₀ + (a₂*a₃*a₄ + a₂ + a₄)/(a₁*a₂*a₃*a₄ + a₁*a₂ + a₁*a₄ + a₃*a₄ + 1)\"\n\njulia> push!(l,  a0)\n1-element Vector{Sym}:\n a₀\n\njulia> frac = 1/(frac - a0); string(frac)\n\"(a₁*a₂*a₃*a₄ + a₁*a₂ + a₁*a₄ + a₃*a₄ + 1)/(a₂*a₃*a₄ + a₂ + a₄)\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Now we repeat this process","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> frac = apart(frac, a1)\n    >>> frac\n             a₃⋅a₄ + 1\n    a₁ + ──────────────────\n         a₂⋅a₃⋅a₄ + a₂ + a₄\n    >>> l.append(a1)\n    >>> frac = 1/(frac - a1)\n    >>> frac = apart(frac, a2)\n    >>> frac\n             a₄\n    a₂ + ─────────\n         a₃⋅a₄ + 1\n    >>> l.append(a2)\n    >>> frac = 1/(frac - a2)\n    >>> frac = apart(frac, a3)\n    >>> frac\n         1\n    a₃ + ──\n         a₄\n    >>> l.append(a3)\n    >>> frac = 1/(frac - a3)\n    >>> frac = apart(frac, a4)\n    >>> frac\n    a₄\n    >>> l.append(a4)\n    >>> list_to_frac(l)\n                 1\n    a₀ + ─────────────────\n                   1\n         a₁ + ────────────\n                      1\n              a₂ + ───────\n                        1\n                   a₃ + ──\n                        a₄","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-55","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> frac = apart(frac, a1);\n\njulia> push!(l, a1);\n\njulia> frac = 1/(frac - a1);\n\njulia> frac = apart(frac, a2);\n\njulia> push!(l, a2);\n\njulia> frac = 1/(frac - a2);\n\njulia> frac = apart(frac, a3);\n\njulia> push!(l, a3);\n\njulia> frac = 1/(frac - a3);\n\njulia> frac = apart(frac, a4);\n\njulia> push!(l, a4);\n\njulia> list_to_frac(l) |> string\n\"a₀ + 1/(a₁ + 1/(a₂ + 1/(a₃ + 1/a₄)))\"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Quick tip\nYou can execute multiple lines at once in SymPy Live.  Typing Shift-Enter instead of Enter will enter a newline instead of executing.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Of course, this exercise seems pointless, because we already know that our frac is list_to_frac([a0, a1, a2, a3, a4]).  So try the following exercise.  Take a list of symbols and randomize them, and create the canceled continued fraction, and see if you can reproduce the original list.  For example","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> import random\n    >>> l = list(symbols('a0:5'))\n    >>> random.shuffle(l)\n    >>> orig_frac = frac = cancel(list_to_frac(l))\n    >>> del l","category":"page"},{"location":"Tutorial/simplification/#In-Julia:-56","page":"Simplification","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"shuffle from Python is randperm in the Random module","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"julia> using Random\n\njulia> @syms a[0:4]\n(Sym[a₀, a₁, a₂, a₃, a₄],)\n\njulia> a = a[randperm(length(a))]\n5-element Vector{Sym}:\n a₄\n a₀\n a₃\n a₂\n a₁\n\njulia> orig_frac = frac = cancel(list_to_frac(a))\na₀⋅a₁⋅a₂⋅a₃⋅a₄ + a₀⋅a₁⋅a₄ + a₀⋅a₃⋅a₄ + a₁⋅a₂⋅a₃ + a₁⋅a₂⋅a₄ + a₁ + a₃ + a₄\n─────────────────────────────────────────────────────────────────────────\n                 a₀⋅a₁⋅a₂⋅a₃ + a₀⋅a₁ + a₀⋅a₃ + a₁⋅a₂ + 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Click on \"Run code block in SymPy Live\" on the definition of list_to_frac() above, and then on the above example, and try to reproduce l from frac.  I have deleted l at the end to remove the temptation for peeking (you can check your answer at the end by calling cancel(list_to_frac(l)) on the list that you generate at the end, and comparing it to orig_frac.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"See if you can think of a way to figure out what symbol to pass to apart() at each stage (hint: think of what happens to a_0 in the formula a_0 + frac1a_1 + cdots when it is canceled).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Note\nAnswer: a0 is the only symbol that does not appear in the denominator","category":"page"},{"location":"Tutorial/basic_operations/#Basic-Operations","page":"Basic operations","title":"Basic Operations","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"From","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Here we discuss some of the most basic operations needed for expression manipulation in SymPy.  Some more advanced operations will be discussed later in the :ref:advanced expression manipulation <tutorial-manipulation> section.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> from sympy import *\n    >>> x, y, z = symbols(\"x y z\")","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"using SymPy\nsympy.init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> using SymPy\n\njulia> x, y, z = symbols(\"x y z\")\n(x, y, z)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"We didn't replicate from sympy import *, though this is mostly done through the command import_from(sympy).  By default, SymPy only makes available a priviledged collection of the functions available through the sympy object. The import_from imports most all of the rest.\nIf a function is not imported, it may be referenced through qualification, asin sympy.expand_trig, as will be seen in the following.\nthe use of symbols to construct symbolic values is more easily facilitated with the macro @syms, used as follows","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> @syms x, y, z\n(x, y, z)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/#Substitution","page":"Basic operations","title":"Substitution","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"One of the most common things you might want to do with a mathematical expression is substitution.  Substitution replaces all instances of something in an expression with something else.  It is done using the subs method. For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = cos(x) + 1\n    >>> expr.subs(x, y)\n    cos(y) + 1","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-2","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = cos(x) + 1\ncos(x) + 1\n\njulia> expr.subs(x, y)\ncos(y) + 1","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Julia also allows \"call\" notation using a pairs to indicate the substitution:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr(x => y)\ncos(y) + 1","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Substitution is usually done for one of two reasons:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Evaluating an expression at a point. For example, if our expression is cos(x) + 1 and we want to evaluate it at the point x = 0, so that we get cos(0) + 1, which is 2.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr.subs(x, 0)\n   2","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-3","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr(x => 0)\n2","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Replacing a subexpression with another subexpression.  There are two reasons we might want to do this.  The first is if we are trying to build an expression that has some symmetry, such as x^{x^{x^x}}.  To build this, we might start with x**y, and replace y with x**y.  We would then get x**(x**y).  If we replaced y in this new expression with x**x, we would get x**(x**(x**x)), the desired expression.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr = x**y\n   >>> expr\n   x**y\n   >>> expr = expr.subs(y, x**y)\n   >>> expr\n   x**(x**y)\n   >>> expr = expr.subs(y, x**x)\n   >>> expr\n   x**(x**(x**x))","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-4","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = x^y\n y\nx\n\njulia> expr = expr(y => x^y)\n ⎛ y⎞\n ⎝x ⎠\nx\n\njulia> expr = expr(y => x^x)\n ⎛ ⎛ x⎞⎞\n ⎜ ⎝x ⎠⎟\n ⎝x    ⎠\nx\n","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The second is if we want to perform a very controlled simplification, or    perhaps a simplification that SymPy is otherwise unable to do.  For    example, say we have \\sin(2x) + \\cos(2x), and we want to replace    \\sin(2x) with 2\\sin(x)\\cos(x).  As we will learn later, the function    expand_trig does this.  However, this function will also expand    \\cos(2x), which we may not want.  While there are ways to perform such    precise simplification, and we will learn some of them in the    :ref:advanced expression manipulation <tutorial-manipulation> section, an    easy way is to just replace \\sin(2x) with 2\\sin(x)\\cos(x).","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr = sin(2*x) + cos(2*x)\n   >>> expand_trig(expr)\n   2*sin(x)*cos(x) + 2*cos(x)**2 - 1\n   >>> expr.subs(sin(2*x), 2*sin(x)*cos(x))\n   2*sin(x)*cos(x) + cos(2*x)","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-5","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expand_trig is not exported, so we qualify it:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = sin(2*x) + cos(2*x)\nsin(2⋅x) + cos(2⋅x)\n\njulia> sympy.expand_trig(expr) |> string\n\"2*sin(x)*cos(x) + 2*cos(x)^2 - 1\"\n\njulia> expr(sin(2*x) => 2*sin(x)*cos(x))\n2⋅sin(x)⋅cos(x) + cos(2⋅x)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"There are two important things to note about subs.  First, it returns a new expression.  SymPy objects are immutable.  That means that subs does not modify it in-place.  For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr = cos(x)\n   >>> expr.subs(x, 0)\n   1\n   >>> expr\n   cos(x)\n   >>> x\n   x","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-6","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = cos(x)\ncos(x)\n\njulia> expr(x => 0)\n1\n\njulia> expr\ncos(x)\n\njulia> x\nx","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: Quick Tip\nSymPy expressions are immutable.  No function will change them in-place.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Here, we see that performing expr.subs(x, 0) leaves expr unchanged. In fact, since SymPy expressions are immutable, no function will change them in-place.  All functions will return new expressions.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To perform multiple substitutions at once, pass a list of (old, new) pairs to subs.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = x**3 + 4*x*y - z\n    >>> expr.subs([(x, 2), (y, 4), (z, 0)])\n    40","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-7","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = x^3 + 4*x*y - z;  string(expr)\n\"x^3 + 4*x*y - z\"\n\njulia> expr.subs([(x, 2), (y, 4), (z, 0)])\n40","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Or, using pairs:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr(x=>2, y=>4, z=>0)\n40","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"It is often useful to combine this with a list comprehension to do a large set of similar replacements all at once.  For example, say we had x^4 - 4x^3 + 4x^2 - 2x + 3 and we wanted to replace all instances of x that have an even power with y, to get y^4 - 4x^3 + 4y^2 - 2x + 3.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = x**4 - 4*x**3 + 4*x**2 - 2*x + 3\n    >>> replacements = [(x**i, y**i) for i in range(5) if i % 2 == 0]\n    >>> expr.subs(replacements)\n    -4*x**3 - 2*x + y**4 + 4*y**2 + 3","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-8","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = x^4 - 4*x^3 + 4*x^2 - 2*x + 3\n 4      3      2\nx  - 4⋅x  + 4⋅x  - 2⋅x + 3\n\njulia> replacements = [(x^i, y^i) for i in 1:5 if iseven(i)]\n2-element Vector{Tuple{Sym, Sym}}:\n (x^2, y^2)\n (x^4, y^4)\n\njulia> expr.subs(replacements)\n     3          4      2\n- 4⋅x  - 2⋅x + y  + 4⋅y  + 3","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/#Converting-Strings-to-SymPy-Expressions","page":"Basic operations","title":"Converting Strings to SymPy Expressions","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The sympify function (that's sympify, not to be confused with simplify) can be used to convert strings into SymPy expressions.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> str_expr = \"x**2 + 3*x - 1/2\"\n    >>> expr = sympify(str_expr)\n    >>> expr\n    x**2 + 3*x - 1/2\n    >>> expr.subs(x, 2)\n    19/2","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-9","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"As sympify is not passed a symbolic value, it is qualified:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> str_expr = \"x^2 + 3*x - 1/2\"\n\"x^2 + 3*x - 1/2\"\n\njulia> expr = sympy.sympify(str_expr)\n 2         1\nx  + 3⋅x - ─\n           2\njulia> expr.subs(x, 2)\n19/2","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: Alert:\nsympify uses eval.  Don't use it on unsanitized input.","category":"page"},{"location":"Tutorial/basic_operations/#evalf","page":"Basic operations","title":"evalf","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To evaluate a numerical expression into a floating point number, use evalf.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = sqrt(8)\n    >>> expr.evalf()\n    2.82842712474619","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-10","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"We must use a symbolic value for 8:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = sqrt(Sym(8))\n2⋅√2\n\njulia> expr.evalf()\n2.82842712474619","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: N is different in SymPy.jl\nMore importantly, SymPy.jl treats N differently from evalf. N is used to convert a SymPy numeric (or Boolean) value to a Julian counterpart. The main difference between N(x) and convert(T, x), is that rather than specify the Julia type as T, N works to guess the appropriate type for the SymPy object.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> N(sqrt(8))   # brings back as BigFloat\n2.8284271247461903","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> N(sqrt(9))   # an Int\n3.0","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"SymPy can evaluate floating point expressions to arbitrary precision.  By default, 15 digits of precision are used, but you can pass any number as the argument to evalf.  Let's compute the first 100 digits of \\pi.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> pi.evalf(100)\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-11","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> PI.evalf(100)\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To numerically evaluate an expression with a Symbol at a point, we might use subs followed by evalf, but it is more efficient and numerically stable to pass the substitution to evalf using the subs flag, which takes a dictionary of Symbol: point pairs.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = cos(2*x)\n    >>> expr.evalf(subs={x: 2.4})\n    0.0874989834394464","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-12","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"A Dict can be used:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> expr = cos(2*x)\ncos(2⋅x)\n\njulia> expr.evalf(subs=Dict(x => 2.4))\n0.0874989834394464","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Sometimes there are roundoff errors smaller than the desired precision that remain after an expression is evaluated. Such numbers can be removed at the user's discretion by setting the chop flag to True.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> one = cos(1)**2 + sin(1)**2\n    >>> (one - 1).evalf()\n    -0.e-124\n    >>> (one - 1).evalf(chop=True)\n    0","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-13","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"we need to use symbolic values for 1 in defining  _one:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> _one = cos(Sym(1))^2 + sin(Sym(1))^2\n   2         2\ncos (1) + sin (1)\n\njulia> (_one - 1).evalf()\n-0.e-124","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> (_one - 1).evalf(chop=true)\n0","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/#N-with-Julia","page":"Basic operations","title":"N with Julia","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The N function is used to convert a symbolic number or boolean into a Julia counterpart.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> two = Sym(2)\n2\n\njulia> a,b,c,d = two, sqrt(two), two^20, two^100\n(2, sqrt(2), 1048576, 1267650600228229401496703205376)\n\njulia> N.((a,b,c,d))\n(2, 1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1048576, 1267650600228229401496703205376)","category":"page"},{"location":"Tutorial/basic_operations/#lambdify","page":"Basic operations","title":"lambdify","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"subs and evalf are good if you want to do simple evaluation, but if you intend to evaluate an expression at many points, there are more efficient ways.  For example, if you wanted to evaluate an expression at a thousand points, using SymPy would be far slower than it needs to be, especially if you only care about machine precision.  Instead, you should use libraries like NumPy <http://www.numpy.org/>_ and SciPy <http://www.scipy.org/>_.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The easiest way to convert a SymPy expression to an expression that can be numerically evaluated is to use the lambdify function.  lambdify acts like a lambda function, except it converts the SymPy names to the names of the given numerical library, usually NumPy.  For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> import numpy # doctest:+SKIP\n    >>> a = numpy.arange(10) # doctest:+SKIP\n    >>> expr = sin(x)\n    >>> f = lambdify(x, expr, \"numpy\") # doctest:+SKIP\n    >>> f(a) # doctest:+SKIP\n    [ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427\n     -0.2794155   0.6569866   0.98935825  0.41211849]","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: Alert\nlambdify uses eval.  Don't use it on unsanitized input.","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-14","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"lambdify is defined seperately and with a different argument order: lambdify(ex, vars=free_symbols(ex)).","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> a = 0:10\n0:10\n\njulia> @syms x\n(x,)\n\njulia> expr = sin(x)\nsin(x)\n\njulia> fn = lambdify(expr);\n\njulia> fn.(a)\n11-element Vector{Float64}:\n  0.0\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n -0.27941549819892586\n  0.6569865987187891\n  0.9893582466233818\n  0.4121184852417566\n -0.5440211108893698","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: Technical note\nThe lambdify  function converts a symbolic  expression into  a Julia  expression, and then creates a function using invokelatest  to avoid  world  age issues.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"More performant functions can be produced using the following pattern:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> ex = sin(x)^2 + x^2\n 2      2\nx  + sin (x)\n\njulia> body = convert(Expr, ex)\n:(x ^ 2 + sin(x) ^ 2)\n\njulia> syms = Symbol.(free_symbols(ex))\n1-element Vector{Symbol}:\n :x\n\njulia> fn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));\n\njulia> fn(pi)\n9.869604401089358","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"You can use other libraries than NumPy. For example, to use the standard library math module, use \"math\".","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> f = lambdify(x, expr, \"math\")\n    >>> f(0.1)\n    0.0998334166468","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-15","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"this doesn't apply, so is not implemented.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To use lambdify with numerical libraries that it does not know about, pass a dictionary of sympy_name:numerical_function pairs.  For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> def mysin(x):\n    ...     \"\"\"\n    ...     My sine. Note that this is only accurate for small x.\n    ...     \"\"\"\n    ...     return x\n    >>> f = lambdify(x, expr, {\"sin\":mysin})\n    >>> f(0.1)\n    0.1","category":"page"},{"location":"Tutorial/basic_operations/#In-Julia:-16","page":"Basic operations","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The fns dictionary coud be used to do this, though due to the call of eval, we must do this in the proper module:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"julia> mysin(x) = cos(x)\nmysin (generic function with 1 method)\n\njulia> ex = sin(x)\nsin(x)\n\njulia> body = SymPy.walk_expression(ex, fns=Dict(\"sin\" => :mysin))\n:(mysin(x))\n\njulia> syms = (:x,)\n(:x,)\n\njulia> fn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));\n\njulia> fn(0)\n1.0","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: TODO\nWrite an advanced numerics section","category":"page"},{"location":"reference/#Reference/API","page":"Reference/API","title":"Reference/API","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"DocTestSetup = quote\n  using SymPy\nend","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SymPy, SymPy.𝑄, SymPy.Introspection]\nOrder   = [:function, :constant, :macro, :type, :module]","category":"page"},{"location":"reference/#Base.:~-Tuple{Number, SymPy.SymbolicObject}","page":"Reference/API","title":"Base.:~","text":"lhs ~ rhs\n\nSpecify an equation.\n\nAlternative syntax to Eq(lhs, rhs) or lhs ⩵ rhs (\\Equal[tab]) following Symbolics.jl.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Tuple{Sym, Vararg{Sym}}","page":"Reference/API","title":"Base.getindex","text":"x[i]\n\nSome SymPy Python objects have index notation provided for them through __getitem__. This allows Julia's getindex to dispatch to Python's __getitem__. The index (indices) must be symbolic. This will use 0-based indexing, as it is a simple pass through to Python.\n\nExamples:\n\njulia> using SymPy\n\njulia> i,j = sympy.symbols(\"i j\", integer=True)\n(i, j)\n\njulia> x = sympy.IndexedBase(\"x\")\nx\n\njulia> a = sympy.Sum(x[i], (i, 1, j))\n  j\n ___\n ╲\n  ╲\n  ╱   x[i]\n ╱\n ‾‾‾\ni = 1\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Tuple{SymMatrix, Int64, Int64}","page":"Reference/API","title":"Base.getindex","text":"M[i,j]\n\nDefine getindex for SymPy's ImmutableMatrix class.\n\nSymMatrix is 0-based, like python, not Julia. Use Matrix{Sym} for that.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.match-Tuple{Sym, Sym, Vararg{Any}}","page":"Reference/API","title":"Base.match","text":"match(pattern, expression, ...)\n\nMatch a pattern against an expression; returns a dictionary of matches.\n\nIf a match is unsuccesful, returns an empty dictionary. (SymPy returns \"nothing\")\n\nThe order of the arguments follows Julia's match function, not sympy.match, which can be used directly, otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.occursin-Tuple{Any, SymPermutationGroup}","page":"Reference/API","title":"Base.occursin","text":"occursin(x, G::SymPermutationGroup)\n\nDoes G contain x. (In SymPy, this is `contains.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.replace-Tuple{Sym, Sym, Function}","page":"Reference/API","title":"Base.replace","text":"replace(expression, pattern, value, ...)\nreplace(expression, pattern => value; kwargs...)\n\nIn the expression replace a mathcing pattern with the value. Returns the modified expression.\n\nExtended help\n\nFrom: SymPy Docs\n\nTraverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to false. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is true, then the match will only succeed if non-zero values are received for each Wild that appears in the match pattern.\n\nDifferences from SymPy:\n\n\"types\" are specified via calling func on the head of an expression: func(sin(x)) -> sin, or directly through sympy.sin\nfunctions are supported, but only with PyCall commands.\n\nExamples (from the SymPy docs)\n\njulia> using SymPy\n\njulia> x, y, z = symbols(\"x, y, z\")\n(x, y, z)\n\njulia> f = log(sin(x)) + tan(sin(x^2)); string(f) # `string(f)` only so doctest can run\n\"log(sin(x)) + tan(sin(x^2))\"\n\n\n\"type\" -> \"type\"\n\nTypes are specified through func:\n\njulia> func = SymPy.Introspection.func\nfunc (generic function with 1 method)\n\njulia> replace(f, func(sin(x)), func(cos(x))) |> string  # type -> type\n\"log(cos(x)) + tan(cos(x^2))\"\n\njulia> replace(f, sympy.sin, sympy.cos)  |>  string\n\"log(cos(x)) + tan(cos(x^2))\"\n\njulia> sin(x).replace(sympy.sin, sympy.cos, map=true)\n(cos(x), Dict{Any, Any}(sin(x) => cos(x)))\n\n\nThe func function finds the head of an expression (sin and cos above). This could also have been written (perhaps more directly) as:\n\njulia> replace(f, sympy.sin, sympy.cos) |> string\n\"log(cos(x)) + tan(cos(x^2))\"\n\n\n\"type\" -> \"function\"\n\nTo replace with a more complicated function, requires some assistance from Python, as an anonymous function must be defined witin Python, not Julia:\n\njulia> import PyCall\n\njulia> ## Anonymous function a -> sin(2a)\n       PyCall.py\"\"\"\n       from sympy import sin, Mul\n       def anonfn(*args):\n           return sin(2*Mul(*args))\n       \"\"\")\n\n\njulia> replace(f, sympy.sin, PyCall.py\"anonfn\")\n                   ⎛   ⎛   2⎞⎞\nlog(sin(2⋅x)) + tan⎝sin⎝2⋅x ⎠⎠\n\n\"pattern\" -> \"expression\"\n\nUsing \"Wild\" variables allows a pattern to be replaced by an expression:\n\njulia> a, b = Wild(\"a\"), Wild(\"b\")\n(a_, b_)\n\njulia> replace(f, sin(a), tan(2a)) |> string\n\"log(tan(2*x)) + tan(tan(2*x^2))\"\n\njulia> replace(f, sin(a), tan(a/2)) |> string\n\"log(tan(x/2)) + tan(tan(x^2/2))\"\n\njulia> f.replace(sin(a), a) |> string\n\"log(x) + tan(x^2)\"\n\njulia> (x*y).replace(a*x, a)\ny\n\n\nIn the SymPy docs we have:\n\nMatching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols.\"\n\njulia> replace(2x + y, a*x+b, b-a)  # y - 2\ny - 2\n\njulia> replace(2x + y, a*x+b, b-a, exact=false)  # y + 2/x\n    2\ny + ─\n    x\n\n\"pattern\" -> \"func\"\n\nThe function is redefined, as a fixed argument is passed:\n\njulia> PyCall.py\"\"\"\n       from sympy import sin\n       def anonfn(a):\n           return sin(2*a)\n       \"\"\"\n\njulia> replace(f, sin(a), PyCall.py\"anonfn\")\n                   ⎛   ⎛   2⎞⎞\nlog(sin(2⋅x)) + tan⎝sin⎝2⋅x ⎠⎠\n\n\"func\" -> \"func\"\n\n\njulia> PyCall.py\"\"\"\n       def fn1(expr):\n           return expr.is_Number\n\n       def fn2(expr):\n           return expr**2\n       \"\"\"\n\njulia> replace(2*sin(x^3), PyCall.py\"fn1\", PyCall.py\"fn2\")\n     ⎛ 9⎞\n4⋅sin⎝x ⎠\n\njulia> PyCall.py\"\"\"\n       def fn1(x):\n           return x.is_Mul\n\n       def fn2(x):\n           return 2*x\n       \"\"\"\n\njulia> replace(x*(x*y + 1), PyCall.py\"fn1\", PyCall.py\"fn2\")\n2⋅x⋅(2⋅x⋅y + 1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CommonSolve.solve-Tuple{}","page":"Reference/API","title":"CommonSolve.solve","text":"solve\n\nUse solve to solve algebraic equations.\n\nExamples:\n\njulia> using SymPy\n\njulia> @syms x y a b c d\n(x, y, a, b, c, d)\n\njulia> solve(x^2 + 2x + 1, x) # [-1]\n1-element Vector{Sym}:\n -1\n\njulia> solve(x^2 + 2a*x + a^2, x) # [-a]\n1-element Vector{Sym}:\n -a\n\njulia> solve([a*x + b*y-3, c*x + b*y - 1], [x,y]) # Dict(y => (a - 3*c)/(b*(a - c)),x => 2/(a - c))\nDict{Any, Any} with 2 entries:\n  y => (a - 3*c)/(a*b - b*c)\n  x => 2/(a - c)\n\n\nnote: Note\nA very nice example using solve is a blog entry on Napolean's theorem by Xing Shi Cai.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.N-Tuple{Sym, Int64}","page":"Reference/API","title":"SymPy.N","text":"N(x::Sym, digits::Int)\n\nN can take a precision argument, whichm when given as an integer greater than 16, we try to match the digits of accuracy using BigFloat precision on conversions to floating point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.N-Tuple{Sym}","page":"Reference/API","title":"SymPy.N","text":"N(ex)\n\nConvert a Sym value to a numeric Julian value.\n\nIn SymPy, N(ex, options...) is identifcal to ex.evalf(options...) and is used to convert expressions into floating-point approximations. A positional precision argument indicates the number of digits, keyword arguments chop can be used to trim floating point roundoff errors and subs for free variable substitution prior to conversions.\n\nFor example, symbolic roots can be computed numerically, even if not available symbolically, by calling N on the values.\n\nUsing SymPy within Julia makes having two such functions useful:\n\none to do the equivalent of SymPy's evalf call\none to convert these expressions back into Julia objects (like convert(T,  ex))\n\nWe use N to return a Julia object and evalf to return a symbolic object. The type of Julia object is heurisitically identified.\n\nExamples:\n\njulia> using SymPy\n\njulia> x = Sym(\"x\")\nx\n\njulia> p = subs(x, x, pi)\nπ\n\njulia> N(p)                            # float version of pi\nπ = 3.1415926535897...\n\njulia> p.evalf(60)                     # 60 digits of pi, as a symbolic value\n3.14159265358979323846264338327950288419716939937510582097494\n\njulia> N(p, 60)                        # when a precision is given, \"Big\" values are returned\n3.141592653589793238462643383279502884197169399375105820974939\n\njulia> r = subs(x,x,1.2)\n1.20000000000000\n\njulia> N(r)                            # float\n1.2\n\njulia> q = subs(x, x, 1//2)\n1/2\n\njulia> N(q)                            # 1//2\n1//2\n\njulia> z = solve(x^2 + 1)[1]           # -ⅈ\n-ⅈ\n\njulia> N(z)                            # 0 - 1im\n0 - 1im\n\njulia> z.evalf()\n-1.0⋅ⅈ\n\njulia> rts = solve(x^5 - x + 1)\n5-element Vector{Sym}:\n CRootOf(x^5 - x + 1, 0)\n CRootOf(x^5 - x + 1, 1)\n CRootOf(x^5 - x + 1, 2)\n CRootOf(x^5 - x + 1, 3)\n CRootOf(x^5 - x + 1, 4)\n\njulia> [r.evalf() for r in rts]          # numeric solutions to quintic\n5-element Vector{Sym}:\n                       -1.16730397826142\n -0.181232444469875 - 1.08395410131771⋅ⅈ\n -0.181232444469875 + 1.08395410131771⋅ⅈ\n 0.764884433600585 - 0.352471546031726⋅ⅈ\n 0.764884433600585 + 0.352471546031726⋅ⅈ\n\njulia> [N(r) for r in rts]\n5-element Vector{Number}:\n                     -1.167303978261418684256045899854842180720560371525489039140082449275651903429536\n -0.18123244446987538 - 1.0839541013177107im\n -0.18123244446987538 + 1.0839541013177107im\n   0.7648844336005847 - 0.35247154603172626im\n   0.7648844336005847 + 0.35247154603172626im\n\nN returns the value unchanged when it has free symbols.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.Permutation-Tuple{Any}","page":"Reference/API","title":"SymPy.Permutation","text":"Permutation(args...)\n\nThis module mostly implements SymPy's Permutation module.\n\nA permuation can be represented in different ways. Here a permutation is a reaarangment of the values 0, 1, ..., n. For example, the mapping 0->2, 1->3, 2->0, 3->1 can be presented by a vector: sigma = [2,3,0,1] where sigma[i] = j when i -> j. Otheriwse, it can be presented as a product of cycles: (0 2)(1 3) which reads 0 goes to 2 which goes to 0 (wrapping) and 1 goes to 3 and 3 goes to 1.\n\nEither representation can be passed through the Permutation constructor.\n\nFor the vector notation – 0-based – it is passed directly to the constructor:\n\njulia> using SymPy\n\njulia> p = Permutation([2,3,0,1])\n(0 2)(1 3)\n\n\nIf a range describes a permutation, it can be used as well:\n\njulia> id = Permutation(10:-1:0)\n(0 10)(1 9)(2 8)(3 7)(4 6)\n\n\nCycle notation can more compactly describe a permuation, it can be passed in as a container of cycles specified through tuples or vectors:\n\njulia>  p = Permutation([(0,2), (1,3)])\n(0 2)(1 3)\n\n\nThe latter can be be expresed more quickly as\n\njulia> p = Permutation(0,2)(1,3)\n(0 2)(1 3)\n\n\nThis works as a single cycle can be passed to the Permutation constructor with values separated by commas and the \"call\" method for Permuation objects is overloaded: for a single argument, the mapping i -> j is created (also the notation i^p returns this) but if more than one argument is given, a cycle is created and multiplied on the right by p, so that the above becomes (0,2) * (1,3).\n\nHere are two permutations forming the symmetries of square, naturally represented in the two ways:\n\njulia> flip = Permutation([[0,1],[2,3]])  # or Permutation(0,1)(2,3)\n(0 1)(2 3)\n\njulia> rotate = Permutation([1,2,3,0])    # or Permutation(0,1,2,3) in cycle notation\n(0 1 2 3)\n\n\nOperations on permutations include:\n\na function call, p(i) to recover j where i -> j, also i^p.\n* for multiplication. The convention is (p*q)(i) = q(p(i)) or with the ^ notation: i^(p*q) = (i^p)^q.\n+ for multiplication when p and q commute, where a check on commuting is performed.\ninv for the inverse permutation.\n/, where p/q is p * inv(q).\np^n for powers. We have inv(p) = p^(-1) and p^order(p) is the identity.\np^q for conjugate, defined by inv(q) * p * q.\n\nWe can see that a flip is an involution through:\n\njulia> flip^2  # the identity\n()\n\n\nwhereas a rotation is not (as it has order 4)\n\njulia> rotate * rotate\n(0 2)(1 3)\n\njulia> rotate.order()\n4\n\n\nThese two operations do not commute:\n\njulia> flip * rotate\n(0 2)\n\n\njulia> rotate * flip  # (1 3)\n(1 3)\n\n\nWe can see this is the correct mapping 1 -> 3 with\n\njulia> (1^rotate)^flip, 1^(rotate*flip), flip(rotate(1))\n(3, 3, 3)\n\n\nWe can check that flip and rotate^2 do commute:\n\njulia> id = Permutation(3)   # (n) is the identify\n()\n\njulia> flip.commutator(rotate^2) == id\ntrue\n\n\nThe conjugate for flip and rotate does the inverse of the flip, then rotates, then flips:\n\njulia> rotate^flip\n(0 3 2 1)\n\n\nThis is different than flip^rotate. As flip commutes with rotate^2 this will return rotate^2:\n\njulia> (rotate^2)^flip\n(0 2)(1 3)\n\n\nnote: Differences\nThere is no support currently for the Cycle class\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.PermutationGroup-Tuple","page":"Reference/API","title":"SymPy.PermutationGroup","text":"PermutationGroup()\n\nCreate Permutation group from group generators\n\nA PermutationGroup is one generated by a collection of permutations.\n\nSome pre-defined groups are built-in:\n\nSymmetricgGroup(n): S_n or all symmetries of an n-gon\nCyclicGroup: the group Z_n\nDihedralGroup: Group formed by a flip and rotation\nAlternativeGroup: Subgroup of S_n of even elements\nAbelianGroup: Returns the direct product of cyclic groups with the given orders.\n\nDifferences:\n\nuse collect(generate(G)) in place of list(G.generate())\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.Wild-Tuple{AbstractString}","page":"Reference/API","title":"SymPy.Wild","text":"Wild(x)\n\ncreate a \"wild card\" for pattern matching\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.ask-Tuple{Sym, Vararg{Any}}","page":"Reference/API","title":"SymPy.ask","text":"ask(query)\n\nReturns true, false, or nothing; ask\n\nExample:\n\njulia> using SymPy\n\njulia> @vars x y integer=true\n(x, y)\n\njulia> ask(𝑄.integer(x*y), And(𝑄.integer(x), 𝑄.integer(y)))\ntrue\n\njulia> ## really slow isprime:\n       filter(x -> ask(𝑄.prime(x)), 1:10)\n4-element Vector{Int64}:\n 2\n 3\n 5\n 7\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.doit-Tuple{T} where T<:SymPy.SymbolicObject","page":"Reference/API","title":"SymPy.doit","text":"doit evaluates objects that are not evaluated by default.\n\nExamples:\n\njulia> using SymPy\n\njulia> @syms x f()\n(x, f)\n\njulia> D = Differential(x)\nDifferential(x)\n\njulia> df = D(f(x))\nd\n──(f(x))\ndx\n\njulia> dfx = subs(df, (f(x), x^2))\nd ⎛ 2⎞\n──⎝x ⎠\ndx\n\njulia> doit(dfx)\n2⋅x\n\nSet deep=true to apply doit recursively to force evaluation of nested expressions:\n\njulia> @syms g()\n(g,)\n\njulia> dgfx = g(dfx)\n ⎛d ⎛ 2⎞⎞\ng⎜──⎝x ⎠⎟\n ⎝dx    ⎠\n\njulia> doit(dgfx)\n ⎛d ⎛ 2⎞⎞\ng⎜──⎝x ⎠⎟\n ⎝dx    ⎠\n\njulia> doit(dgfx, deep=true)\ng(2⋅x)\n\nThere is also a curried form of doit:\n\njulia> dfx |> doit\n2⋅x\n\njulia> dgfx |> doit(deep=true)\ng(2⋅x)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.dsolve-Tuple{Any, Vararg{Any}}","page":"Reference/API","title":"SymPy.dsolve","text":"dsolve(eqn, var, args..,; ics=nothing, kwargs...)\n\nCall sympy.dsolve.\n\nThe initial conditions are specified with a dictionary.\n\nExample:\n\njulia> using SymPy\n\njulia> @syms α, x, f(), g()\n(α, x, f, g)\n\njulia> ∂ = Differential(x)\nDifferential(x)\n\njulia> eqn = ∂(f(x)) ~ α * x\nd\n──(f(x)) = x⋅α\ndx\n\njulia> dsolve(eqn)\n             2\n            x ⋅α\nf(x) = C₁ + ────\n             2\n\njulia> dsolve(eqn(α=>2); ics=Dict(f(0)=>1)) |> print # fill in parameter, initial condition\nEq(f(x), x^2 + 1)\n\njulia> eqn = ∂(∂(f(x))) ~ -f(x); print(eqn)\nEq(Derivative(f(x), (x, 2)), -f(x))\n\njulia> dsolve(eqn)\nf(x) = C₁⋅sin(x) + C₂⋅cos(x)\n\njulia> dsolve(eqn; ics = Dict(f(0)=>1, ∂(f)(0) => -1))\nf(x) = -sin(x) + cos(x)\n\njulia> eqn = ∂(∂(f(x))) - f(x) - exp(x);\n\njulia> dsolve(eqn, ics=Dict(f(0) => 1, f(1) => Sym(1//2))) |> print # not just 1//2\nEq(f(x), (x/2 + (-exp(2) - 2 + E)/(-2 + 2*exp(2)))*exp(x) + (-E + 3*exp(2))*exp(-x)/(-2 + 2*exp(2)))\n\nSystems. Use a tuple, not a vector, of equations, as such are now deprecated by SymPy.\n\njulia> @syms x() y() t g\n(x, y, t, g)\n\njulia> ∂ = Differential(t)\nDifferential(t)\n\njulia> eqns = (∂(x(t)) ~ y(t), ∂(y(t)) ~ x(t))\n(Eq(Derivative(x(t), t), y(t)), Eq(Derivative(y(t), t), x(t)))\n\njulia> dsolve(eqns)\n2-element Vector{Sym}:\n Eq(x(t), -C1*exp(-t) + C2*exp(t))\n  Eq(y(t), C1*exp(-t) + C2*exp(t))\n\njulia> dsolve(eqns, ics = Dict(x(0) => 1, y(0) => 2))\n2-element Vector{Sym}:\n Eq(x(t), 3*exp(t)/2 - exp(-t)/2)\n Eq(y(t), 3*exp(t)/2 + exp(-t)/2)\n\njulia> eqns = (∂(∂(x(t))) ~ 0, ∂(∂(y(t))) ~ -g)\n(Eq(Derivative(x(t), (t, 2)), 0), Eq(Derivative(y(t), (t, 2)), -g))\n\njulia> dsolve(eqns)  # can't solve for initial conditions though! (NotAlgebraic)\n2-element Vector{Sym}:\n           x(t) = C₁ + C₂⋅t\n Eq(y(t), C3 + C4*t - g*t^2/2)\n\njulia> @syms t x() y()\n(t, x, y)\n\njulia> eq = (∂(x)(t) ~ x(t)*y(t)*sin(t), ∂(y)(t) ~ y(t)^2 * sin(t))\n(Eq(Derivative(x(t), t), x(t)*y(t)*sin(t)), Eq(Derivative(y(t), t), y(t)^2*sin(t)))\n\njulia> dsolve(eq)  # returns a set to be `collect`ed:\nPyObject {Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}\n\njulia> dsolve(eq) |> collect\n2-element Vector{Any}:\n Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t)))\n               Eq(y(t), -1/(C1 - cos(t)))\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.elements-Tuple{Sym}","page":"Reference/API","title":"SymPy.elements","text":"elements(s)\n\nreturn elements of a set s as an array, unlike convert(Set,s)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.free_symbols-Union{Tuple{Union{Vector{T}, T}}, Tuple{T}} where T<:SymPy.SymbolicObject","page":"Reference/API","title":"SymPy.free_symbols","text":"free_symbols(ex)\nfree_symbols(ex::Vector{Sym})\n\nReturn vector of free symbols of expression or vector of expressions. The results are orderded by sortperm(string.(fs)).\n\nExample:\n\njulia> using SymPy\n\njulia> @syms x y z a\n(x, y, z, a)\n\njulia> free_symbols(2*x + a*y) # [a, x, y]\n3-element Vector{Sym}:\n a\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.import_from-Union{Tuple{Any}, Tuple{N}, Tuple{Any, Any}} where N","page":"Reference/API","title":"SymPy.import_from","text":"import_from(module, meths; kwargs...)\n\nImport methods from a python module. Implements functionality  of from module import function in  Python.\n\nmodule: a python module, such as sympy\nmeths: nothing or a tuple of symbols to import. If nothing, then all member functions of the module are imported (but not constructors or other objects)\nMs: additional Julia Modules to import from. By default, a few base modules are searched for to avoid namespace collisions.\ntyp: a symbol indicating variable type for first argument that the new function should be restricted to. For most, the default, :SymbolicObject will be appropriate\nexclude: when importing all (meths=nothing), this can be used to avoid importing some methods by name. The default has a few to avoid.\n\nExamples:\n\nimport_from(sympy)  # bring in functions from sympy (done `import_sympy`)\nimport_from(sympy, (:sin, :cos))  # just bring in a few methods\nimport_from(sympy , (:Wild,), typ=:Any) # Allows `Wild(\"x\")`\n#\nimport PyCall\nPyCall.pyimport_conda(\"sympy.physics.wigner\", \"sympy\")\nimport_from(sympy.physics.wigner)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.import_sympy-Tuple{}","page":"Reference/API","title":"SymPy.import_sympy","text":"import_sympy\n\nThis method imports all functions from mpmath and a priviledged set of functions from sympy, as well as the relational operators.\n\nThese functions are narrowed on their first argument being of type SymbolicObject.\n\nA few modules are checked for namespace collisions.\n\nIf a function naturally takes an non-Symbolic argument as a first argument, then it can be qualified: e.g. sympy.sin(2) (as opposed to sin(Sym(2))).\n\nIf a constructor is needed (which is not a function) then it must be qualified. (E.g. sympy.Function(\"F\"), though for this particular case, there is SymFunction defined for convenience.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.jprint-Tuple{SymPy.SymbolicObject}","page":"Reference/API","title":"SymPy.jprint","text":"create basic printed output\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.lambdify","page":"Reference/API","title":"SymPy.lambdify","text":"lambdify(ex, vars=free_symbols();\n         fns=Dict(), values=Dict, use_julia_code=false,\n         invoke_latest=true)\n\nTake a symbolic expression and return a Julia function or expression to build a function.\n\nex::Sym a symbolic expression with 0, 1, or more free symbols\nvars a container of symbols to use for the function arguments. The default is free_symbols which has a specific ordering. Specifying vars allows this default ordering of arguments to be customized. If vars is empty, such as when the symbolic expression has no free symbols, a variable arg constant function is returned.\nfns::Dict, vals::Dict: Dictionaries that allow customization of the function that walks the expression ex and creates the corresponding AST for a Julia expression. See SymPy.fn_map and SymPy.val_map for the default mappings of sympy functions and values into Julia's AST.\nuse_julia_code::Bool: use SymPy's conversion to an expression, the default is false\ninvoke_latest=true: if true will call eval and Base.invokelatest to return a function that should not have any world age issue. If false will return a Julia expression that can be evaled to produce a function.\n\nExample:\n\njulia> using SymPy\n\njulia> @syms x y z\n(x, y, z)\n\njulia> ex = x^2 * sin(x)\n 2\nx ⋅sin(x)\n\njulia> fn = lambdify(ex);\n\njulia> fn(pi)\n0.0\n\njulia> ex = x + 2y + 3z\nx + 2⋅y + 3⋅z\n\njulia> fn = lambdify(ex);\n\njulia> fn(1,2,3) # order is by free_symbols\n14\n\njulia> ex(x=>1, y=>2, z=>3)\n14\n\njulia> fn = lambdify(ex, (y,x,z));\n\njulia> fn(1,2,3)\n13\n\n!!! Note:\n\nThe default produces slower functions due to the calls to eval and Base.invokelatest.  In the following g2 (which, as seen, requires additional work to compute) is as fast as calling f (on non symbolic types), whereas g1 is an order of magnitude slower in this example.\n\njulia> @vars x\n(x,)\n\njulia> f(x) = exp(cot(x))\nf (generic function with 1 method)\n\njulia> g1 = lambdify(f(x))\n#88 (generic function with 1 method)\n\njulia> ex = lambdify(f(x), invoke_latest=false)\n:(function var\"##271\"(x)\n      exp(cot(x))\n  end)\n\njulia> @eval g2(x) = ($ex)(x)\ng2 (generic function with 1 method)\n\nAn alternative, say, is to use GeneralizedGenerated's mk_function, as follows:\n\njulia> using GeneralizedGenerated\n\njulia> body = convert(Expr, f(x))\n:(exp(cot(x)))\n\njulia> g3 = mk_function((:x,), (), body)\nfunction = (x;) -> begin\n    (Main).exp((Main).cot(x))\nend\n\nThis function will be about 2-3 times slower than f.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymPy.nonlinsolve-Tuple{}","page":"Reference/API","title":"SymPy.nonlinsolve","text":"nonlinsolve\n\nNote: if passing variables in use a tuple (e.g., (x,y)) and not a vector (e.g., [x,y]).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.refine-Tuple{Any, Vararg{Any}}","page":"Reference/API","title":"SymPy.refine","text":" refine\n\nSimplify an expression using assumptions; refine.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.simplify-Tuple{Any, Vararg{Any}}","page":"Reference/API","title":"SymPy.simplify","text":"simplify\n\nSymPy has dozens of functions to perform various kinds of simplification. There is also one general function called simplify that attempts to apply all of these functions in an intelligent way to arrive at the simplest form of an expression. (See Simplification for details on simplify and other related functionality).\n\nFor non-symbolic expressions, simplify returns its first argument.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.subs-Union{Tuple{T}, Tuple{T, Tuple{Any, Any}}} where T<:SymPy.SymbolicObject","page":"Reference/API","title":"SymPy.subs","text":"subs is used to subsitute a value in an expression with another value. Examples:\n\njulia> using SymPy\n\njulia> x,y = symbols(\"x,y\")\n(x, y)\n\njulia> ex = (x-y)*(x+2y)\n(x - y)⋅(x + 2⋅y)\n\njulia> subs(ex, (y, y^2))\n⎛     2⎞ ⎛       2⎞\n⎝x - y ⎠⋅⎝x + 2⋅y ⎠\n\njulia> subs(ex, (x,1), (y,2))\n-5\n\njulia> subs(ex, (x,y^3), (y,2))\n72\n\njulia> subs(ex, y, 3)\n(x - 3)⋅(x + 6)\n\nThere is a curried form of subs to use with the chaining |> operator\n\njulia> ex |> subs(x,ℯ)\n(ℯ - y)⋅(2⋅y + ℯ)\n\nThe use of pairs gives a convenient alternative:\n\njulia> subs(ex, x=>1, y=>2)\n-5\n\njulia> ex |> subs(x=>1, y=>2)\n-5\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.symbols-Tuple{AbstractString}","page":"Reference/API","title":"SymPy.symbols","text":"symbols(name(s), assumptions...)\n\nCalls sympy.symbols to produce symbolic variables and symbolic functions. An alternate to the recommended @syms, (when applicable)\n\nIn sympy sympy.symbols and sympy.Symbol both allow the construction of symbolic variables and functions. The Julia function symbols is an alias for sympy.symbols.\n\nVariables are created through x=symbols(\"x\");\nAssumptions on variables by x=symbols(\"x\", real=true);\nMultiple symbols x1,x2 = symbols(\"x[1:3]\") can be created. Unlike @syms, the number of variables can be specified with a variable through interpolation.\nSymbolic functions can be created py passing cls=sympy.Function, symbols(\"F\", cls=sympy.Function, real=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.walk_expression-Tuple{Any}","page":"Reference/API","title":"SymPy.walk_expression","text":"walk_expression(ex; values=Dict(), fns=Dict())\n\nConvert a symbolic SymPy expression into a Julia expression. This is needed to use functions in external packages in lambdified functions.\n\nExample\n\nusing SymPy\n@syms x y\nex = sympy.hyper((2,2),(3,3),x) * y\n\nCalling lambdify(ex) will fail to make a valid function, as hyper is implemented in HypergeometricFunctions.pFq. So, we have:\n\nusing HypergeometricFunctions\nd = Dict(\"hyper\" => :pFq)\nbody = SymPy.walk_expression(ex, fns=d)\nsyms = Symbol.(free_symbols(ex))\nfn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));\nfn(1,1) # 1.6015187080185656\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.False","page":"Reference/API","title":"SymPy.False","text":"False from SymPy\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.IM","page":"Reference/API","title":"SymPy.IM","text":"IM is a symbolic im\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.PI","page":"Reference/API","title":"SymPy.PI","text":"PI is symbolic pi\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.True","page":"Reference/API","title":"SymPy.True","text":"True from SymPy\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.oo","page":"Reference/API","title":"SymPy.oo","text":"oo is a symbolic infinity. Example: integrate(exp(-x), x, 0, oo).\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.sympy","page":"Reference/API","title":"SymPy.sympy","text":"sympy\n\nVariable from pyimport(\"sympy\"). Numerous methods are available through Python's dot-call syntax.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.sympy_core","page":"Reference/API","title":"SymPy.sympy_core","text":"sympy_core\n\nVariable from pyimport(\"sympy.core\").\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.sympy_matrices","page":"Reference/API","title":"SymPy.sympy_matrices","text":"sympy_matrices\n\nVariable from pyimport(\"sympy.matrices\").\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.sympy_plotting","page":"Reference/API","title":"SymPy.sympy_plotting","text":"Plotting of symbolic objects.\n\nThe Plots package provide a uniform interface to many of Julia's plotting packages. SymPy plugs into Plots' \"recipes.\"\n\nThe basic goal is that when Plots provides an interface for function objects, this package extends the interface to symbolic expressions.\n\nIn particular:\n\nplot(ex::Sym, a, b; kwargs...) will plot a function evaluating ex over [a,b]\n\nExample. Here we use the default backend for Plots to make a plot:\n\nusing Plots\n@syms x\nplot(x^2 - 2x, 0, 4)\n\nplot(ex1, ex2, a, b; kwargs...) will plot the two expressions in a parametric plot over the interval [a,b].\n\nExample:\n\n@syms x\nplot(sin(2x), cos(3x), 0, 4pi) ## also\n\nFor a few backends (those that support :path3d) a third symbolic expression may be added to have a 3d parametric plot rendered:\n\nplot(sin(x), cos(x), x, 0, 4pi) # helix in 3d\n\nplot(xs, ys, expression) will make a contour plot (for many backends).\n\n@syms x y\nplot(range(0,stop=5, length=50), range(0,stop=5, length=50), x*y)\n\nTo plot the surface  z=ex(x,y) over a region we have Plots.surface. For example,\n\n@syms x y\nsurface(-5:5, -5:5, 25 - x^2 - y^2)\n\na vectorfield plot can (inefficiently but directly) be produced following this example:\n\nfunction vfieldplot(fx, fy; xlim=(-5,5), ylim=(-5,5), n=8)\n    xs = range(xlim[1], stop=xlim[2], length=n)\n    ys = range(ylim[1], stop=ylim[2], length=n)\n\n    us = vec([x for x in xs, y in ys])\n    vs = vec([y for x in xs, y in ys])\n    fxs = vec([fx(x,y) for x in xs, y in ys])\n    fys = vec([fy(x,y) for x in xs, y in ys])\n\n    mxs = maximum(abs.(filter(!isinf, filter(!isnan, fxs))))\n    mys = maximum(abs.(filter(!isinf, filter(!isnan, fys))))\n    d = 1/2 * max((xlim[2]-xlim[1])/mxs, (ylim[2]-ylim[1])/mys) / n\n\n    quiver(us, vs, quiver=(fxs.*d, fys.*d))\n\nend\nfx = (x + y) / sqrt(x^2 + y^2)\nfy = (x - y) / sqrt(x^2 + y^2)\nvfieldplot(fx, fy)\n\n\n\nTo plot two or more functions at once, the style plot([ex1, ex2], a, b) does not work. Rather, use   plot(ex1, a, b); plot!(ex2), as in:\n\n@syms x\nplot(sin(x), 0, 2pi)\nplot!(cos(x))\n\n\n\nSome graphics provided by SymPy are available if PyPlot is installed, such as:\n\nsympy.plotting.plot3d_parametric_surface\nsympy.plotting.plot_implicit\n\nPlot the parametrically defined surface [exs[1](u,v), exs[2](u,v), exs[3](u,v)] over [a0,a1] x [b0,b1]. The specification of the variables uses a tuple of the form (Sym, Real, Real) following the style of SymPy in integrate, say, where disambiguation of variable names is needed.\n\n@syms theta, phi\nr = 1\nsympy.plotting.plot3d_parametric_surface((r*sin(theta)*sin(phi), r*sin(theta)*cos(phi), r*cos(theta)),\n                        (theta, 0, pi), (phi, 0, pi/2))\n\nsympy.plotting.plot_implicit(equation, (xvar, x0, x1), (yvar, y0, y1)) will plot implicitly the equation.\n\n@syms x y\nsympy.plotting.plot_implicit(Eq(x^2+ y^2,3), (x, -2, 2), (y, -2, 2))  # draw a circle\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.zoo","page":"Reference/API","title":"SymPy.zoo","text":"zoo complex inifinity\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPy.@symfuns-Tuple","page":"Reference/API","title":"SymPy.@symfuns","text":"@symfuns\n\nThanks to @alhirzel for the contribution.\n\n!!! Note:     The @symfuns macro is deprecated. The more general @syms macro should be used for constructing symbolic functions of type SymFunction and symbols can be used to construct symbolic functions in general.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SymPy.@syms-Tuple","page":"Reference/API","title":"SymPy.@syms","text":"@syms a n::integer x::(real,positive)=>\"x₀\" y[-1:1] u() v()::real w()::(real,positive) y()[1:3]::real\n\nConstruct symbolic variables or functions along with specified assumptions. Similar to @vars, sympy.symbols, and sympy.Function, but the specification of the assumptions is more immediate than those interfaces which follow sympy's constructors.\n\nAllows the specification of assumptions on the variables and functions.\n\na type-like annontation, such as n::integer is equivalent to sympy.symbols(\"n\", integer=true). Multiple assumptions are combined using parentheses (e.g., n::(integer,nonnegative).\n\nThe possible values for assumptions are: \"commutative\", \"complex\", \"imaginary\", \"real\", \"integer\", \"odd\", \"even\", \"prime\", \"composite\", \"zero\", \"nonzero\", \"rational\", \"algebraic\", \"transcendental\", \"irrational\", \"finite\", \"infinite\", \"negative\", \"nonnegative\", \"positive\", \"nonpositive\", \"hermitian\", \"antihermetian\".\n\na tensor declaration form is provided to define arrays of variables, e.g. x[-1:1] or y[1:4, 2:5].\na symbolic function can be specified using a pair of parentheses after the name, as in u().\nThe return type of a function can have assumptions specified, as with a variable. E.g., h()::complex. How the symbolic function prints can be set as with a variable, e.g. h()::complex=>\"h̄\".\nmultiple definitions can be separated by commas\nHow the symbol prints (the __str__() value) can be specified using the syntax =>\"name\", as in x=>\"xₒ\"\n\nExamples:\n\njulia> using SymPy\n\njulia> @syms a b::nonnegative\n(a, b)\n\njulia> sqrt(a^2), sqrt(b^2)\n(sqrt(a^2), b)\n\njulia> @syms x::prime\n(x,)\n\njulia> ask(𝑄.negative(x)), ask(𝑄.integer(x)), ask(𝑄.even(x))  # (false, true, nothing)\n(false, true, nothing)\n\njulia> @syms a[0:5], x\n(Sym[a₀, a₁, a₂, a₃, a₄, a₅], x)\n\njulia> sum( aᵢ*x^(i) for (i,aᵢ) ∈ zip(0:5, a)) |> print\na₀ + a₁*x + a₂*x^2 + a₃*x^3 + a₄*x^4 + a₅*x^5\n\njulia> @syms x u() v()::nonnegative\n(x, u, v)\n\njulia> sqrt(u(x)^2), sqrt(v(x)^2) # sqrt(u(x)^2), Abs(v(x))\n(sqrt(u(x)^2), Abs(v(x)))\n\n!!! Note:     Many thanks to @matthieubulte for this contribution.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SymPy.@vars-Tuple","page":"Reference/API","title":"SymPy.@vars","text":"@vars x y z\n\nDefine symbolic values, possibly with names and assumptions\n\nExamples:\n\n@vars x y\n@vars a1=>\"α₁\"\n@vars a b real=true\n\n!!! Note:     The @vars macro is deprecated and will be removed. Use @syms.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SymPy.Differential","page":"Reference/API","title":"SymPy.Differential","text":"Differential(x)\n\nUse to find (partial) derivatives.\n\nExample\n\n@syms x y u()\nDx = Differential(x)\nDx(u(x,y))  # resolves to diff(u(x,y),x)\nDx(u)       # will evaluate diff(u(x), x)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPy.Doc","page":"Reference/API","title":"SymPy.Doc","text":"SymPy.Doc(f::Symbol, [module=sympy])\n\nReturn docstring of f found within the specified module.\n\nExamples\n\nSymPy.Doc(:sin)\nSymPy.Doc(:det, sympy.matrices)\n## add module to query\nSymPy.pyimport_conda(\"sympy.crypto.crypto\", \"sympy\")\nSymPy.Doc(:padded_key, sympy.crypto)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPy.SymFunction","page":"Reference/API","title":"SymPy.SymFunction","text":"SymFunction\n\nA type and constructor to create symbolic functions. Such objects can be used for specifying differential equations. The macro @syms is also available for constructing SymFunctions (@syms f())\n\nExamples:\n\njulia> using SymPy\n\njulia> u = SymFunction(\"u\");\n\njulia> @syms v();\n\n\nAlternatively, we can pass a comma separated string of variable names to create more than one at a time.\n\njulia> F,G,H = SymFunction(\"F, G, H\")\n3-element Vector{SymFunction}:\n F\n G\n H\n\nFor symbolic functions not wrapped in the SymFunction type, the sympy.Function constructor can be used, as can the symbols function to construct symbolic functions (F=sympy.Function(\"F\", real=true); F = sympy.symbols(\"F\", cls=sympy.Function, real=true)).\n\njulia> @syms u(), v()::real, t\n(u, v, t)\n\njulia> sqrt(u(t)^2), sqrt(v(t)^2) # real values have different simplification rules\n(sqrt(u(t)^2), Abs(v(t)))\n\n\nSuch functions are undefined functions in SymPy, and can be used symbolically, such as with taking derivatives:\n\njulia> @syms x y u()\n(x, y, u)\n\njulia> diff(u(x), x) |> string\n\"Derivative(u(x), x)\"\n\njulia> diff(u(x, y), x) |> string\n\"Derivative(u(x, y), x)\"\n\nHere is one way to find the second derivative of an inverse function to f, utilizing the SymFunction class and the convenience Differential function:\n\n@syms f() f⁻¹() x\nD = Differential(x) # ∂(f) is diff(f(x),x)\nD² = D∘D\nu1 = solve(diff((f⁻¹∘f)(x), x) ~ 1, D(f⁻¹)(f(x)))[1]\nu2 = solve(diff((f⁻¹∘f)(x), x,2) ~ 0, D²(f⁻¹)(f(x)))[1]\nu2(D(f⁻¹)(f(x)) => u1) # f''/[f']^3\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPy.SymMatrix","page":"Reference/API","title":"SymPy.SymMatrix","text":"SymMatrix\n\nType to store a SymPy matrix, as created by sympy.ImmutableMatrix.\n\nThese have 0-based indexing defined for them to match SymPy\n\nThe traditional infix mathmatical operations are defined, but no dot broadcasting.\n\nThe convert(Matrix{Sym}, M) call is useful to covert to a Julia matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPy.VectorField","page":"Reference/API","title":"SymPy.VectorField","text":"VectorField(fx, fy): create an object that can be plotted as a vector field.\n\nA vectorfield plot draws arrows at grid points proportional to [fx(x_i,y_i), fy(x_i,y_i)] to visualize the field generated by [fx, fy].\n\nThe plot command: plot(VectorField(fx, fy), xlims=(-5,5), ylims=(-5,5), n=8) will draw the vectorfield. This uses the default values, so the same graph would be rendered by plot(VectorField(fx,fy)).\n\nTo faciliate the visualization of solution to the ODE y' = F(x, y(x)), the call plot(VectorField(F)) will work. (The order is x then y, though often this is written as F(y(x),x).)\n\nSymPy objects can be passed to VectorField, but this is a bit fragile, as they must each have two variables so that they can be called with two variables.  (E.g., y(1,2) will be 1 not 2, as might be intended.)\n\nExamples:\n\nusing Plots\n\nfx(x,y) = sin(y); fy(x,y) = cos(y)\nplot(VectorField(fx, fy), xlims=(-2pi, 2pi), ylims=(-2pi,2pi))\n\n# plot field of y' = 3y*x over (-5,5) x (-5,5)\nF(x,y) = 3*y*x\nplot(VectorField(F))\n\n# plot field and solution u' = u*(1-u)\n@syms x u()\nF(x,y) = y*(1-y)\nout = dsolve(u'(x) - F(x, u(x)), x, (u, 0, 1))\nplot(VectorField(F), xlims=(0,5), ylims=(0,2))\nplot!(rhs(out))\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPy.SymPy","page":"Reference/API","title":"SymPy.SymPy","text":"SymPy package to interface with Python's SymPy library through PyCall.\n\nThe basic idea is that a new type – Sym – is made to hold symbolic objects.  For this type, the basic functions from SymPy and appropriate functions of Julia are overloaded for Sym objects so that the expressions are treated symbolically and not evaluated immediately. Instances of this type are created by the constructor Sym, the function symbols or the macro @vars.\n\nOn loading, a priviledged set of the functions from the sympy module are defined as generic functions with their first argument narrowed to symbolic types. Others may be accessed by qualification, as in sympy.trigsimp. Calling import_from(sympy) will import the rest. SymPy methods are called through Python's dot-call syntax.  To find documentation on SymPy functions and methods, one should refer to SymPy's website.\n\nPlotting is provided through  Plots recipes. For details, see the help page for sympy_plotting.\n\nThe package documentation provides many examples.\n\nAccess to SymPy's help system for most functions is available through SymPy.Doc.\n\n\n\n\n\n","category":"module"},{"location":"reference/#SymPy.𝑄","page":"Reference/API","title":"SymPy.𝑄","text":"𝑄\nSymPy.Q\n\nTheSymPy.𝑄 module adds features of the sympy.Q module. Also accesible through SymPy.Q.\n\nSymPy allows for assumptions on variables. These may be placed on free sympols at construction.\n\nFor example, the following creates a real value variable x and a postive, real variable y:\n\njulia> using SymPy\n\njulia> @vars x real=true\n(x,)\n\njulia> @vars y real=true positive=true\n(y,)\n\nThe 𝑄 module exposes a means to query the assumptions on a variable. For example,\n\njulia> ask(𝑄.positive(y))  # true\ntrue\n\njulia> ask(𝑄.negative(y))  # false\nfalse\n\njulia> ask(SymPy.Q.positive(x))  # `nothing`\n\njulia> ask(SymPy.Q.positive(x^2)) # `nothing` -- might be 0\n\njulia> ask(SymPy.Q.positive(1 + x^2)) # true  -- must be postive now.\ntrue\n\nThe ask function uses tri-state logic, returning one of 3 values: true; false; or nothing, when the query is indeterminate.\n\nThe construction of predicates is done through Q methods. These can be combined logically. For example, this will be true:\n\njulia> ask(𝑄.positive(y) & 𝑄.negative(-x^2 - 1))\n\n\nThe above use & as an infix operation for the binary operator And. Values can also be combined with Or, Not, Xor, Nand, Nor, Implies, Equivalent, and satisfiable.\n\nnote: typing `𝑄`\n𝑄 is entered as  [slash]itQ[tab]) or SymPy.Q.query(value) but  not as sympy.Q.query(value)\n\nnote: Matrix predicates\nAs SymPy.jl converts symbolic matrices into Julia's Array\n\ntype and not as matrices within Python, the predicate functions from SymPy for matrices are not used, though a replacement is given.\n\n\n\n\n\n","category":"module"},{"location":"reference/#SymPy.Introspection.args-Tuple{Sym}","page":"Reference/API","title":"SymPy.Introspection.args","text":"args(x)\n\nReturn arguments of x, as a tuple. (Empty if no :args property.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.Introspection.func-Tuple{Sym}","page":"Reference/API","title":"SymPy.Introspection.func","text":"func(x)\n\nReturn function head from an expression\n\nInvariant:\n\nEvery well-formed SymPy expression ex must either have length(args(ex)) == 0 or func(ex)(args(ex)...) = ex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPy.Introspection.funcname-Tuple{Sym}","page":"Reference/API","title":"SymPy.Introspection.funcname","text":"funcname(x)\n\nReturn name or \"\"\n\n\n\n\n\n","category":"method"},{"location":"Tutorial/matrices/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"From","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> from sympy import *\n    >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"using SymPy\nsympy.init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/matrices/#In-Julia:","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"In SymPy, matrices can be store using Julia's generic Matrix{T} type where T <: Sym or using SymPy's matrix type, wrapped in a SymMatrix type by SymPy. This tutorial shows how to use the underlying SymMatrix values. To construct a matrix of symbolic values is identical to construction a matrix of numeric values within Julia, and will be illustrated at the end.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"methods for SymMatrix objects use the dot call syntax. As a convenience, this will also work for Array{Sym} objects. The returned value may be a SymMatrix, not an Array{Sym}.\nThe matrix constructor in SymPy using a vector of row vectors does not work in SymPy, as of newer versions (it does not work with version 1.5.1 of sympy and PyCall). This style is used in this document. The user of SymPy can eaesily avoid this specification, using Julia's matrix construction techniques.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> using SymPy\n\njulia> using LinearAlgebra\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To make a matrix in SymPy, use the Matrix object.  A matrix is constructed by providing a list of row vectors that make up the matrix.  For example, to construct the matrix","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"\n   leftbeginarraycc1  -13  40  2endarrayright\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"use","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> Matrix([[1, -1], [3, 4], [0, 2]])\n    ⎡1  -1⎤\n    ⎢     ⎥\n    ⎢3  4 ⎥\n    ⎢     ⎥\n    ⎣0  2 ⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-2","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"In Julia, the Matrix constructor is not exported, so must be qualified. Here we avoid the vector of row vectors above:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> sympy.Matrix([1 -1; 3 4; 0 2])\n3×2 Matrix{Sym}:\n 1  -1\n 3   4\n 0   2\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"However, through the magic of PyCall, such matrices are converted into Julia matrices, of type Array{Sym}, so the familiar matrix operations for Julia users are available.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"In fact, the above could be done in the more Julian manner through","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> Sym[1 -1; 3 4; 0 2]\n3×2 Matrix{Sym}:\n 1  -1\n 3   4\n 0   2\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"using an annotation to ensure the type. Alternatively, through promotion, just a single symbolic object will result in the same:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> [Sym(1) -1; 3 4; 0 2]\n3×2 Matrix{Sym}:\n 1  -1\n 3   4\n 0   2\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To make it easy to make column vectors, a list of elements is considered to be a column vector.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> Matrix([1, 2, 3])\n    ⎡1⎤\n    ⎢ ⎥\n    ⎢2⎥\n    ⎢ ⎥\n    ⎣3⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-3","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"For this use, sympy.Matrix does work, but again its usage is discouraged:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> sympy.Matrix([1, 2, 3])\n3×1 Matrix{Sym}:\n 1\n 2\n 3\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Again, this is converted into a Vector{Sym} object or entered directly:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> Sym[1,2,3]\n3-element Vector{Sym}:\n 1\n 2\n 3\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Avoid `sympy.Matrix`\nAs shown, it is better to  avoid  the   sympy.Matrix constructor when possible, and when not, only pass in a  symbolic  array created through Julia's array semantics.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Matrices are manipulated just like any other object in SymPy or Python.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 2, 3], [3, 2, 1]])\n    >>> N = Matrix([0, 1, 1])\n    >>> M*N\n    ⎡5⎤\n    ⎢ ⎥\n    ⎣3⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-4","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"In Julia, matrices are just matrices, and inherit all of the operations defined on them:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 2 3; 3 2 1]\n2×3 Matrix{Sym}:\n 1  2  3\n 3  2  1\n\njulia> N = Sym[0, 1, 1]\n3-element Vector{Sym}:\n 0\n 1\n 1\n\njulia> M*N\n2-element Vector{Sym}:\n 5\n 3\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"One important thing to note about SymPy matrices is that, unlike every other object in SymPy, they are mutable.  This means that they can be modified in place, as we will see below.  The downside to this is that Matrix cannot be used in places that require immutability, such as inside other SymPy expressions or as keys to dictionaries.  If you need an immutable version of Matrix, use ImmutableMatrix.","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-5","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"A distinction is made between ImmutableMatrix and a mutable one. Mutable ones are mapped to Julia arrays, immutable ones are left as a symbolic object of type SymMatrix. The usual infix mathematical operations (but not dot broadcasting), 0-based indexing, and dot call syntax for methods maay  be used with these objects.","category":"page"},{"location":"Tutorial/matrices/#Basic-Operations","page":"Matrices","title":"Basic Operations","text":"","category":"section"},{"location":"Tutorial/matrices/#Shape","page":"Matrices","title":"Shape","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Here are some basic operations on Matrix.  To get the shape of a matrix use shape","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 2, 3], [-2, 0, 4]])\n    >>> M\n    ⎡1   2  3⎤\n    ⎢        ⎥\n    ⎣-2  0  4⎦\n    >>> M.shape\n    (2, 3)","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-6","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 2 3; -2 0 4]\n2×3 Matrix{Sym}:\n  1  2  3\n -2  0  4\n\njulia> M.shape\n(2, 3)\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Or, the Julian counterpart:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> size(M)\n(2, 3)\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Accessing-Rows-and-Columns","page":"Matrices","title":"Accessing Rows and Columns","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To get an individual row or column of a matrix, use row or col.  For example, M.row(0) will get the first row. M.col(-1) will get the last column.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M.row(0)\n    [1  2  3]\n    >>> M.col(-1)\n    ⎡3⎤\n    ⎢ ⎥\n    ⎣4⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-7","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"these 0-based operations are supported:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M.row(0)\n1×3 Matrix{Sym}:\n 1  2  3\n\njulia> M.col(-1)\n2×1 Matrix{Sym}:\n 3\n 4\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"The more familiar counterparts would be:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M[1,:], M[:, end]\n(Sym[1, 2, 3], Sym[3, 4])\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Deleting-and-Inserting-Rows-and-Columns","page":"Matrices","title":"Deleting and Inserting Rows and Columns","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To delete a row or column, use row_del or col_del.  These operations will modify the Matrix in place.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M.col_del(0)\n    >>> M\n    ⎡2  3⎤\n    ⎢    ⎥\n    ⎣0  4⎦\n    >>> M.row_del(1)\n    >>> M\n    [2  3]","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-8","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"These methods do not work on Array{Sym} objects, use Julia's indexing notation to remove a row or column.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"However, these methods do work on the ImmutableMatrix class:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = sympy.ImmutableMatrix([1 2 3; -2 0 4])  # avoid vector of row vector construction\n⎡1   2  3⎤\n⎢        ⎥\n⎣-2  0  4⎦\n\njulia> M.col_del(0)\n⎡2  3⎤\n⎢    ⎥\n⎣0  4⎦\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M.row_del(1)\n[1  2  3]\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Alert\nFor older versions of sympy, the following did not work (using symbolic  values as matrix entries without reverting to  their PyObjects  had shape issues);  this should work  now:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> @syms x\n(x,)\n\njulia> sympy.ImmutableMatrix([x 1;  1  x])\n⎡x  1⎤\n⎢    ⎥\n⎣1  x⎦\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: TODO\nThis is a mess. See issue 6992.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To insert rows or columns, use row_insert or col_insert.  These operations do not operate in place.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M\n    [2  3]\n    >>> M = M.row_insert(1, Matrix([[0, 4]]))\n    >>> M\n    ⎡2  3⎤\n    ⎢    ⎥\n    ⎣0  4⎦\n    >>> M = M.col_insert(0, Matrix([1, -2]))\n    >>> M\n    ⎡1   2  3⎤\n    ⎢        ⎥\n    ⎣-2  0  4⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-9","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = sympy.ImmutableMatrix([2 3])\n[2  3]\n\njulia> M = M.row_insert(1, Sym[0 4])\n⎡2  3⎤\n⎢    ⎥\n⎣0  4⎦\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = M.col_insert(0, Sym[1, -2])\n⎡1   2  3⎤\n⎢        ⎥\n⎣-2  0  4⎦\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Unless explicitly stated, the methods mentioned below do not operate in place. In general, a method that does not operate in place will return a new Matrix and a method that does operate in place will return None.","category":"page"},{"location":"Tutorial/matrices/#In-Julia","page":"Matrices","title":"In Julia","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"This would be the case for the immutable matrices.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Basic-Methods","page":"Matrices","title":"Basic Methods","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"As noted above, simple operations like addition and multiplication are done just by using +, *, and **.  To find the inverse of a matrix, just raise it to the -1 power.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 3], [-2, 3]])\n    >>> N = Matrix([[0, 3], [0, 7]])\n    >>> M + N\n    ⎡1   6 ⎤\n    ⎢      ⎥\n    ⎣-2  10⎦\n    >>> M*N\n    ⎡0  24⎤\n    ⎢     ⎥\n    ⎣0  15⎦\n    >>> 3*M\n    ⎡3   9⎤\n    ⎢     ⎥\n    ⎣-6  9⎦\n    >>> M**2\n    ⎡-5  12⎤\n    ⎢      ⎥\n    ⎣-8  3 ⎦\n    >>> M**-1\n    ⎡1/3  -1/3⎤\n    ⎢         ⎥\n    ⎣2/9  1/9 ⎦\n    >>> N**-1\n    Traceback (most recent call last):\n    ...\n    ValueError: Matrix det == 0; not invertible.","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-10","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"In Julia,  we  use M1 instead  of N, an exported symbol of SymPy. Otherise, it  all looks similar:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 3; -2 3]\n2×2 Matrix{Sym}:\n  1  3\n -2  3\n\njulia> M1 = Sym[0 3; 0 7]\n2×2 Matrix{Sym}:\n 0  3\n 0  7\n\njulia> M + M1\n2×2 Matrix{Sym}:\n  1   6\n -2  10\n\njulia> M*M1\n2×2 Matrix{Sym}:\n 0  24\n 0  15\n\njulia> 3*M\n2×2 Matrix{Sym}:\n  3  9\n -6  9\n\njulia> M^2\n2×2 Matrix{Sym}:\n -5  12\n -8   3\n\njulia> M^-1\n2×2 Matrix{Sym}:\n 1/3  -1/3\n 2/9   1/9","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Attempting to find the inverse of  M1 will  error (we suppress its lengthy output)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> using Test\n\njulia> @test_throws  Exception M1^-1\nTest Passed\n      Thrown: PyCall.PyError\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"The above (except for the inverses) are using generic Julia definitions. For immutable matrices, we would have:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = sympy.ImmutableMatrix([1 3; -2 3])\n⎡1   3⎤\n⎢     ⎥\n⎣-2  3⎦\n\njulia> M1 = sympy.ImmutableMatrix([0 3; 0 7])\n⎡0  3⎤\n⎢    ⎥\n⎣0  7⎦\n\njulia> M + M1\n⎡1   6 ⎤\n⎢      ⎥\n⎣-2  10⎦\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M*M1\n⎡0  24⎤\n⎢     ⎥\n⎣0  15⎦\n\njulia> 3*M\n⎡3   9⎤\n⎢     ⎥\n⎣-6  9⎦\n\njulia> M^2\n         2\n2\n\njulia> M^-1\n⎡1/3  -1/3⎤\n⎢         ⎥\n⎣2/9  1/9 ⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Similarly, M1^(-1) would yield an  error  for  the non-invertible matrix","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"There is no broadcasting defined for the SymMatrix type.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To take the transpose of a Matrix, use T.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 2, 3], [4, 5, 6]])\n    >>> M\n    ⎡1  2  3⎤\n    ⎢       ⎥\n    ⎣4  5  6⎦\n    >>> M.T\n    ⎡1  4⎤\n    ⎢    ⎥\n    ⎢2  5⎥\n    ⎢    ⎥\n    ⎣3  6⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-11","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 2 3; 4 5 6]\n2×3 Matrix{Sym}:\n 1  2  3\n 4  5  6\n\njulia> M.T\n3×2 Matrix{Sym}:\n 1  4\n 2  5\n 3  6\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Matrix-Constructors","page":"Matrices","title":"Matrix Constructors","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Several constructors exist for creating common matrices.  To create an identity matrix, use eye.  The command eye(n) will create an n x n identity matrix:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> eye(3)\n    ⎡1  0  0⎤\n    ⎢       ⎥\n    ⎢0  1  0⎥\n    ⎢       ⎥\n    ⎣0  0  1⎦\n    >>> eye(4)\n    ⎡1  0  0  0⎤\n    ⎢          ⎥\n    ⎢0  1  0  0⎥\n    ⎢          ⎥\n    ⎢0  0  1  0⎥\n    ⎢          ⎥\n    ⎣0  0  0  1⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-12","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"eye is not exported so must qualified:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> sympy.eye(3)\n3×3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> sympy.eye(4)\n4×4 Matrix{Sym}:\n 1  0  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To create a matrix of all zeros, use zeros.  zeros(n, m) creates an n x m matrix of 0s.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> zeros(2, 3)\n    ⎡0  0  0⎤\n    ⎢       ⎥\n    ⎣0  0  0⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-13","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"zeros is extended but the method expects a symbolic first argument.  Either qualify it:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> sympy.zeros(2, 3)\n2×3 Matrix{Sym}:\n 0  0  0\n 0  0  0\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"or create a symbolic first value:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> zeros(Sym(2), 3)\n2×3 Matrix{Sym}:\n 0  0  0\n 0  0  0\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"or use the Julia constructor:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> zeros(Sym, 2, 3)\n2×3 Matrix{Sym}:\n 0  0  0\n 0  0  0\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Similarly, ones creates a matrix of ones.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> ones(3, 2)\n    ⎡1  1⎤\n    ⎢    ⎥\n    ⎢1  1⎥\n    ⎢    ⎥\n    ⎣1  1⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-14","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Similarly with ones:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> sympy.ones(3, 2)\n3×2 Matrix{Sym}:\n 1  1\n 1  1\n 1  1\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To create diagonal matrices, use diag.  The arguments to diag can be either numbers or matrices.  A number is interpreted as a 1 x 1 matrix. The matrices are stacked diagonally.  The remaining elements are filled with 0\\ s.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> diag(1, 2, 3)\n    ⎡1  0  0⎤\n    ⎢       ⎥\n    ⎢0  2  0⎥\n    ⎢       ⎥\n    ⎣0  0  3⎦\n    >>> diag(-1, ones(2, 2), Matrix([5, 7, 5]))\n    ⎡-1  0  0  0⎤\n    ⎢           ⎥\n    ⎢0   1  1  0⎥\n    ⎢           ⎥\n    ⎢0   1  1  0⎥\n    ⎢           ⎥\n    ⎢0   0  0  5⎥\n    ⎢           ⎥\n    ⎢0   0  0  7⎥\n    ⎢           ⎥\n    ⎣0   0  0  5⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-15","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"similarly with diag:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> sympy.diag(1, 2, 3)\n3×3 Matrix{Sym}:\n 1  0  0\n 0  2  0\n 0  0  3\n\njulia> sympy.diag(-1, sympy.ones(2, 2), sympy.Matrix([5, 7, 5]))\n6×4 Matrix{Sym}:\n -1  0  0  0\n  0  1  1  0\n  0  1  1  0\n  0  0  0  5\n  0  0  0  7\n  0  0  0  5\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"The first one, could also use Julia's diagm function from the LinearAlgebra package:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> diagm(0 => Sym[1,2,3])\n3×3 Matrix{Sym}:\n 1  0  0\n 0  2  0\n 0  0  3\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Advanced-Methods","page":"Matrices","title":"Advanced Methods","text":"","category":"section"},{"location":"Tutorial/matrices/#Determinant","page":"Matrices","title":"Determinant","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To compute the determinant of a matrix, use det.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 0, 1], [2, -1, 3], [4, 3, 2]])\n    >>> M\n    ⎡1  0   1⎤\n    ⎢        ⎥\n    ⎢2  -1  3⎥\n    ⎢        ⎥\n    ⎣4  3   2⎦\n    >>> M.det()\n    -1","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-16","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 0 1; 2 -1 3; 4 3 2]\n3×3 Matrix{Sym}:\n 1   0  1\n 2  -1  3\n 4   3  2\n\njulia> M.det()\n-1\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Let","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> @syms x\n(x,)\n\njulia> A = Sym[x 1; 1 x]\n2×2 Matrix{Sym}:\n x  1\n 1  x\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"The method for det falls back  the  sympy method:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> det(A)\n 2\nx  - 1\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"There is no reason  to,  but generic Julia methods  could be used:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> out  = lu(A)\nLU{Sym, Matrix{Sym}, Vector{Int64}}\nL factor:\n2×2 Matrix{Sym}:\n   1  0\n 1/x  1\nU factor:\n2×2 Matrix{Sym}:\n x        1\n 0  x - 1/x\n\njulia> prod(diag(out.L)) * prod(diag(out.U))\n  ⎛    1⎞\nx⋅⎜x - ─⎟\n  ⎝    x⎠","category":"page"},{"location":"Tutorial/matrices/#RREF","page":"Matrices","title":"RREF","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To put a matrix into reduced row echelon form, use rref.  rref returns a tuple of two elements. The first is the reduced row echelon form, and the second is a tuple of indices of the pivot columns.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 0, 1, 3], [2, 3, 4, 7], [-1, -3, -3, -4]])\n    >>> M\n    ⎡1   0   1   3 ⎤\n    ⎢              ⎥\n    ⎢2   3   4   7 ⎥\n    ⎢              ⎥\n    ⎣-1  -3  -3  -4⎦\n    >>> M.rref()\n    ⎛⎡1  0   1    3 ⎤        ⎞\n    ⎜⎢              ⎥        ⎟\n    ⎜⎢0  1  2/3  1/3⎥, (0, 1)⎟\n    ⎜⎢              ⎥        ⎟\n    ⎝⎣0  0   0    0 ⎦        ⎠","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-17","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 0 1 3; 2 3 4 7; -1 -3 -3 -4]\n3×4 Matrix{Sym}:\n  1   0   1   3\n  2   3   4   7\n -1  -3  -3  -4\n\njulia> M.rref()\n(Sym[1 0 1 3; 0 1 2/3 1/3; 0 0 0 0], (0, 1))","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Note\nThe first element of the tuple returned by rref is of type Matrix. The second is of type tuple.","category":"page"},{"location":"Tutorial/matrices/#Nullspace","page":"Matrices","title":"Nullspace","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the nullspace of a matrix, use nullspace. nullspace returns a list of column vectors that span the nullspace of the matrix.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 2, 3, 0, 0], [4, 10, 0, 0, 1]])\n    >>> M\n    ⎡1  2   3  0  0⎤\n    ⎢              ⎥\n    ⎣4  10  0  0  1⎦\n    >>> M.nullspace()\n    ⎡⎡-15⎤  ⎡0⎤  ⎡ 1  ⎤⎤\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎢⎢ 6 ⎥  ⎢0⎥  ⎢-1/2⎥⎥\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎢⎢ 1 ⎥, ⎢0⎥, ⎢ 0  ⎥⎥\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎢⎢ 0 ⎥  ⎢1⎥  ⎢ 0  ⎥⎥\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎣⎣ 0 ⎦  ⎣0⎦  ⎣ 1  ⎦⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-18","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"the list is mapped to an array of vectors, otherwise this is identical:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 2 3 0 0; 4 10 0 0 1]\n2×5 Matrix{Sym}:\n 1   2  3  0  0\n 4  10  0  0  1\n\njulia> M.nullspace()\n3-element Vector{Matrix{Sym}}:\n [-15; 6; … ; 0; 0;;]\n [0; 0; … ; 1; 0;;]\n [1; -1/2; … ; 0; 1;;]\n","category":"page"},{"location":"Tutorial/matrices/#Columnspace","page":"Matrices","title":"Columnspace","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the columnspace of a matrix, use columnspace. columnspace returns a list of column vectors that span the columnspace of the matrix.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 1, 2], [2 ,1 , 3], [3 , 1, 4]])\n    >>> M\n    ⎡1  1  2⎤\n    ⎢       ⎥\n    ⎢2  1  3⎥\n    ⎢       ⎥\n    ⎣3  1  4⎦\n    >>> M.columnspace()\n    ⎡⎡1⎤  ⎡1⎤⎤\n    ⎢⎢ ⎥  ⎢ ⎥⎥\n    ⎢⎢2⎥, ⎢1⎥⎥\n    ⎢⎢ ⎥  ⎢ ⎥⎥\n    ⎣⎣3⎦  ⎣1⎦⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-19","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"as with nullspace, the return value is a vector of vectors:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[1 1 2; 2 1 3; 3 1 4]\n3×3 Matrix{Sym}:\n 1  1  2\n 2  1  3\n 3  1  4\n\njulia> M.columnspace()\n2-element Vector{Matrix{Sym}}:\n [1; 2; 3;;]\n [1; 1; 1;;]\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Eigenvalues,-Eigenvectors,-and-Diagonalization","page":"Matrices","title":"Eigenvalues, Eigenvectors, and Diagonalization","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the eigenvalues of a matrix, use eigenvals.  eigenvals returns a dictionary of eigenvalue:algebraic multiplicity pairs (similar to the output of :ref:roots <tutorial-roots>).","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[3, -2,  4, -2], [5,  3, -3, -2], [5, -2,  2, -2], [5, -2, -3,  3]])\n    >>> M\n    ⎡3  -2  4   -2⎤\n    ⎢             ⎥\n    ⎢5  3   -3  -2⎥\n    ⎢             ⎥\n    ⎢5  -2  2   -2⎥\n    ⎢             ⎥\n    ⎣5  -2  -3  3 ⎦\n    >>> M.eigenvals()\n    {-2: 1, 3: 1, 5: 2}","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-20","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M = Sym[3 -2  4 -2; 5  3 -3 -2; 5 -2  2 -2; 5 -2 -3  3]\n4×4 Matrix{Sym}:\n 3  -2   4  -2\n 5   3  -3  -2\n 5  -2   2  -2\n 5  -2  -3   3\n\njulia> M.eigenvals()\nDict{Any, Any} with 3 entries:\n  3  => 1\n  5  => 2\n  -2 => 1\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"This means that M has eigenvalues -2, 3, and 5, and that the eigenvalues -2 and 3 have algebraic multiplicity 1 and that the eigenvalue 5 has algebraic multiplicity 2.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the eigenvectors of a matrix, use eigenvects.  eigenvects returns a list of tuples of the form (eigenvalue:algebraic multiplicity, [eigenvectors]).","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M.eigenvects()\n    ⎡⎛       ⎡⎡0⎤⎤⎞  ⎛      ⎡⎡1⎤⎤⎞  ⎛      ⎡⎡1⎤  ⎡0 ⎤⎤⎞⎤\n    ⎢⎜       ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥  ⎢  ⎥⎥⎟⎥\n    ⎢⎜       ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥  ⎢-1⎥⎥⎟⎥\n    ⎢⎜-2, 1, ⎢⎢ ⎥⎥⎟, ⎜3, 1, ⎢⎢ ⎥⎥⎟, ⎜5, 2, ⎢⎢ ⎥, ⎢  ⎥⎥⎟⎥\n    ⎢⎜       ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥  ⎢0 ⎥⎥⎟⎥\n    ⎢⎜       ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥  ⎢  ⎥⎥⎟⎥\n    ⎣⎝       ⎣⎣1⎦⎦⎠  ⎝      ⎣⎣1⎦⎦⎠  ⎝      ⎣⎣0⎦  ⎣1 ⎦⎦⎠⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-21","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"the output is less than desirable, as there is no special show method\nthe eigvals and eigvecs methods present the output in the manner that Julia's generic functions do:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> M.eigenvects()\n3-element Vector{Tuple{Sym, Int64, Vector{Matrix{Sym}}}}:\n (-2, 1, [[0; 1; 1; 1;;]])\n (3, 1, [[1; 1; 1; 1;;]])\n (5, 2, [[1; 1; 1; 0;;], [0; -1; 0; 1;;]])\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"compare with","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> eigvecs(M)\n4×4 Matrix{Sym}:\n 0  1  1   0\n 1  1  1  -1\n 1  1  1   0\n 1  1  0   1\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"This shows us that, for example, the eigenvalue 5 also has geometric multiplicity 2, because it has two eigenvectors.  Because the algebraic and geometric multiplicities are the same for all the eigenvalues, M is diagonalizable.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To diagonalize a matrix, use diagonalize. diagonalize returns a tuple (P, D), where D is diagonal and M = PDP^{-1}.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> P, D = M.diagonalize()\n    >>> P\n    ⎡0  1  1  0 ⎤\n    ⎢           ⎥\n    ⎢1  1  1  -1⎥\n    ⎢           ⎥\n    ⎢1  1  1  0 ⎥\n    ⎢           ⎥\n    ⎣1  1  0  1 ⎦\n    >>> D\n    ⎡-2  0  0  0⎤\n    ⎢           ⎥\n    ⎢0   3  0  0⎥\n    ⎢           ⎥\n    ⎢0   0  5  0⎥\n    ⎢           ⎥\n    ⎣0   0  0  5⎦\n    >>> P*D*P**-1\n    ⎡3  -2  4   -2⎤\n    ⎢             ⎥\n    ⎢5  3   -3  -2⎥\n    ⎢             ⎥\n    ⎢5  -2  2   -2⎥\n    ⎢             ⎥\n    ⎣5  -2  -3  3 ⎦\n    >>> P*D*P**-1 == M\n    True","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-22","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> P, D = M.diagonalize()\n(Sym[0 1 1 0; 1 1 1 -1; 1 1 1 0; 1 1 0 1], Sym[-2 0 0 0; 0 3 0 0; 0 0 5 0; 0 0 0 5])\n\njulia> P\n4×4 Matrix{Sym}:\n 0  1  1   0\n 1  1  1  -1\n 1  1  1   0\n 1  1  0   1\n\njulia> D\n4×4 Matrix{Sym}:\n -2  0  0  0\n  0  3  0  0\n  0  0  5  0\n  0  0  0  5\n\njulia> P*D*P^-1\n4×4 Matrix{Sym}:\n 3  -2   4  -2\n 5   3  -3  -2\n 5  -2   2  -2\n 5  -2  -3   3\n\njulia> P*D*P^-1 == M\ntrue\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Quick Tip\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"As  lambda is a reserved keyword in Python, so to create a Symbol called  λ, while using the same names for SymPy Symbols and Python variables, use lamda (without the b).  It will still pretty print as λ.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Note that since eigenvects also includes the eigenvalues, you should use it instead of eigenvals if you also want the eigenvectors. However, as computing the eigenvectors may often be costly, eigenvals should be preferred if you only wish to find the eigenvalues.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"If all you want is the characteristic polynomial, use charpoly.  This is more efficient than eigenvals, because sometimes symbolic roots can be expensive to calculate.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> lamda = symbols('lamda')\n    >>> p = M.charpoly(lamda)\n    >>> factor(p)\n           2\n    (λ - 5) ⋅(λ - 3)⋅(λ + 2)","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-23","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note missing b is not needed with Julia:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> @syms lambda\n(lambda,)\n\njulia> p = M.charpoly(lambda)\nPurePoly(lambda**4 - 11*lambda**3 + 29*lambda**2 + 35*lambda - 150, lambda, domain='ZZ')\n\njulia> factor(p) |>  string\n\"PurePoly(lambda^4 - 11*lambda^3 + 29*lambda^2 + 35*lambda - 150, lambda, domain='ZZ')\"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"As an aside, we can get prettier output by adjusting how lambda should print, as follows:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> @syms lambda=>\"λ\"\n(λ,)\n\njulia> p = M.charpoly(lambda)\nPurePoly(λ**4 - 11*λ**3 + 29*λ**2 + 35*λ - 150, λ, domain='ZZ')","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: TODO\nAdd an example for jordan_form, once it is fully implemented.","category":"page"},{"location":"Tutorial/matrices/#Possible-Issues","page":"Matrices","title":"Possible Issues","text":"","category":"section"},{"location":"Tutorial/matrices/#Zero-Testing","page":"Matrices","title":"Zero Testing","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"If your matrix operations are failing or returning wrong answers, the common reasons would likely be from zero testing. If there is an expression not properly zero-tested, it can possibly bring issues in finding pivots for gaussian elimination, or deciding whether the matrix is inversible, or any high level functions which relies on the prior procedures.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Currently, the SymPy's default method of zero testing _iszero is only guaranteed to be accurate in some limited domain of numerics and symbols, and any complicated expressions beyond its decidability are treated as None, which behaves similarly to logical False.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"The list of methods using zero testing procedures are as followings.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"echelon_form , is_echelon , rank , rref , nullspace , eigenvects , inverse_ADJ , inverse_GE , inverse_LU , LUdecomposition , LUdecomposition_Simple , LUsolve","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"They have property iszerofunc opened up for user to specify zero testing method, which can accept any function with single input and boolean output, while being defaulted with _iszero.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Here is an example of solving an issue caused by undertested zero. [#zerotestexampleidea-fn]_ [#zerotestexamplediscovery-fn]_","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> from sympy import *\n    >>> q = Symbol(\"q\", positive = True)\n    >>> m = Matrix([\n    ... [-2*cosh(q/3),      exp(-q),            1],\n    ... [      exp(q), -2*cosh(q/3),            1],\n    ... [           1,            1, -2*cosh(q/3)]])\n    >>> m.nullspace()\n    []","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-24","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"julia> q = sympy.Symbol(\"q\", positive = true)\nq\n\njulia> m = Sym[-2*cosh(q/3) exp(-q) 1; exp(q) -2*cosh(q/3) 1; 1 1 -2*cosh(q/3)]\n3×3 Matrix{Sym}:\n -2*cosh(q/3)       exp(-q)             1\n       exp(q)  -2*cosh(q/3)             1\n            1             1  -2*cosh(q/3)\n\njulia> m.nullspace()\n1-element Vector{Matrix{Sym}}:\n [-(-2*exp(q)*cosh(q/3) - 4*cosh(q/3)^2 - 1 - 2*exp(-q)*cosh(q/3))/(4*exp(q)*cosh(q/3)^2 + 4*cosh(q/3) + exp(-q)); -(1 - 4*cosh(q/3)^2)/(2*cosh(q/3) + exp(-q)); 1;;]\n","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"You can trace down which expression is being underevaluated, by injecting a custom zero test with warnings enabled.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> import warnings\n    >>>\n    >>> def my_iszero(x):\n    ...     try:\n    ...         result = x.is_zero\n    ...     except AttributeError:\n    ...         result = None\n    ...\n    ...     # Warnings if evaluated into None\n    ...     if result == None:\n    ...         warnings.warn(\"Zero testing of {} evaluated into {}\".format(x, result))\n    ...     return result\n    ...\n    >>> m.nullspace(iszerofunc=my_iszero) # doctest: +SKIP\n    __main__:9: UserWarning: Zero testing of 4*cosh(q/3)**2 - 1 evaluated into None\n    __main__:9: UserWarning: Zero testing of (-exp(q) - 2*cosh(q/3))*(-2*cosh(q/3) - exp(-q)) - (4*cosh(q/3)**2 - 1)**2 evaluated into None\n    __main__:9: UserWarning: Zero testing of 2*exp(q)*cosh(q/3) - 16*cosh(q/3)**4 + 12*cosh(q/3)**2 + 2*exp(-q)*cosh(q/3) evaluated into None\n    __main__:9: UserWarning: Zero testing of -(4*cosh(q/3)**2 - 1)*exp(-q) - 2*cosh(q/3) - exp(-q) evaluated into None\n    []","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-25","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Is this available??","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"In this case, (-exp(q) - 2*cosh(q/3))*(-2*cosh(q/3) - exp(-q)) - (4*cosh(q/3)**2 - 1)**2 should yield zero, but the zero testing had failed to catch. possibly meaning that a stronger zero test should be introduced. For this specific example, rewriting to exponentials and applying simplify would make zero test stronger for hyperbolics, while being harmless to other polynomials or transcendental functions.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> def my_iszero(x):\n    ...     try:\n    ...         result = x.rewrite(exp).simplify().is_zero\n    ...     except AttributeError:\n    ...         result = None\n    ...\n    ...     # Warnings if evaluated into None\n    ...     if result == None:\n    ...         warnings.warn(\"Zero testing of {} evaluated into {}\".format(x, result))\n    ...     return result\n    ...\n    >>> m.nullspace(iszerofunc=my_iszero) # doctest: +SKIP\n    __main__:9: UserWarning: Zero testing of -2*cosh(q/3) - exp(-q) evaluated into None\n    ⎡⎡  ⎛   q         ⎛q⎞⎞  -q         2⎛q⎞    ⎤⎤\n    ⎢⎢- ⎜- ℯ  - 2⋅cosh⎜─⎟⎟⋅ℯ   + 4⋅cosh ⎜─⎟ - 1⎥⎥\n    ⎢⎢  ⎝             ⎝3⎠⎠              ⎝3⎠    ⎥⎥\n    ⎢⎢─────────────────────────────────────────⎥⎥\n    ⎢⎢          ⎛      2⎛q⎞    ⎞     ⎛q⎞       ⎥⎥\n    ⎢⎢        2⋅⎜4⋅cosh ⎜─⎟ - 1⎟⋅cosh⎜─⎟       ⎥⎥\n    ⎢⎢          ⎝       ⎝3⎠    ⎠     ⎝3⎠       ⎥⎥\n    ⎢⎢                                         ⎥⎥\n    ⎢⎢           ⎛   q         ⎛q⎞⎞            ⎥⎥\n    ⎢⎢          -⎜- ℯ  - 2⋅cosh⎜─⎟⎟            ⎥⎥\n    ⎢⎢           ⎝             ⎝3⎠⎠            ⎥⎥\n    ⎢⎢          ────────────────────           ⎥⎥\n    ⎢⎢                   2⎛q⎞                  ⎥⎥\n    ⎢⎢             4⋅cosh ⎜─⎟ - 1              ⎥⎥\n    ⎢⎢                    ⎝3⎠                  ⎥⎥\n    ⎢⎢                                         ⎥⎥\n    ⎣⎣                    1                    ⎦⎦","category":"page"},{"location":"Tutorial/matrices/#In-Julia:-26","page":"Matrices","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Is this available?","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"You can clearly see nullspace returning proper result, after injecting an alternative zero test.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Note that this approach is only valid for some limited cases of matrices containing only numerics, hyperbolics, and exponentials. For other matrices, you should use different method opted for their domains.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Possible suggestions would be either taking advantage of rewriting and simplifying, with tradeoff of speed [#zerotestsimplifysolution-fn]_ , or using random numeric testing, with tradeoff of accuracy [#zerotestnumerictestsolution-fn]_ .","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"If you wonder why there is no generic algorithm for zero testing that can work with any symbolic entities, it's because of the constant problem stating that zero testing is undecidable [#constantproblemwikilink-fn]_ , and not only the SymPy, but also other computer algebra systems [#mathematicazero-fn]_ [#matlabzero-fn]_ would face the same fundamental issue.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"However, discovery of any zero test failings can provide some good examples to improve SymPy, so if you have encountered one, you can report the issue to SymPy issue tracker [#sympyissues-fn]_ to get detailed help from the community.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Footnotes\n[#zerotestexampleidea-fn] Inspired by https://gitter.im/sympy/sympy?at=5b7c3e8ee5b40332abdb206c\n[#zerotestexamplediscovery-fn] Discovered from https://github.com/sympy/sympy/issues/15141\n[#zerotestsimplifysolution-fn] Suggested from https://github.com/sympy/sympy/issues/10120\n[#zerotestnumerictestsolution-fn] Suggested from https://github.com/sympy/sympy/issues/10279\n[#constantproblemwikilink-fn] https://en.wikipedia.org/wiki/Constant_problem\n[#mathematicazero-fn] How mathematica tests zero https://reference.wolfram.com/language/ref/PossibleZeroQ.html\n[#matlabzero-fn] How matlab tests zero https://www.mathworks.com/help/symbolic/mupad_ref/iszero.html\n[#sympyissues-fn] https://github.com/sympy/sympy/issues","category":"page"},{"location":"introduction/#A-SymPy-introduction","page":"Examples","title":"A SymPy introduction","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This document provides an introduction to using SymPy within Julia. It owes an enormous debt to SymPy documentation and the tutorial for using SymPy within Python which may be found here.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Here we first load the package into Julia:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"using SymPy\nsympy.init_printing(use_latex=true)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> using SymPy\n","category":"page"},{"location":"introduction/#Symbols","page":"Examples","title":"Symbols","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"At the core of SymPy is the introduction of symbolic variables that differ quite a bit from Julia's variables. Symbolic variables do not immediately evaluate to a value, rather the \"symbolicness\" propagates when interacted with. To keep the resulting expressions manageable, SymPy does some simplifications along the way.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The @syms macro makes creating one or more symbolic variables very easy:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x\n(x,)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms a b c\n(a, b, c)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This macro creates variables in the local scope, no assignment is needed.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This example shows that symbols may be Unicode:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms α, β, γ\n(α, β, γ)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Additionally you can specify how the variables are displayed using pair notation:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms a1=>\"α₁\" a2=>\"α₂\"\n(α₁, α₂)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The user can type a1, say, but, as seen, the variable prints as α₁.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"There are other means, described in the following, to create symbolic variables, but the @syms macro is the suggested one to use.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The sympy.symbols constructor is exported as symbols, as it is a common means for creating symbolic variables in other documentation. Here the variables are passed as a string with names separated by space or commas, allowing the creation of one or more variables:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> a = symbols(\"a\")\na\n\njulia> a, b, c = symbols(\"a b c\")\n(a, b, c)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The documentation for the Python function is available from within Julia using the SymPy.@doc macro, as in SymPy.@doc sympy.symbols.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In Julia, the symbolic expressions are primarily instances of the Sym type, which holds an instance to an underlying PyObject. This type can be used as a constructor in the standard way:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> x = Sym(\"x\")\nx\n\njulia> a,b,c = Sym(\"a, b, c\")\n(a, b, c)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The sympify function is used by SymPy to convert arbitrary expressions to a type useful within SymPy. It too can be used to create variables (and more):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"sympify(\"x\")  # sympy.sympify is exported","category":"page"},{"location":"introduction/#Ranges-of-symbolic-variables","page":"Examples","title":"Ranges of symbolic variables","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Here are two ways to make sequenced variables:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms xs[1:5]\n(Sym[xs₁, xs₂, xs₃, xs₄, xs₅],)\n\njulia> ys = [Sym(\"y$i\") for i in 1:5]\n5-element Vector{Sym}:\n y₁\n y₂\n y₃\n y₄\n y₅","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The former much more succinct, but the latter pattern of use when the number of terms is a variable.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The symbols constructor also has non-Julian range patterns available:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> symbols(\"x:3\")\n(x0, x1, x2)\n\njulia> symbols(\"x:2:2\")\n(x00, x01, x10, x11)","category":"page"},{"location":"introduction/#Assumptions","page":"Examples","title":"Assumptions","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy has \"core assumptions\" that can be asserted for a variable. These include being real, positive, etc. A list of possible assumptions is here.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The @syms macro allows annotations, akin to type annotations, to specify assumptions on new variables:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms u1::positive u2::(real, nonzero)\n(u1, u2)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Skipping ahead, there are some functions from the assumptions module of SymPy to query these properties:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ask(𝑄.positive(u1)), ask(𝑄.positive(u2)), ask(𝑄.positive(u2^2)), ask(𝑄.real(u2))\n(true, nothing, nothing, true)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Despite it easy to see that a non-zero real variable (u2) when squared will be positive, this is not identified in the assumptions.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The symbols constructor uses keyword arguments to pass in assumptions. It is illustrated below as they apply to all the variables that are created, which can be more convenient at times.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> u = symbols(\"u\")\nu\n\njulia> x = symbols(\"x\", real=true)\nx\n\njulia> y1, y2 = symbols(\"y1, y2\", positive=true)\n(y1, y2)\n\njulia> alpha = symbols(\"alpha\", integer=true, positive=true)\nα\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We jump ahead for a second to illustrate, but here we see that solve will respect these assumptions, by failing to find solutions to these equations:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x::real\n(x,)\n\njulia> solve(x^2 + 1)   # ±i are not real\nAny[]\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x::positive\n(x,)\n\njulia> solve(x + 1)    # -1 is not positive\nAny[]\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"warning: Warning\nSymPy can easily create two variables with the same stringified name but different assumptions and will treat these as distinct.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x::real=>\"x\" y=>\"x\"\n(x, x)\n\njulia> x, y\n(x, x)\n\njulia> string(x) == string(y)\ntrue\n\njulia> x == y\nfalse\n\njulia> hash(x) == hash(y)\nfalse\n","category":"page"},{"location":"introduction/#Special-constants","page":"Examples","title":"Special constants","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Julia has its math constants, like pi and e, SymPy as well. A few of these have Julia counterparts provided by SymPy. For example, these two constants are defined (where oo is for infinity):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> PI, oo\n(pi, oo)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(The pretty printing of SymPy objects does not work for tuples.)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"These are aliases to sympy.pi and sympy.oo. There are a few others.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Numeric values themselves can be symbolic. This example shows the difference. The first asin call dispatches to Julia's asin function, the second to SymPy's:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> [asin(1), asin(Sym(1))]\n2-element Vector{Sym}:\n 1.57079632679490\n             pi/2\n","category":"page"},{"location":"introduction/#Basics-of-SymPy","page":"Examples","title":"Basics of SymPy","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"As seen, SymPy has symbolic variables and numbers can be symbolic. These are used to build symbolic expressions. In SymPy most all of these have the Sym type, a subtype of the SymbolicObject type. The Sym type is immutable; assignment is necessary to modify a variable.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In the Python library, there are two basic method types for interacting with expressions: ones that are defined in the sympy module and called using fn(args...) style, and ones that are methods of the object and called using Python's dot call notation obj.fn(args...; kwargs...).","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The SymPy package essentially merges the Python style and Julia's style as follows:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Promotion rules are established to promote Julia number types to symbolic values so that expressions like pi * x will first promote pi and x to two symbolic values (with pi being converted to the exact sympy.pi) and then the SymPy multiplication operator is called on the two symbolic values. The result is wrapped in the Sym type.\nFor generic methods in Julia, such as sin, a new method specialized on the first argument being symbolic  is defined to call the underlying sympy function. (Essentially, the method sin(x::Sym) = sympy.sin(x) is added.)\nFor a selection of sympy methods, an exported function is defined. (For example a method like simplify(x::Sym) = sympy.simplify(x) is defined and exported.)\nFor object methods and properties in Python, the dot-call notation is used to call these methods. There is a selection of methods for which a Julian style is also added. For example, ex.subs(...) and subs(ex, ...) are both calling styles for the subs method of the expression ex.\nWhen a SymPy function is called, PyCall converts the arguments to a Python object, which works as desired in most all cases.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Expressions in SymPy are simplified to some extent but are not immediately evaluated if there are symbols involved. Expressions are stored in a tree-like manner that can be explored using some basic functions. Here we look at x*sin(x^2):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x\n(x,)\n\njulia> ex = x * sin(x^2); println(ex)\nx*sin(x^2)\n\njulia> SymPy.Introspection.func(ex)\nPyObject <class 'sympy.core.mul.Mul'>\n\njulia> a,b = SymPy.Introspection.args(ex)\n(x, sin(x^2))\n\njulia> a.is_Atom\ntrue\n\njulia> SymPy.Introspection.func(b)\nPyObject sin\n\njulia> b.is_Atom\nfalse\n\njulia> SymPy.Introspection.args(b)\n(x^2,)\n\njulia> SymPy.Introspection.func(x^2)\nPyObject <class 'sympy.core.power.Pow'>","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The point is not to discuss the introspection functions, but rather to show the tree-like structure:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"x*sin(x^2)\n   / \\\n  x  sin\n      |\n     Pow\n\t / \\\n\tx   2","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy uses the term Atom to describe the leaves of this tree. An atom is an expression with no subexpressions.","category":"page"},{"location":"introduction/#Substitution","page":"Examples","title":"Substitution","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy provides several  means to substitute values in for the symbolic expressions:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"subs: substitution of subexpressions as defined by the objects themselves\nreplace: replace matching subexpressions of self with value\nxreplace: exact node replacement in expr tree; also capable of using matching rules","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We discuss subs here which uses \"old/new\" pairs to indicate the substitution.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The method subs is a method of an object, but for this widely used task, a Julian method subs is also defined. Consider the simplest case:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex = x * sin(x^2); println(ex)\nx*sin(x^2)\n\njulia> subs(ex, x^2, x)\nx⋅sin(x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Above, the old/new pair is separated by a comma. Pairs notation is suggested instead:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> subs(ex, x => x^2) |> println\nx^2*sin(x^4)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Julia's call notation is used for substitution, so we can more directly write:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex = x^2 + x^4; println(ex)\nx^4 + x^2\n\njulia> ex(x^2 => x^5) |> println\nx^10 + x^5\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Of some note, above x^4 is treated like (x^2)^2 and so an x^10 term is returned after the substitution. The subs method simplifies arguments; xreplace method only replaces exact expressions in syntax tree:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex.xreplace(Dict(x^2 => x^5)) |> println\nx^5 + x^4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For example, this is one way to make a polynomial in a new variable:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x y\n(x, y)\n\njulia> ex = x^2 + 2x + 1\n 2\nx  + 2⋅x + 1\n\njulia> ex(x => y)\n 2\ny  + 2⋅y + 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Substitution can also be numeric:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex(x => 0)\n1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output has no free variables, but is still a symbolic quantity.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Expressions with more than one variables can have multiple substitutions (performed from left to right):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x,y,z\n(x, y, z)\n\njulia> ex = x + y + z\nx + y + z\n\njulia> ex(x => 1, y=> PI)\nz + 1 + π\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"A straight call (e.g. ex(1, PI))  is also possble, where the order of the variables is determined by free_symbols. While useful for expressions of a single variable, being explicit through the use of paired values is recommended.","category":"page"},{"location":"introduction/#Simplification","page":"Examples","title":"Simplification","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The simplify function in SymPy \"simplifies\" a given expression. As mentioned in the SymPy documentation, simplification is not a well-defined term and strategies employed may differ between versions. The simplify function depends on over a dozen other functions, such as powsimp, trigsimp, radsimp, logcombine, and together. The simplify function is exported by the SymPy package, the others called through the sympy module.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To illustrate, we have:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x y;\n\njulia> q = x*y + x*y^2 + x^2*y + x;\n\njulia> simplify(q)\n  ⎛       2        ⎞\nx⋅⎝x⋅y + y  + y + 1⎠\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The above uses factoring. Other simplifications are possible. For example, powers:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms m::integer n::integer\n(m, n)\n\njulia> x^m / x^n\n m  -n\nx ⋅x\n\njulia> simplify(x^m / x^n)\n m - n\nx\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Simplification rules can also be made by hand using Wild to create wild cards. This shows a simple trigonometric substitution:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> x_ = Wild(\"x\")\nx\n\njulia> ex = sin(2x)\nsin(2⋅x)\n\njulia> replace(ex, sin(2x_) => 2sin(x_)*cos(x_))\n2⋅sin(x)⋅cos(x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nWith version 1.9 of Julia an extension for the TermInterface package is provided which allows Metatheory rules to be applied to symbolic expressions.","category":"page"},{"location":"introduction/#Trigsimp","page":"Examples","title":"Trigsimp","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For trigonometric expressions, simplify will use trigsimp to simplify:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms theta::real\n(theta,)\n\njulia> p = cos(theta)^2 + sin(theta)^2\n   2         2\nsin (θ) + cos (θ)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Calling either simplify or trigsimp will apply the Pythagorean identity:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> simplify(p)\n1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"While often forgotten,  the trigsimp function is, of course,  aware of the double angle formulas:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> simplify(sin(2theta) - 2sin(theta)*cos(theta))\n0\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Unlike the example above, trigsimp replaces the product with the double angle:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> sympy.trigsimp(2* sin(theta) * cos(theta))\nsin(2⋅θ)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The expand_trig function will expand such expressions:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> sympy.expand_trig(sin(2theta))\n2⋅sin(θ)⋅cos(θ)\n","category":"page"},{"location":"introduction/#Conversion-from-symbolic-to-numeric","page":"Examples","title":"Conversion from symbolic to numeric","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy provides two identical means to convert a symbolic math expression to a number. One is the evalf method, the other the N function. Within Julia we decouple these, using N to also convert to a Julian value and; evalf leaving the conversion as a symbolic object.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The N function converts symbolic integers, rationals, irrationals, and complex values, while attempting to find an appropriate Julia type for the value.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To see the difference, we use both on PI:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> N(PI)  # converts to underlying pi Irrational\nπ = 3.1415926535897...\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Whereas, evalf will produce a symbolic numeric value:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> PI.evalf()\n3.14159265358979\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The evalf call allows for a precision argument to be passed through the second argument. This is how 30 digits of pi can be extracted:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> PI.evalf(30)\n3.14159265358979323846264338328\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output of an evalf call is is a symbolic number, not a Julia object. Composing with N we can see the difference:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> N(PI.evalf(30))\n3.141592653589793238462643383279999999999999999999999999999999999999999999999985\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Explicit conversion via the convert(T, ex) pattern can also be used to convert a symbolic number to a Julian one. This is necessary at times when N does not give the desired type.","category":"page"},{"location":"introduction/#Algebraic-expressions","page":"Examples","title":"Algebraic expressions","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"As mentioned, SymPy overloads many of Julia's functions to work with symbolic objects, such as seen above with sin and asin. The usual mathematical operations such as +, *, -, / etc. work through Julia's promotion mechanism, where numbers are promoted to symbolic objects, others dispatch internally to related SymPy functions.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In most all  cases, thinking about this distinction between numbers and symbolic numbers is unnecessary, as numeric values passed to SymPy functions are typically promoted to symbolic expressions. This conversion will take math constants to their corresponding SymPy counterpart, rational expressions to rational expressions, and floating point values to floating point values. However there are edge cases. An expression like 1//2 * pi * x will differ from the seemingly identical  1//2 * (pi * x). The former will produce a floating point value from 1//2 * pi before being promoted to a symbolic instance. Using the symbolic value PI makes this expression work either way.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nThe sympy.nsimplify function can be used to convert floating point values to rational values, but it is suggested to convert rational value in Julia to symbolic values, rather than rely on later conversions.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Most of Julia's mathematical functions are overloaded to work with symbolic expressions. Julia's generic definitions are used, as possible. This also introduces some edge cases. For example, x^(-2) will work, but k=-2; x^l will balk due to the non-literal, negative, integer exponent. However, either k = -2//1 or k = Sym(-2) will work as expected with x^k, as the former call first dispatches to a generic definition not defined for negative integer exponents unless x is one, but the latter two expressions do not.","category":"page"},{"location":"introduction/#Polynomial-and-rational-expressions","page":"Examples","title":"Polynomial and rational expressions","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy makes it very easy to work with polynomial and rational expressions, as illustrated in the following section.","category":"page"},{"location":"introduction/#The-expand,-factor,-and-collect-functions","page":"Examples","title":"The expand, factor, and collect functions","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"A typical polynomial expression in a single variable can be written in two common ways, expanded or factored form. Using factor and expand can move between the two.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For example,","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x y z\n(x, y, z)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> p = x^2 + 3x + 2; println(p)\nx^2 + 3*x + 2\n\njulia> factor(p)\n(x + 1)⋅(x + 2)\n\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Or","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> expand(prod((x-i) for i in 1:5)) |> println\nx^5 - 15*x^4 + 85*x^3 - 225*x^2 + 274*x - 120\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The factor function factors over the rational numbers, so something like this with obvious factors is not finished:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> factor(x^2 - 2) |> println\nx^2 - 2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"When expressions involve one or more variables, it can be convenient to be able to manipulate them. For example, if we define q by:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> q = x*y + x*y^2 + x^2*y + x\n 2        2\nx ⋅y + x⋅y  + x⋅y + x\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Then we can collect the terms by the variable x:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> collect(q, x)\n 2       ⎛ 2        ⎞\nx ⋅y + x⋅⎝y  + y + 1⎠\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"or the variable y:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> collect(q, y)\n   2         ⎛ 2    ⎞\nx⋅y  + x + y⋅⎝x  + x⎠\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"These are identical expressions, though viewed differently.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The SymPy tutorial illustrates that expand can also result in simplifications through this example:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> expand((x + 1)*(x - 2) - (x - 1)*x)\n-2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"These methods are not restricted to polynomial expressions and will work with other expressions. For example, factor identifies the following as a factorable object in terms of the variable exp(x):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> factor(exp(2x) + 3exp(x) + 2)\n⎛ x    ⎞ ⎛ x    ⎞\n⎝ℯ  + 1⎠⋅⎝ℯ  + 2⎠\n","category":"page"},{"location":"introduction/#Rational-expressions:-apart,-together,-cancel","page":"Examples","title":"Rational expressions: apart, together, cancel","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"When working with rational expressions, SymPy does not do much simplification unless asked. For example this expression is not simplified:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> r = 1/x + 1/x^2\n1   1\n─ + ──\nx    2\n    x\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To put the terms of r over a common denominator, the together function is available:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> together(r)\nx + 1\n─────\n   2\n  x\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The apart function does the reverse, creating a partial fraction decomposition from a ratio of polynomials:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> apart( (4x^3 + 21x^2 + 10x + 12) /  (x^4 + 5x^3 + 5x^2 + 4x))\n 2⋅x - 1       1     3\n────────── - ───── + ─\n 2           x + 4   x\nx  + x + 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Some times SymPy will cancel factors, as here:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> top = (x-1)*(x-2)*(x-3)\n(x - 3)⋅(x - 2)⋅(x - 1)\n\njulia> bottom = (x-1)*(x-4)\n(x - 4)⋅(x - 1)\n\njulia> top/bottom\n(x - 3)⋅(x - 2)\n───────────────\n     x - 4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(This might make math faculty a bit upset, but it is in line with student thinking.)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"However, with expanded terms, the common factor of (x-1) is not cancelled:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> r = expand(top) / expand(bottom)\n 3      2\nx  - 6⋅x  + 11⋅x - 6\n────────────────────\n     2\n    x  - 5⋅x + 4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The cancel function instructs SymPy to cancel common factors in a rational expression.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> cancel(r)\n 2\nx  - 5⋅x + 6\n────────────\n   x - 4\n","category":"page"},{"location":"introduction/#Powers","page":"Examples","title":"Powers","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The SymPy tutorial offers a thorough explanation on powers and how the rules of powers are applied during simplification. Basically","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"x^a x^b = x^a+b\nis always true. However\nx^a y^a=(xy)^a\nis only true with assumptions, such as xy geq 0 and a is real, but not in general. For example, x=y=-1 and a=12 has x^a cdot y^a = i cdot i =  -1, where as (xy)^a = 1.\n(x^a)^b = x^ab\nis only true with assumptions. For example x=-1 a=2, and b=12 gives (x^a)^b = 1^12 = 1, whereas x^ab = -1^1 = -1.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We see that with assumptions, the following expression does simplify to 0:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x::nonnegatve y::nonnegative  a::real\n(x, y, a)\n\njulia> simplify(x^a * y^a - (x*y)^a)\n0\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"However, without assumptions this is not the case","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x, y, a\n(x, y, a)\n\njulia> simplify(x^a * y^a - (x*y)^a)\n a  a        a\nx ⋅y  - (x⋅y)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The simplify function calls powsimp to simplify powers, as above. The powsimp function has the keyword argument force=true to force simplification even if assumptions are not specified:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> powsimp(x^a * y^a - (x*y)^a, force=true)\n0\n","category":"page"},{"location":"introduction/#More-on-polynomials","page":"Examples","title":"More on polynomials","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(The following section is borrowed almost directly from the SymPy documentation Examples from Wester's Article) and shows more methods for working with polynomial expressions.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The following are reasonably high-degree polynomials:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x\n(x,)\n\njulia> f = 64*x^34 - 21*x^47 - 126*x^8 - 46*x^5 - 16*x^60 - 81\n      60       47       34        8       5\n- 16⋅x   - 21⋅x   + 64⋅x   - 126⋅x  - 46⋅x  - 81\n\njulia> g = 72*x^60 - 25*x^25 - 19*x^23 - 22*x^39 - 83*x^52 + 54*x^10 + 81\n    60       52       39       25       23       10\n72⋅x   - 83⋅x   - 22⋅x   - 25⋅x   - 19⋅x   + 54⋅x   + 81\n\njulia> h = 34*x^19 - 25*x^16 + 70*x^7 + 20*x^3 - 91*x - 86\n    19       16       7       3\n34⋅x   - 25⋅x   + 70⋅x  + 20⋅x  - 91⋅x - 86","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"There are no common divisors of f and g, as gcd illustrates:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> gcd(f,g)\n1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Multiplying both terms by h and expanding gives a known g.c.d. of h, verified through:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> gcd(expand(f*h), expand(g*h)) - h\n0\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The resultant of two polynomials is a polynomial expression of their coefficients that is equal to zero if and only if the polynomials have a common root :","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> sympy.resultant(expand(f*h), expand(g*h))\n0","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The following shows high-degree polynomials can easily be factored:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> factor(expand(f*g)) |> println\n-(16*x^60 + 21*x^47 - 64*x^34 + 126*x^8 + 46*x^5 + 81)*(72*x^60 - 83*x^52 - 22*x^39 - 25*x^25 - 19*x^23 + 54*x^10 + 81)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Similar functionality extends to multivariable polynomials","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x y z\n(x, y, z)\n\njulia> f = 24*x*y^19*z^8 - 47*x^17*y^5*z^8 + 6*x^15*y^9*z^2 - 3*x^22 + 5\n     22       17  5  8      15  9  2         19  8\n- 3⋅x   - 47⋅x  ⋅y ⋅z  + 6⋅x  ⋅y ⋅z  + 24⋅x⋅y  ⋅z  + 5\n\njulia> g = 34*x^5*y^8*z^13 + 20*x^7*y^7*z^7 + 12*x^9*y^16*z^4 + 80*y^14*z\n    9  16  4       7  7  7       5  8  13       14\n12⋅x ⋅y  ⋅z  + 20⋅x ⋅y ⋅z  + 34⋅x ⋅y ⋅z   + 80⋅y  ⋅z\n\njulia> h = 11*x^12*y^7*z^13 - 23*x^2*y^8*z^10 + 47*x^17*y^5*z^8\n    17  5  8       12  7  13       2  8  10\n47⋅x  ⋅y ⋅z  + 11⋅x  ⋅y ⋅z   - 23⋅x ⋅y ⋅z\n\njulia> gcd(expand(f*h), expand(g*h)) - h\n0\n\njulia> factor(expand(f*g)) |> println\n-2*y^7*z*(6*x^9*y^9*z^3 + 10*x^7*z^6 + 17*x^5*y*z^12 + 40*y^7)*(3*x^22 + 47*x^17*y^5*z^8 - 6*x^15*y^9*z^2 - 24*x*y^19*z^8 - 5)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Symbolic powers also can be used:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x::real, n::integer\n(x, n)\n\njulia> gcd(x^n - x^(2*n), x^n) |> println\nx^n\n\njulia> sympy.resultant(3*x^4 + 3*x^3 + x^2 - x - 2, x^3 - 3*x^2 + x + 5)\n0\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Factoring can be done over different fields, not just the rationals. This shows factoring over complex terms:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> f = 4*x^4 + 8*x^3 + 77*x^2 + 18*x + 153\n   4      3       2\n4⋅x  + 8⋅x  + 77⋅x  + 18⋅x + 153\n\njulia> factor(f, gaussian=true)\n  ⎛    3⋅ⅈ⎞ ⎛    3⋅ⅈ⎞\n4⋅⎜x - ───⎟⋅⎜x + ───⎟⋅(x + 1 - 4⋅ⅈ)⋅(x + 1 + 4⋅ⅈ)\n  ⎝     2 ⎠ ⎝     2 ⎠\n\njulia> factor(f, extension=sympy.I)\n  ⎛    3⋅ⅈ⎞ ⎛    3⋅ⅈ⎞\n4⋅⎜x - ───⎟⋅⎜x + ───⎟⋅(x + 1 - 4⋅ⅈ)⋅(x + 1 + 4⋅ⅈ)\n  ⎝     2 ⎠ ⎝     2 ⎠","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In the following  we make a variable for a symbolic sqrt2:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> const φ = sqrt(Sym(2))\n√2\n\njulia> f = x^3 + (φ - 2)*x^2 - (2*φ + 3)*x - 3*φ\n 3    2\nx  + x ⋅(-2 + √2) - x⋅(2⋅√2 + 3) - 3⋅√2\n\njulia> g = x^2 - 2\n 2\nx  - 2","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Trying to cancel f/g leaves the expression unchanged; to make cancel recognize algebraic properties of sqrt2 the extension keyword is needed:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> cancel(f/g) |> println\n(x^3 - 2*x^2 + sqrt(2)*x^2 - 3*x - 2*sqrt(2)*x - 3*sqrt(2))/(x^2 - 2)\n\njulia> cancel(f/g, extension=true) |> println\n(x^2 - 2*x - 3)/(x - sqrt(2))\n\njulia> cancel(f/g, extension=φ) |> println\n(x^2 - 2*x - 3)/(x - sqrt(2))\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Factoring over modular integers (prime only) is possible using the keyword modulus:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> f = x^4 - 3*x^2 + 1;\n\njulia> factor(f) |> println\n(x^2 - x - 1)*(x^2 + x - 1)\n\njulia> factor(f, modulus=2) |> println\n(x^2 + x + 1)^2\n\njulia> factor(f, modulus=5) |> println\n(x - 2)^2*(x + 2)^2\n","category":"page"},{"location":"introduction/#The-Poly-class-in-SymPy","page":"Examples","title":"The Poly class in SymPy","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The expression x^4 - 3x^2 + 1 is stored internally as other expressions are, using the expression tree to build up from the atoms. However, for polynomials, more efficient and advantageous representations are possible. The dense polynomial representation is possible by storing just the coefficients relative to a known basis. For example:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> f = x^4 - 2x^2 + 1\n 4      2\nx  - 2⋅x  + 1\n\njulia> println(sympy.srepr(f))\nAdd(Pow(Symbol('x'), Integer(4)), Mul(Integer(-1), Integer(2), Pow(Symbol('x'), Integer(2))), Integer(1))\n\njulia> p = sympy.Poly(f, x)\nPoly(x**4 - 2*x**2 + 1, x, domain='ZZ')\n\njulia> p.rep\nPyObject DMP([mpz(1), mpz(0), mpz(-2), mpz(0), mpz(1)], ZZ, None)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Storing p using just coefficients may be more efficient for many task, such as addition and multiplication, but not, as it will be much more efficient to store f^100 than p^100.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"One advantage of the Poly class is specific methods become available as the structure is assumed. For example, we will see the coeffs method used to extract the coefficients.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The domain shown when p is displayed refers to assumptions on the coefficients. Above is a symbol for integers, QQ is for rational numbers, RR for real numbers, CC for complex (along with other variants, like ZZ_I for complex integers.","category":"page"},{"location":"introduction/#Coefficients","page":"Examples","title":"Coefficients","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Returning to polynomials, there are a few functions to find various pieces of the polynomials. First we make a general quadratic polynomial:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms a,b,c,x\n(a, b, c, x)\n\njulia> p = a*x^2 + b*x + c\n   2\na⋅x  + b⋅x + c\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"If given a polynomial, like p, there are different means to extract the coefficients:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy provides a coeffs method for Poly objects, but p must first be converted to one.\nSymPy provides the coeff method for expressions, which allows extration of a coeffiecient for a given monomial","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The ex.coeff(monom) call will return the corresponding coefficient of the monomial:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> p.coeff(x^2) # a\na\n\njulia> p.coeff(x)   # b\nb\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The constant can be found through substitution:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> p(x=>0)\nc\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Though one could use some trick like this to find all the coefficients:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> Sym[[p.coeff(x^i) for i in N(degree(p,gen=x)):-1:1]; p(x=>0)]\n3-element Vector{Sym}:\n a\n b\n c\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"that is cumbersome, at best. SymPy has a function coeffs, but it is defined for polynomial types, so will fail on p:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> try p.coeffs() catch err \"ERROR: KeyError: key `coeffs` not found\" end # wrap p.coeffs() for doctest of error\n\"ERROR: KeyError: key `coeffs` not found\"","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Polynomials are a special class in SymPy and must be constructed. The Poly constructor can be used. As there is more than one free variable in p, we specify the variable x below:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> q = sympy.Poly(p, x)\nPoly(a*x**2 + b*x + c, x, domain='ZZ[a,b,c]')\n\njulia> q.coeffs()\n3-element Vector{Sym}:\n a\n b\n c\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nThe Poly constructor from SymPy is not a function, so is not exported when SymPy is loaded. To access it, the object must be qualified by its containing module, in this case Poly. Were it to be used frequently, an alias could be used, as in const Poly=sympy.Poly or the import_from function, as in import_from(sympy, :Poly). The latter has some attempt to avoid naming collisions.","category":"page"},{"location":"introduction/#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots","page":"Examples","title":"Polynomial roots: solve, real_roots, polyroots, nroots","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy provides functions to find the roots of a polynomial. In general, a polynomial with real coefficients of degree n will have n roots when multiplicities and complex roots are accounted for. The number of real roots is consequently between 0 and n.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For a univariate polynomial expression (a single variable), the real roots, when available, are returned by real_roots. For example,","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> real_roots(x^2 - 2)\n2-element Vector{Sym}:\n -√2\n  √2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Unlike factor – which only factors over rational factors – real_roots finds the two irrational roots here. It is well known (the Abel-Ruffini theorem) that for degree 5 polynomials, or higher, it is not always possible to express the roots in terms of radicals. However, when the roots are rational SymPy can have success:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> p = (x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1);  println(p)\nx*(x - 3)^2*(x - 2)*(x - 1)*(x + 1)*(x^2 + x + 1)\n\njulia> real_roots(p)\n6-element Vector{Sym}:\n -1\n  0\n  1\n  2\n  3\n  3\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Why `println`?\nThe uses of println(p) above and elsewhere throughout the introduction is only for technical reasons related to doctesting and how Documenter.jl parses  the expected output. This usage is not idiomatic, or suggested; it  only allows the cell  to  be tested programatically for  regressions. Similarly, expected errors  are  wrapped in try-catch blocks just  for testing purposes.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In this example, the degree of p is 8, but only the 6 real roots returned, the double root of 3 is accounted for. The two complex roots of x^2 + x+ 1 are not considered by this function. The complete set of distinct roots can be found with solve:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solve(p)\n7-element Vector{Sym}:\n                 -1\n                  0\n                  1\n                  2\n                  3\n -1/2 - sqrt(3)*I/2\n -1/2 + sqrt(3)*I/2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This finds the complex roots, but does not account for the double root. The roots function of SymPy does.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output of calling roots will be a dictionary whose keys are the roots and values the multiplicity.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> roots(p)\nDict{Any, Any} with 7 entries:\n  -1                 => 1\n  3                  => 2\n  1                  => 1\n  0                  => 1\n  -1/2 - sqrt(3)*I/2 => 1\n  2                  => 1\n  -1/2 + sqrt(3)*I/2 => 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"When exact answers are not provided, the roots call is contentless:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> p = x^5 - x + 1\n 5\nx  - x + 1\n\njulia> sympy.roots(p)\nDict{Any, Any}()\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Calling solve seems to produce very little as well:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> rts = solve(p)\n5-element Vector{Sym}:\n CRootOf(x^5 - x + 1, 0)\n CRootOf(x^5 - x + 1, 1)\n CRootOf(x^5 - x + 1, 2)\n CRootOf(x^5 - x + 1, 3)\n CRootOf(x^5 - x + 1, 4)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"But in fact, rts contains lots of information. We can extract numeric values quite easily with N:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> N.(rts)\n5-element Vector{Number}:\n                     -1.167303978261418684256045899854842180720560371525489039140082449275651903429536\n -0.18123244446987538 - 1.0839541013177107im\n -0.18123244446987538 + 1.0839541013177107im\n   0.7648844336005847 - 0.35247154603172626im\n   0.7648844336005847 + 0.35247154603172626im\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"These are numeric approximations to irrational values. For numeric approximations to polynomial roots, the nroots function is also provided. The answers are still symbolic:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> nroots(p)\n5-element Vector{Sym}:\n                       -1.16730397826142\n -0.181232444469875 - 1.08395410131771⋅ⅈ\n -0.181232444469875 + 1.08395410131771⋅ⅈ\n 0.764884433600585 - 0.352471546031726⋅ⅈ\n 0.764884433600585 + 0.352471546031726⋅ⅈ\n","category":"page"},{"location":"introduction/#The-solve-function","page":"Examples","title":"The solve function","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The solve function is more general purpose than just finding roots of univariate polynomials. The function tries to solve for when an expression is 0, or a set of expressions are all 0.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For example, it can be used to solve when cos(x) = sin(x):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solve(cos(x) - sin(x))\n1-element Vector{Sym}:\n pi/4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Though there are infinitely many correct solutions, these are within a certain range.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Using `~` to specify an equation\nThe above solved an equation cos(x) = sin(x) by subtracting and solving the mathematically equivalent cos(x) - sin(x) = 0, the 0 being assumed by SymPy when an explicit equation is not specified. Alternatively, the ~ can be used in place of = when representing an equation, as in solve(cos(x) ~ sin(x), x).","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The solveset function appeared in version 1.0 of SymPy and is an intended replacement for solve. Here we see it describes all solutions:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> u = solveset(cos(x) ~ sin(x))\n⎧        5⋅π │      ⎫   ⎧        π │      ⎫\n⎨2⋅n⋅π + ─── │ n ∊ ℤ⎬ ∪ ⎨2⋅n⋅π + ─ │ n ∊ ℤ⎬\n⎩         4  │      ⎭   ⎩        4 │      ⎭\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output of solveset is a set, rather than a vector or dictionary. To get the values requires some work. For finite sets we collect the elements with collect, but first we must convert to a Julia Set:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> v = solveset(x^2 ~ 4, x)\n{-2, 2}\n\njulia> collect(Set(v...))\n2-element Vector{Any}:\n  2\n -2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This composition is done in the elements function:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> elements(v)\n2-element Vector{Sym}:\n  2\n -2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The elements function does not work for more complicated (non-finite) sets, such as u. For these, the contains method may be useful to query the underlying elements.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solveset(cos(x) ~ sin(x), x).contains(PI/4)\nTrue","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output is a symbolic True. This can be converted via N or compared to rrue, but not directly used within a conditional argument:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> N(True), True == true, True === true\n(true, true, false)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Solving within Sympy has limits. For example, there is no symbolic solution here:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> try  solve(cos(x) - x)  catch err \"error\" end # wrap command for doctest of error\n\"error\"","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(And hence the error message generated.)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For such an equation, a numeric method would be needed, similar to the Roots package. For example:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> nsolve(cos(x) - x, 1) ≈ 0.73908513321516064165\ntrue","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Though it can't solve everything, the solve function can also solve equations of a more general type. For example, here it is used to derive the quadratic equation:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms a::real, b::real, c::real\n(a, b, c)\n\njulia> p = a*x^2 + b*x + c\n   2\na⋅x  + b⋅x + c","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solve(p, x)\n2-element Vector{Sym}:\n (-b + sqrt(-4*a*c + b^2))/(2*a)\n -(b + sqrt(-4*a*c + b^2))/(2*a)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The extra argument x is passed to solve so that solve knows which variable to solve for.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The solveset function is similar:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solveset(p, x)\n⎧           _____________             _____________⎫\n⎪          ╱           2             ╱           2 ⎪\n⎨   b    ╲╱  -4⋅a⋅c + b       b    ╲╱  -4⋅a⋅c + b  ⎬\n⎪- ─── - ────────────────, - ─── + ────────────────⎪\n⎩  2⋅a         2⋅a           2⋅a         2⋅a       ⎭\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"If the x value is not given, solveset will error and  solve will try to find a solution over all the free variables:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solve(p)\n1-element Vector{Dict{Any, Any}}:\n Dict(a => -(b*x + c)/x^2)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Systems of equations can be solved as well. For example, to solve this linear system: 2x + 3y = 6 3x - 4y=12, we have:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x::real, y::real\n(x, y)\n\njulia> exs = (2x+3y ~ 6, 3x-4y ~ 12)\n(Eq(2*x + 3*y, 6), Eq(3*x - 4*y, 12))\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> d = solve(exs); # Dict(x=>60/17, y=>-6/17)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nWe formed a tuple of equations above. A matrix of equations is now deprecated within SymPy and the automatic conversion of PyCall does that conversion.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We can \"check our work\" by plugging into each equation. We take advantage of how the subs function, used implicitly, allows us to pass in a dictionary:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> [ex(d) for ex ∈ exs]\n2-element Vector{Sym}:\n True\n True\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The more Julian way to solve a linear  equation, like this   would be as follows:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> A = Sym[2 3; 3  -4]; b = Sym[6, 12]\n2-element Vector{Sym}:\n  6\n 12\n\njulia> A \\ b\n2-element Vector{Sym}:\n 60/17\n -6/17","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nRather than use a generic  lu solver through Julia (which  proved slow for larger  systems),  the \\ operator utilizes  solve to perform this  computation.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In the previous example, the system had two equations and two unknowns. When that is not the case, one can specify the variables to solve for in a tuple. In this example, we find a quadratic polynomial that approximates cos(x) near 0:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> a,b,c,h = symbols(\"a,b,c,h\", real=true)\n(a, b, c, h)\n\njulia> p = a*x^2 + b*x + c\n   2\na⋅x  + b⋅x + c\n\njulia> fn = cos\ncos (generic function with 14 methods)\n\njulia> exs = [fn(0*h)-p(x => 0), fn(h)-p(x => h), fn(2h)-p(x => 2h)]\n3-element Vector{Sym}:\n                           1 - c\n       -a*h^2 - b*h - c + cos(h)\n -4*a*h^2 - 2*b*h - c + cos(2*h)\n\njulia> d = solve(exs, (a,b,c))\nDict{Any, Any} with 3 entries:\n  a => -cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2)\n  c => 1\n  b => 2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Again, a dictionary is returned. The polynomial itself can be found by substituting back in for a, b, and c:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> quad_approx = p.subs(d); println(quad_approx)\nx^2*(-cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2)) + x*(2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h)) + 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Taking the \"limit\" as h goes to 0 produces the answer 1 - x^22, as  will be shown later.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Finally for solve, we show one way to re-express the polynomial a_2x^2 + a_1x + a_0 as b_2(x-c)^2 + b_1(x-c) + b_0 using solve (and not, say, an expansion theorem.)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> n = 3\n3\n\njulia> @syms x, c\n(x, c)\n\njulia> @syms as[1:3]\n(Sym[as₁, as₂, as₃],)\n\njulia> @syms bs[1:3]\n(Sym[bs₁, bs₂, bs₃],)\n\njulia> p = sum([as[i+1]*x^i for i in 0:(n-1)]);\n\njulia> q = sum([bs[i+1]*(x-c)^i for i in 0:(n-1)]);\n\njulia> solve(p ~ q, bs)\nDict{Any, Any} with 3 entries:\n  bs₁ => as₁ + as₂*c + as₃*c^2\n  bs₂ => as₂ + 2*as₃*c\n  bs₃ => as₃\n","category":"page"},{"location":"introduction/#Solving-using-logical-operators","page":"Examples","title":"Solving using logical operators","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The solve function does not need to just solve ex = 0. There are other means to specify an equation. Ideally, it would be nice to say ex1 == ex2, but the interpretation of == is not for this. Rather, SymPy introduces Eq for equality. So this expression","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solve(Eq(x, 1))\n1-element Vector{Sym}:\n 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"gives 1, as expected from solving x == 1.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The previously used infix operator ~ simply calls Eq to construct an equality.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In addition to Eq, there are Lt, Le, Ge, Gt. The Unicode operators (e.g., \\leq  and not  \\leq)  are not aliased to these, but there are alternatives \\ll[tab], \\leqq[tab], \\Equal[tab], \\geqq[tab], \\gg[tab] and \\neg[tab] to negate.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"So, the above could have been written with the following nearly identical expression, though it is entered with \\Equal[tab]:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> solve(x ⩵ 1)\n1-element Vector{Sym}:\n 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The infix tilde, ~,  consistent with the interface from Symbolics , is recommended for readability over ⩵.","category":"page"},{"location":"introduction/#Plotting","page":"Examples","title":"Plotting","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The Plots package allows many 2-dimensional plots of SymPy objects to be agnostic as to a backend plotting package.  SymPy provides recipes that allow symbolic expressions to be used where functions are part of the Plots interface. [See the help page for sympy_plotting.]","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In particular, the following methods of plot are defined:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"plot(ex::Sym, a, b) will plot the expression of single variable over the interval [a,b]\nplot!(ex::Sym, a, b) will add to the current plot a plot of  the expression of single variable over the interval [a,b], or, when not specified, the current plotting limits\nplot(ex1, ex2, a, b) will plot a parametric plot of the two expressions over the interval [a,b].\ncontour(xs, ys, ex::Sym) will make a contour plot of the expression of two variables over the grid specifed by the xs and ys.\nsurface(xs, ys, ex::Sym) will make a surface plot of the expression of two variables over the grid specifed by the xs and ys.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For example:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"using SymPy, Plots\n@syms x\nplot(x^2 - 2, -2, 2)\nsavefig(\"plot-1.svg\"); nothing  # hide","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Or a parametric plot:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"plot(sin(2x), cos(3x), 0, 4pi);\nsavefig(\"plot-2.svg\"); nothing # hide","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For plotting with other plotting packages, it is generally faster to first call lambdify on the expression and then generate y values with the resulting Julia function. An example might follow this pattern:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"ex = cos(x)^2  +  cos(x^2)\nfn = lambdify(ex)\nxs = range(0, stop=10, length=256)\nplot(xs, fn.(xs))\nsavefig(\"plot-3.svg\"); nothing #hide","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In addition, with PyPlot a few other plotting functions from SymPy are available from its interface to MatplotLib:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"plot3d_parametric_surface(ex1::Sym, ex2::Sym, ex3::Sym), (uvar, a0, b0), (vvar, a1, b1)) – make a surface plot of the expressions parameterized by the region [a0,b0] x [a1,b1]. The default region is [-5,5]x[-5,5] where the ordering of the variables is given by free_symbols(ex).\nplot_implicit(predictate, (xvar, a0, b0), (yvar, a1, b1)) – make","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"an implicit equation plot of the expressions over the region [a0,b0] x [a1,b1]. The default region is [-5,5]x[-5,5] where the ordering of the variables is given by free_symbols(ex).  To create predicates from the variable, the functions Lt, Le, Eq, Ge, and Gt can be used, as with Lt(x*y, 1). For infix notation, unicode operators can be used: \\ll<tab>, \\leqq<tab>, \\Equal<tab>, \\geqq<tab>, and \\gg<tab>. For example, x*y ≪ 1.  To combine terms, the unicode \\vee<tab> (for \"or\"), \\wedge<tab> (for \"and\") can be used.","category":"page"},{"location":"introduction/#Calculus","page":"Examples","title":"Calculus","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy has many of the basic operations of calculus provided through a relatively small handful of functions.","category":"page"},{"location":"introduction/#Limits","page":"Examples","title":"Limits","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Limits are computed by the limit function which takes an expression, a variable and a value, and optionally a direction specified by either dir=\"+\" or dir=\"-\".","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For example, this shows Gauss was right:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(sin(x)/x, x, 0)\n1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Alternatively, the second and third arguments can be specified as a pair:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(sin(x)/x, x => 0)\n1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Limits at infinity are done by using oo for infty:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit((1+1/x)^x, x => oo)\nℯ\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This example computes what L'Hopital reportedly paid a Bernoulli for","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms a::positive\n(a,)\n\njulia> ex = (sqrt(2a^3*x-x^4) - a*(a^2*x)^(1//3)) / (a - (a*x^3)^(1//4));  println(ex)\n(-a^(5/3)*x^(1/3) + sqrt(2*a^3*x - x^4))/(-a^(1/4)*(x^3)^(1/4) + a)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Substituting x=a gives an indeterminate form:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex(x=>a)\nnan\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We can see it is of the form 00:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> denom(ex)(x => a), numer(ex)(x => a)\n(0, 0)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"And we get","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(ex, x => a)\n16⋅a\n────\n 9\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In a previous example, we defined quad_approx:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> quad_approx |> println\nx^2*(-cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2)) + x*(2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h)) + 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The limit as h goes to 0 gives 1 - x^2/2, as expected:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(quad_approx, h => 0)\n     2\n    x\n1 - ──\n    2\n","category":"page"},{"location":"introduction/#Left-and-right-limits","page":"Examples","title":"Left and right limits","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The limit is defined when both the left and right limits exist and are equal. But left and right limits can exist and not be equal. The sign function is 1 for positive x, -1 for negative x and 0 when x is 0. It should not have a limit at 0:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(sign(x), x => 0)\n1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Oops. Well, the left and right limits are different anyways:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(sign(x), x => 0, dir=\"-\"), limit(sign(x), x => 0, dir=\"+\")\n(-1, 1)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The limit function finds the right limit by default. The direction \"+-\" will check both, erroring if the two do not agree, as below with a message of \"ValueError('The limit does not exist since left hand limit = -1 and right hand limit = 1')\"","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> try(limit(sign(x), x => 0, dir=\"+-\")) catch err \"error\" end\n\"error\"\n","category":"page"},{"location":"introduction/#Numeric-limits","page":"Examples","title":"Numeric limits","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The limit function uses the Gruntz algorithm. It is far more reliable then simple numeric attempts at limits. An example of Gruntz is the right limit at 0 of the function:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> j(x) = 1/x^(log(log(log(log(1/x)))) - 1)\nj (generic function with 1 method)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"A numeric attempt might be done along these lines:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> hs = [10.0^(-i) for i in 6:16]\n11-element Vector{Float64}:\n 1.0e-6\n 1.0e-7\n 1.0e-8\n 1.0e-9\n 1.0e-10\n 1.0e-11\n 1.0e-12\n 1.0e-13\n 1.0e-14\n 1.0e-15\n 1.0e-16\n\njulia> ys = [r(h) for h in hs]\n11-element Vector{Float64}:\n 6.146316238971239e-7\n 1.4298053954169988e-7\n 3.4385814272678773e-8\n 8.529918929292077e-9\n 2.176869418153584e-9\n 5.700972891527026e-10\n 1.528656750900649e-10\n 4.188388514215749e-11\n 1.1705748589577942e-11\n 3.331965462828263e-12\n 9.64641441953344e-13\n\njulia> [hs ys]\n11×2 Matrix{Float64}:\n 1.0e-6   6.14632e-7\n 1.0e-7   1.42981e-7\n 1.0e-8   3.43858e-8\n 1.0e-9   8.52992e-9\n 1.0e-10  2.17687e-9\n 1.0e-11  5.70097e-10\n 1.0e-12  1.52866e-10\n 1.0e-13  4.18839e-11\n 1.0e-14  1.17057e-11\n 1.0e-15  3.33197e-12\n 1.0e-16  9.64641e-13\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"With a values appearing to approach 0. However, in fact these values will ultimately head  off to infty:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(j(x), x => 0, dir=\"+\")\n∞\n","category":"page"},{"location":"introduction/#Derivatives","page":"Examples","title":"Derivatives","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"One could use limits to implement the definition of a derivative:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x::real, h::real\n(x, h)\n\njulia> j(x) = x * exp(x)\nj (generic function with 1 method)\n\njulia> limit((j(x+h) - j(x)) / h, h => 0) |> println\nx*exp(x) + exp(x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"However, it would be pretty inefficient, as SymPy already does a great job with derivatives. The diff function implements this. The basic syntax is diff(ex, x) to find the first derivative in x of the expression in ex, or its generalization to kth derivatives with diff(ex, x, k).","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The same derivative computed above by a limit could be found with:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> diff(j(x), x)\n   x    x\nx⋅ℯ  + ℯ\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Similarly, we can compute other derivatives:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> diff(x^x, x)\n x\nx ⋅(log(x) + 1)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Or, higher order  derivatives:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> diff(exp(-x^2), (x, 2)) |>  println\n2*(2*x^2 - 1)*exp(-x^2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"As an alternate to specifying the number of derivatives, multiple variables can be passed to diff:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> diff(exp(-x^2), x, x, x) |>  println     # same as diff(..., (x, 3))\n4*x*(3 - 2*x^2)*exp(-x^2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This could include variables besides x,  as is needed with mixed partial  derivatives.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output is a simple expression, so diff can be composed with other functions, such as solve. For example, here we find the critical points where the derivative is 0 of some rational function:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> j(x) = (12x^2 - 1) / (x^3)\nj (generic function with 1 method)\n\njulia> diff(j(x), x) |> solve\n2-element Vector{Sym}:\n -1/2\n  1/2\n","category":"page"},{"location":"introduction/#Partial-derivatives","page":"Examples","title":"Partial derivatives","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The diff function makes finding partial derivatives as easy as specifying the variable to differentiate in. This  example computes the mixed partials of an expression in x and y:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x y\n(x, y)\n\njulia> ex = x^2*cos(y)\n 2\nx ⋅cos(y)\n\njulia> [diff(ex, v1, v2) for v1 in [x,y], v2 in [x,y]]  # also hessian(ex, (x,y))\n2×2 Matrix{Sym}:\n    2⋅cos(y)  -2⋅x⋅sin(y)\n -2⋅x⋅sin(y)  -x^2*cos(y)\n","category":"page"},{"location":"introduction/#Unevaluated-derivatives","page":"Examples","title":"Unevaluated derivatives","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The Derivative constructor provides unevaluated derivatives, useful with differential equations and the output for unknown functions. Here is an example:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex = sympy.Derivative(exp(x*y), x, (y, 2))\n   3\n  ∂   ⎛ x⋅y⎞\n──────⎝ℯ   ⎠\n  2\n∂y  ∂x\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"These expressions are evaluated with the doit method:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex.doit() |> println\nx*(x*y + 2)*exp(x*y)\n","category":"page"},{"location":"introduction/#Implicit-derivatives","page":"Examples","title":"Implicit derivatives","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy can be used to find derivatives of implicitly defined functions. For example, the task of finding dydx for the equation:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"\ny^4 - x^4 -y^2 + 2x^2 = 0\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"As with the mathematical solution, the key is to treat one of the variables as depending on the other. In this case, we think of y locally as a function of x. SymPy allows us to create symbolic functions, and we will use one to substitute in for y.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"In SymPy, symbolic functions use the class name  \"Function\", but in SymPy we use SymFunction to avoid a name collision with one of Julia's primary types. The constructor can be used as SymFunction(:F):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> F, G = SymFunction(\"F\"), SymFunction(\"G\")\n(F, G)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The @syms macro can also more naturally be used, in place of SymFunction:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms F(), G()\n(F, G)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We can call these functions, but we get a function expression:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> F(x)\nF(x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy can differentiate symbolically, again with diff:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> diff(F(x))\nd\n──(F(x))\ndx\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To get back to our problem, we have our expression:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x, y\n(x, y)\n\njulia> ex = y^4 - x^4 - y^2 + 2x^2\n   4      2    4    2\n- x  + 2⋅x  + y  - y\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Now we substitute:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex1 = ex(y=>F(x))\n   4      2    4       2\n- x  + 2⋅x  + F (x) - F (x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We want to differentiate \"both\" sides. As the right side is just 0, there isn't anything to do here, but mentally keep track. As for the left we have:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex2 = diff(ex1, x)\n     3            3    d                 d\n- 4⋅x  + 4⋅x + 4⋅F (x)⋅──(F(x)) - 2⋅F(x)⋅──(F(x))\n                       dx                dx\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Now we collect terms and solve in terms of F(x)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex3 = solve(ex2, F'(x))[1]\n     3\n  2⋅x  - 2⋅x\n──────────────\n   3\n2⋅F (x) - F(x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Finally, we substitute back into the solution for F(x):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex4 = ex3(F(x) => y)\n   3\n2⋅x  - 2⋅x\n──────────\n    3\n 2⋅y  - y\n","category":"page"},{"location":"introduction/#Example:-A-Norman-Window","page":"Examples","title":"Example: A Norman Window","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"A classic calculus problem is to maximize the area of a Norman window (in the shape of a rectangle with a half circle atop) when the perimeter is fixed to be P geq 0.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Label the rectangle with w and h for width and height and then the half circle has radius r=w2. With this, we can see that the area is wh+(12)pi r^2 and the perimeter is w + 2h + pi r. This gives:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms w::nonnegative, h::nonnegative, P::nonnegative\n(w, h, P)\n\njulia> r = w/2\nw\n─\n2\n\njulia> A = w*h + 1//2 * (pi * r^2);   println(A)\nh*w + pi*w^2/8\n\njulia> p = w + 2h + pi*r; println(p)\n2*h + w + pi*w/2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(There is a subtlety above: using 1//2*pi*r^2 will lose exactness, as the products will be done left to right, and 1//2*pi will be converted to an approximate floating point value before multiplying r^2. As such we rewrite the terms. It may be easier to use PI instead of pi.)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We want to solve for h from when p=P (our fixed value) and substitute back into A. We solve taking the first solution.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> h0 =  solve(p ~ P, h)[1]\nP   π⋅w   w\n─ - ─── - ─\n2    4    2\n\njulia> A1 = A(h => h0)\n   2\nπ⋅w      ⎛P   π⋅w   w⎞\n──── + w⋅⎜─ - ─── - ─⎟\n 8       ⎝2    4    2⎠\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Now we note this is a parabola in w, so any maximum will be at  an endpoint or the vertex, provided the leading term is negative. The leading term can be found through:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> sympy.Poly(A1, w).coeffs()\n2-element Vector{Sym}:\n -1/2 - pi/8\n         P/2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Or without using the Poly methods, we could do this:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> collect(expand(A1), w).coeff(w^2)\n  1   π\n- ─ - ─\n  2   8\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Either way, the leading coefficient, -12 - pi8, is negative, so the maximum can only happen at an endpoint or the vertex of the parabola. Now we check that when w=0 (the left endpoint) the area is 0:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> A1(w => 0)\n0\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The other endpoint is when h=0, or","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> b = solve((P-p)(h => 0), w)[1]\n 2⋅P\n─────\n2 + π\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We will need to check the area at b and at the vertex.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To find the vertex, we can use calculus – it will be when the derivative in w is 0:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> c = solve(diff(A1, w), w)[1]\n 2⋅P\n─────\nπ + 4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The answer will be the larger of A1 at b or c:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> atb = A1(w => b); println(atb)\npi*P^2/(2*(2 + pi)^2) + 2*P*(-pi*P/(2*(2 + pi)) - P/(2 + pi) + P/2)/(2 + pi)\n\njulia> atc = A1(w => c);  println(atc)\npi*P^2/(2*(pi + 4)^2) + 2*P*(-pi*P/(2*(pi + 4)) - P/(pi + 4) + P/2)/(pi + 4)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"A simple comparison isn't revealing:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> atc - atb |> println\n-pi*P^2/(2*(2 + pi)^2) + pi*P^2/(2*(pi + 4)^2) - 2*P*(-pi*P/(2*(2 + pi)) - P/(2 + pi) + P/2)/(2 + pi) + 2*P*(-pi*P/(2*(pi + 4)) - P/(pi + 4) + P/2)/(pi + 4)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"But after simplifying, we can see that this expression is positive if P is:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> simplify(atc - atb) |> println\n2*P^2/(16 + pi^3 + 20*pi + 8*pi^2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"With this observation, we conclude the maximum area happens at c with area atc.","category":"page"},{"location":"introduction/#Integrals","page":"Examples","title":"Integrals","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Integration is implemented in SymPy through the integrate function. There are two basic calls: integrate(f(x), x) will find the indefinite integral (int f(x) dx) and when endpoints are specified through integrate(f(x), (x, a, b)) the definite integral will be found (int_a^b f(x) dx). The special form integrate(ex, x, a, b) can be used for single integrals, but the specification through a tuple is needed for multiple integrals, so isn't illustrated here.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Basic integrals are implemented:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> integrate(x^3, x)\n 4\nx\n──\n4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Or in more generality:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms n::real\n(n,)\n\njulia> ex = integrate(x^n, x)\n⎧ n + 1\n⎪x\n⎪──────  for n ≠ -1\n⎨n + 1\n⎪\n⎪log(x)  otherwise\n⎩\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output here is a piecewise function, performing a substitution will choose a branch in this case:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex(n => 3)\n 4\nx\n──\n4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Definite integrals are just as easy. Here is Archimedes' answer:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> integrate(x^2, (x, 0, 1))\n1/3\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Tedious problems, such as those needing multiple integration-by-parts steps can be done easily:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> integrate(x^5 * sin(x), x)\n   5             4              3              2\n- x ⋅cos(x) + 5⋅x ⋅sin(x) + 20⋅x ⋅cos(x) - 60⋅x ⋅sin(x) - 120⋅x⋅cos(x) + 120⋅sin(x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The SymPy tutorial says:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"\"integrate uses powerful algorithms that are always improving to compute both definite and indefinite integrals, including heuristic pattern matching type algorithms, a partial implementation of the Risch algorithm, and an algorithm using Meijer G-functions that is useful for computing integrals in terms of special functions, especially definite integrals.\"","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The tutorial gives the following example:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex = (x^4 + x^2*exp(x) - x^2 - 2*x*exp(x) - 2*x - exp(x))*exp(x)/((x - 1)^2*(x + 1)^2*(exp(x) + 1))\n⎛ 4    2  x    2        x          x⎞  x\n⎝x  + x ⋅ℯ  - x  - 2⋅x⋅ℯ  - 2⋅x - ℯ ⎠⋅ℯ\n────────────────────────────────────────\n              2        2 ⎛ x    ⎞\n       (x - 1) ⋅(x + 1) ⋅⎝ℯ  + 1⎠\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"With indefinite integral:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> integrate(ex, x) |> println\nlog(exp(x) + 1) + exp(x)/(x^2 - 1)\n","category":"page"},{"location":"introduction/#Multiple-integrals","page":"Examples","title":"Multiple integrals","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The integrate function uses a tuple, (var, a, b), to specify the limits of a definite integral. This syntax lends itself readily to multiple integration.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For example, the following computes the integral of xy over the unit square:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x, y\n(x, y)\n\njulia> integrate(x*y, (y, 0, 1), (x, 0, 1))\n1/4\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The innermost terms can depend on outer ones. For example, the following integrates x^2y over the upper half of the unit circle:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> integrate(x^2*y, (y, 0, sqrt(1 - x^2)), (x, -1, 1))\n2/15\n","category":"page"},{"location":"introduction/#Unevaluated-integrals","page":"Examples","title":"Unevaluated integrals","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The Integral constructor can stage unevaluated integrals that will be evaluated by calling doit. It is also used when the output is unknown. This example comes from the tutorial:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> integ = sympy.Integral(sin(x^2), x)\n⌠\n⎮    ⎛ 2⎞\n⎮ sin⎝x ⎠ dx\n⌡\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> integ.doit()  |>  println\n3*sqrt(2)*sqrt(pi)*fresnels(sqrt(2)*x/sqrt(pi))*gamma(3/4)/(8*gamma(7/4))\n","category":"page"},{"location":"introduction/#Taylor-series","page":"Examples","title":"Taylor series","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The series function can compute series expansions around a point to a specified order. For example, the following command finds four terms of the series expansion of exp(sin(x)) in x about c=0:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> s1 = series(exp(sin(x)), x, 0, 4); println(s1)\n1 + x + x^2/2 + O(x^4)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The coefficients are from the Taylor expansion (a_i=f^i(c)i). The big \"O\" term indicates that the remainder is no bigger in  size than a constant times x^4,  as xrightarrow  0.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Consider what happens when we multiply series of different orders:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> s2 = series(cos(exp(x)), x, 0, 6); println(s2)\ncos(1) - x*sin(1) + x^2*(-sin(1)/2 - cos(1)/2) - x^3*cos(1)/2 + x^4*(-cos(1)/4 + 5*sin(1)/24) + x^5*(-cos(1)/24 + 23*sin(1)/120) + O(x^6)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> simplify(s1 * s2) |> println\ncos(1) + sqrt(2)*x*cos(pi/4 + 1) - 3*x^2*sin(1)/2 - sqrt(2)*x^3*sin(pi/4 + 1) + O(x^4)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The big \"O\" term is x^4, as smaller order terms in s2 are covered in this term. The big \"O\" notation is sometimes not desired, in which case the removeO function can be employed:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> s1.removeO() |> println\nx^2/2 + x + 1\n","category":"page"},{"location":"introduction/#Sums","page":"Examples","title":"Sums","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy can do sums, including some infinite ones. The summation function performs this task. For example, we have","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms i, n\n(i, n)\n\njulia> summation(i^2, (i, 1, n)) |> println\nn^3/3 + n^2/2 + n/6\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Like Integrate and Derivative, there is also a Sum function to stage the task until the doit function is called to initiate the sum.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Some famous sums can be computed:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> sn = sympy.Sum(1/i^2, (i, 1, n)); println(sn)\nSum(i^(-2), (i, 1, n))\n\njulia> sn.doit()\nharmonic(n, 2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"And from this a limit is available:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> limit(sn.doit(), n, oo) |> println\npi^2/6\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This would have also been possible through summation(1/i^2, (i, 1, oo)).","category":"page"},{"location":"introduction/#Vector-valued-functions","page":"Examples","title":"Vector-valued functions","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Julia makes constructing a vector of symbolic objects easy:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x,y\n(x, y)\n\njulia> v = [1,2,x]\n3-element Vector{Sym}:\n 1\n 2\n x\n\njulia> w = [1,y,3]\n3-element Vector{Sym}:\n 1\n y\n 3\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The generic definitions of vector operations will work as expected with symbolic objects:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> using LinearAlgebra\n\njulia> dot(v,w) |> println\n2*y + 3*conjugate(x) + 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Or","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> cross(v,w)\n3-element Vector{Sym}:\n -x⋅y + 6\n    x - 3\n    y - 2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Finding gradients can be done using a comprehension.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex = x^2*y - x*y^2\n 2        2\nx ⋅y - x⋅y\n\njulia> Sym[diff(ex,var) for var in (x,y)]\n2-element Vector{Sym}:\n 2*x*y - y^2\n x^2 - 2*x*y\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Or through broadcasting:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia>  diff.(ex, (x,y))\n(2*x*y - y^2, x^2 - 2*x*y)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The mixed partials is similarly done by passing two variables to differentiate in to diff, as illustrated previously:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> Sym[diff(ex, v1, v2) for v1 in (x,y), v2 in (x,y)]\n2×2 Matrix{Sym}:\n       2⋅y  2⋅(x - y)\n 2⋅(x - y)       -2⋅x\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For this task, SymPy provides the hessian method:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> hessian(ex, (x,y))\n2×2 Matrix{Sym}:\n       2⋅y  2⋅x - 2⋅y\n 2⋅x - 2⋅y       -2⋅x\n","category":"page"},{"location":"introduction/#Matrices","page":"Examples","title":"Matrices","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Julia has excellent infrastructure to work with generic matrices, such as Matrix{Sym} objects (matrices with symbolic entries). As well, SymPy has a class for matrices. SymPy, through PyCall, automatically maps mutable SymPy matrices into Julian matrices of type Array{Sym}.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Constructing matrices with symbolic entries follows Julia's conventions:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x,y\n(x, y)\n\njulia> M = [1 x; x 1]\n2×2 Matrix{Sym}:\n 1  x\n x  1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nHowever, SymPy may throw a deprecation order when mapping a Matrix{Sym} argument for a function, as the underlying sympy.Matrix class is for symbolic numbers only since this change. The suggestion is to use a \"list of lists, TableForm, NumPy array, or some","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"other data structure instead\". A tuple of tuples will map to a list of lists.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Here is an example of a tuple of tuples forming a matrix:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> A = sympy.Matrix( ((1,x),  (y,2)) )\n2×2 Matrix{Sym}:\n 1  x\n y  2","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This is useful if copying SymPy examples, but otherwise unneccesary, these are immediately mapped into Julia arrays by PyCall – unless an immutable array is desired, and then the sympy.ImmutableMatrix constructor is used.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Some more examples:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> diagm(0=>ones(Sym, 5))\n5×5 Matrix{Sym}:\n 1  0  0  0  0\n 0  1  0  0  0\n 0  0  1  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n\njulia> M = [1 x; x 1]\n2×2 Matrix{Sym}:\n 1  x\n x  1\n\njulia> M^2\n2×2 Matrix{Sym}:\n x^2 + 1      2⋅x\n     2⋅x  x^2 + 1\n\njulia> det(M)\n     2\n1 - x","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We can call Julia's generic matrix functions in the usual manner, e.g:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> det(A)\n-x⋅y + 2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We can also call SymPy's matrix methods using the dot-call syntax:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> A.det()\n-x⋅y + 2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nActually, det(A) avoids the generic Julia implementation. A better example might be qr(M) versus M.QRdecomposition() to see a generic Julia implementation for Matrix{Sym} against SymPy's method for matrices.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Occasionally, the SymPy method has more content:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> eigvecs(M)\n2×2 Matrix{Sym}:\n 1  -1\n 1   1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"As compared to SymPy's eigenvects which yields:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> A.eigenvects()\n2-element Vector{Tuple{Sym, Int64, Vector{Matrix{Sym}}}}:\n (3/2 - sqrt(4*x*y + 1)/2, 1, [[(3/2 - sqrt(4*x*y + 1)/2)/y - 2/y; 1;;]])\n (sqrt(4*x*y + 1)/2 + 3/2, 1, [[(sqrt(4*x*y + 1)/2 + 3/2)/y - 2/y; 1;;]])\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(This is a bit misleading, as the generic eigvecs fails on M, so the value is basically just repackaged from A.eigenvects().)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This example from the SymPy tutorial shows the nullspace method:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> A = Sym[1 2 3 0 0; 4 10 0 0 1]\n2×5 Matrix{Sym}:\n 1   2  3  0  0\n 4  10  0  0  1\n\njulia> vs = A.nullspace()\n3-element Vector{Matrix{Sym}}:\n [-15; 6; … ; 0; 0;;]\n [0; 0; … ; 1; 0;;]\n [1; -1/2; … ; 0; 1;;]\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This confirms that values found are indeed in the null space of A:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> [A*vs[i] for i in 1:3]\n3-element Vector{Matrix{Sym}}:\n [0; 0;;]\n [0; 0;;]\n [0; 0;;]\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Symbolic expressions can be included in the matrices:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> A = [1 x; x 1]\n2×2 Matrix{Sym}:\n 1  x\n x  1\n\njulia> P, D = A.diagonalize()  # M = PDP^-1\n(Sym[-1 1; 1 1], Sym[1 - x 0; 0 x + 1])\n\njulia> A - P*D*inv(P)\n2×2 Matrix{Sym}:\n 0  0\n 0  0\n","category":"page"},{"location":"introduction/#Differential-equations","page":"Examples","title":"Differential equations","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"SymPy has facilities for solving ordinary differential equations. The key is to create a symbolic function expression using SymFunction. Again, this may be done through:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms F()\n(F,)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"With this, we can  construct a  differential equation. Following the SymPy tutorial, we solve f(x) - 2f(x) + f(x) = sin(x):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> diffeq = diff(F(x), x, 2) - 2*diff(F(x)) + F(x) ~ sin(x); println(diffeq)\nEq(F(x) - 2*Derivative(F(x), x) + Derivative(F(x), (x, 2)), sin(x))\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"With this, we just need the dsolve function. This is called as dsolve(eq) or dsolve(eq, F(x)):","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex = dsolve(diffeq, F(x)); println(ex)\nEq(F(x), (C1 + C2*x)*exp(x) + cos(x)/2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The dsolve function in SymPy has an extensive list of named arguments to control the underlying algorithm. These can be passed through with the appropriate keyword arguments.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The definition of the differential equation expects the cumbersome diff(ex, var) to provide the derivative. The Differential function lessens the visual noise (with a design taken from ModelingToolkit). The above would be:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> D = Differential(x)\nDifferential(x)\n\njulia> diffeq = D(D(F))(x) - 2D(F)(x) + F(x) ~ sin(x); println(diffeq)\nEq(F(x) - 2*Derivative(F(x), x) + Derivative(F(x), (x, 2)), sin(x))\n\njulia> sympy.dsolve(diffeq, F(x)) |> println\nEq(F(x), (C1 + C2*x)*exp(x) + cos(x)/2)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This solution has two constants, C_1 and C_2, that would be found from initial conditions. Say we know F(0)=0 and F(0)=1, can we find the constants? To work with the returned expression, it is most convenient to get just the right hand side. The rhs method will return the right-hand side of a relation:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex1 = rhs(ex); println(ex1)\n(C1 + C2*x)*exp(x) + cos(x)/2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(The args function also can be used to break up the expression into parts.)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"With this, we can solve for C1 through substituting in 0 for x:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> C1 = first(free_symbols(ex1))\nC₁\n\njulia> solve(ex1(x => 0), C1)\n1-element Vector{Sym}:\n -1/2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We see that C1=-12, which we substitute in:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex2 = ex1(C1 => -Sym(1//2)); println(ex2)\n(C2*x - 1/2)*exp(x) + cos(x)/2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We know that F(0)=1 now, so we solve for C2 through","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> C2 = free_symbols(ex1)[2]\nC₂\n\njulia> solve( diff(ex2, x)(x => 0) - 1, C2 )\n1-element Vector{Sym}:\n 3/2","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This gives C2=3/2. Again we substitute in to get our answer:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex3 = ex2(Sym(\"C2\") => 3//2); println(ex3)\n(3*x/2 - 1/2)*exp(x) + cos(x)/2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The dsolve function has an ics argument that allows most of the above to be done internally:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ex4 = dsolve(diffeq, F(x), ics=Dict(F(0)=>0, D(F)(0)=>1));\n\njulia> ex3 - rhs(ex4)  # need rhs to extract the solution\n0\n","category":"page"},{"location":"introduction/#Example","page":"Examples","title":"Example","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"This example is borrowed from here.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Find the variation of speed with time of a parachutist subject to a drag force of kcdot v^2.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The equation is","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"\nfracmk fracdvdt = alpha^2 - v^2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We proceed through:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms t, m, k, alpha=>\"α\", v()\n(t, m, k, α, v)\n\njulia> D = Differential(t);\n\njulia> ex = (m/k)*D(v)(t) ~ alpha^2 - v(t)^2; println(ex)\nEq(m*Derivative(v(t), t)/k, α^2 - v(t)^2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We can \"classify\" this ODE with the method classify_ode function.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> sympy.classify_ode(ex)\n(\"separable\", \"1st_exact\", \"1st_power_series\", \"lie_group\", \"separable_Integral\", \"1st_exact_Integral\")\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"It is linear, but not solvable. Proceeding with dsolve gives:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> u = dsolve(ex, v(t));\n\njulia> println(rhs(u))\n-α/tanh(log(exp(α*(C1*m - 2*k*t)))/(2*m))\n","category":"page"},{"location":"introduction/#Example-2","page":"Examples","title":"Example","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We follow an example from Wolfram, solving first order ODE: y(t) - 3tcdot y(t) = 1:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms y(), a, x\n(y, a, x)\n\njulia> D = Differential(x);\n\njulia> eqn = D(y)(x) - 3*x*y(x) - 1; println(eqn)\n-3*x*y(x) + Derivative(y(x), x) - 1\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We solve the initial value problem with y(0) = 4 as follows:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> x0, y0 = 0, 4\n(0, 4)\n\njulia> ics = Dict(y(x0) => y0);\n\njulia> out = dsolve(eqn, ics = ics);\n\njulia> println(rhs(out))\n(sqrt(6)*sqrt(pi)*erf(sqrt(6)*x/2)/6 + 4)*exp(3*x^2/2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Verifying this requires combining some operations:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> u = rhs(out);\n\njulia> diff(u, x) - 3*x*u - 1\n0\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To solve with a general initial condition is similar:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> x0, y0 = 0, a\n(0, a)\n\njulia> ics = Dict(y(x0) => y0);\n\njulia> out = dsolve(eqn, ics=ics);\n\njulia> println(rhs(out))\n(a + sqrt(6)*sqrt(pi)*erf(sqrt(6)*x/2)/6)*exp(3*x^2/2)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To plot this over a range of values for a we would have:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"@syms a x y() ; nothing # hide\nD = Differential(x); nothing # hide\neqn = D(y)(x) - 3*x*y(x) - 1; nothing #hide\nx0, y0 = 0, a; nothing #hide\nout = dsolve(eqn, ics = (y, x0, y0)); nothing #hide\n\nas = -2:0.6:2\nfna = lambdify(subs(rhs(out), a=>first(as)))\nxs = range(-1.8, 1.8, length=500)\np = plot(xs, fna.(xs), legend=false, ylim=(-4,4))\nfor aᵢ in as[2:end]\n    fni  = lambdify(subs(rhs(out), a=>aᵢ))\n    plot!(p, xs, fni.(xs))\nend\np\nsavefig(\"plot-9.svg\"); nothing #hide","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The comment from the example is \"This plots several integral curves of the equation for different values of a. The plot shows that the solutions have an inflection point if the parameter  lies between -1 and 1 , while a global maximum or minimum arises for other values of a.\"","category":"page"},{"location":"introduction/#Example-3","page":"Examples","title":"Example","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We continue with another example from the Wolfram documentation: solving y + 5y + 6y=0 with values prescribed for both y and y at x_0=0.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms y(), x\n(y, x)\n\njulia> D = Differential(x); D2 = D ∘ D\nDifferential(x) ∘ Differential(x)\n\njulia> eqn = D2(y)(x) + 5D(y)(x) + 6y(x);  println(eqn)\n6*y(x) + 5*Derivative(y(x), x) + Derivative(y(x), (x, 2))\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To solve with y(0) = 1 and y(0) = 1 we have:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> ics=Dict(y(0) => 1, D(y)(0) => 1);\n\njulia> out = dsolve(eqn, ics=ics); println(rhs(out))\n(4 - 3*exp(-x))*exp(-2*x)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To make a plot, we only need the right-hand-side of the answer:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"@syms y() x; nothing #hide\nD = Differential(x); nothing # hide\neqn = D(D(y))(x) + 5D(y)(x) + 6y(x); nothing  #hide\nout = dsolve(eqn, ics=Dict(y(0) => 1, D(y)(0) => 1)); nothing #hide\nplot(rhs(out), -1/3, 2)\nsavefig(\"plot-10.svg\"); nothing  # hide","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"introduction/#Example-4","page":"Examples","title":"Example","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Boundary value problems can be solved for, as well, through a similar syntax. Continuing with examples from the Wolfram page, we solve y(x) +y(x) = e^x over 01 with conditions y(0)=1, y(1) = 12:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> eqn = D(D(y))(x) + y(x) - exp(x); println(eqn)\ny(x) - exp(x) + Derivative(y(x), (x, 2))\n\njulia> ics = Dict(y(0)=>1, y(1) => Sym(1//2));\n\njulia> dsolve(eqn, ics=ics) |> println\nEq(y(x), exp(x)/2 + (-E - cos(1) + 1)*sin(x)/(2*sin(1)) + cos(x)/2)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"note: Note\nThe wrapping of Sym(1//2) is necessary to avoid a premature conversion to floating point when the dictionary, ics, is converted to a Python dictionary by PyCall.","category":"page"},{"location":"introduction/#The-lambdify-function","page":"Examples","title":"The lambdify function","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The Symbolics documentation describes its build_function method as follows: \"build_function is kind of like if lambdify ate its spinach.\" This is true, but what is lambdify in the comparison?","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The SymPy docs say it can transform SymPy expressions to lambda functions which can be used to calculate numerical values very fast.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The typical way to evaluate a symbolic expression at some value and gather the output as a number in Julia would follow this pipeline:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"x |> ex(x) |> N","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The first step requires a conversion of the value in Julia to a Python object, this is handled by PyCall and is essentially zero-cost.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The substitution step, is done within SymPy and runs at the speed of Python.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The last step converts the resulting python object computed by SymPy into a value on the Julia side. The N call is just one way to do this. By default, a mapping takes basic SymPy objects and wraps them in the Sym type for dispatch. The N method makes a Julian numeric type, essentially calling convert(T,x) for a run-time determined type T.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"While two steps are  mostly zero cost, it can be much more performant to create a native Julia function to do the work directly.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The SymPy version in this package does not utilize the underlying SymPy lambdify function, rather it walks the expression tree in SymPy, creates a corresponding Julia expression, and then creates a function in Julia from that.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"To see the creation of an expression, we have:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x; ex = x*sin(x - 2)\nx⋅sin(x - 2)\n\njulia> convert(Expr, ex)\n:(x * sin(-2 + x))\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The sympy.julia_code function is SymPy's means to stringify an expression into Julia code, in combination with Meta.parse, this can also create the expression.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Converting the expression to a function can be done many different ways, some more performant than what is the default with lambdify.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"First, the variables in the expression must be identified, these can be passed in via the vars keyword or will be determined by default with the free_symbols function. The order of the variables is important when calling the create function. Finally, invokelatest is used to create a function object made by combining the variables and the function body.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> l = lambdify(ex);\n\njulia> l(3), ex(3)\n(2.5244129544236893, 3*sin(1))\n","category":"page"},{"location":"introduction/#Using-other-SymPy-modules","page":"Examples","title":"Using other SymPy modules","text":"","category":"section"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The SymPy library has numerous external modules beyond those exposed immediately by SymPy.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> stats = SymPy.PyCall.pyimport_conda(\"sympy.stats\", \"sympy\");\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The stats module holds several probability functions, similar to the Distributions package of Julia. This set of commands creates a normally distributed random variable, X, with symbolic parameters:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms μ, σ::positive;\n\njulia> X = stats.Normal(\"X\", μ, σ)\nX\n\njulia> stats.E(X)\nμ\n\njulia> stats.E(X^2)\n 2    2\nμ  + σ\n\njulia> stats.variance(X)\n 2\nσ\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The methods in the stats module are qualified with the module name above. SymPy provides the import_from function to import all such methods creating functions which dispatch on a symbolic first argument. This is not shown.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Next we see that statements like P(X  mu) can be answered specifying the inequality using Gt in the following:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> stats.P(Gt(X, μ))\n1/2","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"A typical calculation for the normal distribution is the area one or more standard deviations larger than the mean:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> stats.P(Gt(X, μ + 1σ)) |> println\nsqrt(2)*(-sqrt(2)*pi*exp(1/2)*erf(sqrt(2)/2)/2 + sqrt(2)*pi*exp(1/2)/2)*exp(-1/2)/(2*pi)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The familiar  answer could be found by calling N or evalf.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"We show one more distribution, the uniform over ab:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms a::real b::real\n(a, b)\n\njulia> U = stats.Uniform(\"U\", a, b)\nU\n\njulia> stats.E(U) |> simplify |> println\na/2 + b/2\n\njulia> stats.variance(U) |> simplify |> factor |> println\n(a - b)^2/12","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Not all modules are so simple to incorporate. PyCall does a good job of converting the arguments from Julia to Python, but the conversion from a Python (SymPy) structure back to a workable Julia structure can require some massaging.","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"For example, the return value of solveset offers a challenge:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms x\n(x,)\n\njulia> u = solveset(x^2 - 2, x)\n{-√2, √2}","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Here u has the Python class FiniteSet:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> u.__class__\nPyObject <class 'sympy.sets.sets.FiniteSet'>\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"PyCall is instructed in SymPy to map SymPy objects as Sym objects, so FiniteSet is only relevant when the object is being interacted with using Julia methods, Here collect will fail on u, but Set will work with splatting, as the finite set is iterable. This set can then be collected:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> collect(Set(u...))\n2-element Vector{Any}:\n -√2\n  √2\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The output of many integration problems is a piecewise function:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> @syms n::integer x::real\n(n, x)\n\njulia> u = integrate(x^n, x)\n⎧ n + 1\n⎪x\n⎪──────  for n ≠ -1\n⎨n + 1\n⎪\n⎪log(x)  otherwise\n⎩\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"The conversion to a Julia object is a bit cumbersome, in the following we work through the args of the expression and pull our the condition and arguments as an underlying ExprCondPair in SymPy for which cond and args are useful properties:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"julia> [c.cond => c.args for c ∈ u.args]\n2-element Vector{Pair{Sym, Tuple{Sym, Sym}}}:\n Ne(n, -1) => (x^(n + 1)/(n + 1), Ne(n, -1))\n      True => (log(x), True)\n","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Such is not automated. However some conversions are. PyCall allows the definition of a mapping between a python type and a Julia type (pytype_mapping). By default, python objects with class sympy_core.basic.Basic are mapped to Sym objects in Julia, a simple wrapper to control dispatch. More germaine to this example, the combinatorics module is imported by default in SymPy. It required managing the automatic mapping of types so that different dispatch rules could be used to follow the syntax of the module. The rules were:","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"pytype_mapping(sympy.combinatorics.permutations.Permutation, SymPermutation)\npytype_mapping(combinatorics.perm_groups.PermutationGroup, SymPermutationGroup)","category":"page"},{"location":"introduction/","page":"Examples","title":"Examples","text":"Here, SymPermutation and SymPermutationGroup are subtypes of the abstract SymbolicObject type.","category":"page"},{"location":"Tutorial/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Taken from the  SymPy tutorial (version 1.3).","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"using SymPy\nsympy.init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/intro/#What-is-Symbolic-Computation?","page":"Introduction","title":"What is Symbolic Computation?","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Symbolic computation deals with the computation of mathematical objects symbolically.  This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Let's take an example. Say we wanted to use the built-in Python functions to compute square roots. We might do something like this","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> import math\n   >>> math.sqrt(9)\n   3.0","category":"page"},{"location":"Tutorial/intro/#In-Julia:","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Of course, sqrt is already there:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> sqrt(9)\n3.0","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"9 is a perfect square, so we got the exact answer, 3. But suppose we computed the square root of a number that isn't a perfect square","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> math.sqrt(8)\n   2.82842712475","category":"page"},{"location":"Tutorial/intro/#In-Julia:-2","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> sqrt(8)\n2.8284271247461903","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Here we got an approximate result. 2.82842712475 is not the exact square root of 8 (indeed, the actual square root of 8 cannot be represented by a finite decimal, since it is an irrational number).  If all we cared about was the decimal form of the square root of 8, we would be done.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"But suppose we want to go further. Recall that sqrt8 = sqrt4cdot 2 = 2sqrt2.  We would have a hard time deducing this from the above result. This is where symbolic computation comes in.  With a symbolic computation system like SymPy, square roots of numbers that are not perfect squares are left unevaluated by default","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> import sympy\n   >>> sympy.sqrt(3)\n   sqrt(3)","category":"page"},{"location":"Tutorial/intro/#In-Julia:-3","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> using SymPy\n\njulia> sympy.sqrt(3)\n√3","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"When SymPy is loaded, the sqrt function is overloaded for symbolic objects, so this could also be done through:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> sqrt(Sym(3))\n√3","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Furthermore–-and this is where we start to see the real power of symbolic computation–-symbolic results can be symbolically simplified.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> sympy.sqrt(8)\n   2*sqrt(2)","category":"page"},{"location":"Tutorial/intro/#In-Julia:-4","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> sympy.sqrt(8)\n2⋅√2","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/#A-More-Interesting-Example","page":"Introduction","title":"A More Interesting Example","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"The above example starts to show how we can manipulate irrational numbers exactly using SymPy.  But it is much more powerful than that.  Symbolic computation systems (which by the way, are also often called computer algebra systems, or just CASs) such as SymPy are capable of computing symbolic expressions with variables.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"As we will see later, in SymPy, variables are defined using symbols. Unlike many symbolic manipulation systems, variables in SymPy must be defined before they are used (the reason for this will be discussed in the :ref:next section <tutorial-gotchas-symbols>).","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Let us define a symbolic expression, representing the mathematical expression x + 2y.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> from sympy import symbols\n   >>> x, y = symbols('x y')\n   >>> expr = x + 2*y\n   >>> expr\n   x + 2*y","category":"page"},{"location":"Tutorial/intro/#In-Julia:-5","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"the command from sympy import * is essentially run (only functions are \"imported\", not all objects), so this becomes the same after adjusting the quotes:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> @syms x, y\n(x, y)\n\njulia> expr = x + 2*y\nx + 2⋅y","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Note that we wrote x + 2*y just as we would if x and y were ordinary Python variables. But in this case, instead of evaluating to something, the expression remains as just x + 2*y.  Now let us play around with it:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> expr + 1\n   x + 2*y + 1\n   >>> expr - x\n   2*y","category":"page"},{"location":"Tutorial/intro/#In-Julia:-6","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> expr + 1\nx + 2⋅y + 1","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> expr - x\n2⋅y","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Notice something in the above example.  When we typed expr - x, we did not get x + 2*y - x, but rather just 2*y.  The x and the -x automatically canceled one another.  This is similar to how sqrt(8) automatically turned into 2*sqrt(2) above.  This isn't always the case in SymPy, however:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> x*expr\n   x*(x + 2*y)","category":"page"},{"location":"Tutorial/intro/#In-Julia:-7","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> x*expr\nx⋅(x + 2⋅y)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Here, we might have expected x(x + 2y) to transform into x^2 + 2xy, but instead we see that the expression was left alone.  This is a common theme in SymPy.  Aside from obvious simplifications like x - x = 0 and \\sqrt{8} = 2\\sqrt{2}, most simplifications are not performed automatically.  This is because we might prefer the factored form x(x + 2y), or we might prefer the expanded form x^2 + 2xy.  Both forms are useful in different circumstances. In SymPy, there are functions to go from one form to the other","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> from sympy import expand, factor\n   >>> expanded_expr = expand(x*expr)\n   >>> expanded_expr\n   x**2 + 2*x*y\n   >>> factor(expanded_expr)\n   x*(x + 2*y)","category":"page"},{"location":"Tutorial/intro/#In-Julia:-8","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> expanded_expr = expand(x*expr)\n 2\nx  + 2⋅x⋅y","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> factor(expanded_expr)\nx⋅(x + 2⋅y)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/#The-Power-of-Symbolic-Computation","page":"Introduction","title":"The Power of Symbolic Computation","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"The real power of a symbolic computation system such as SymPy is the ability to do all sorts of computations symbolically.  SymPy can simplify expressions, compute derivatives, integrals, and limits, solve equations, work with matrices, and much, much more, and do it all symbolically.  It includes modules for plotting, printing (like 2D pretty printed output of math formulas, or \\LaTeX), code generation, physics, statistics, combinatorics, number theory, geometry, logic, and more. Here is a small sampling of the sort of symbolic power SymPy is capable of, to whet your appetite.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> from sympy import *\n >>> x, t, z, nu = symbols('x t z nu')","category":"page"},{"location":"Tutorial/intro/#In-Julia:-9","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"again, the functions in the sympy module are already imported:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> @syms x, t, z, nu\n(x, t, z, nu)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"This will make all further examples pretty print with unicode characters.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/intro/#In-Julia:-10","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"The printing in Julia is controlled by show and the appropriate MIME type.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Take the derivative of sin(x)e^x.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> diff(sin(x)*exp(x), x)\n  x           x\n ℯ ⋅sin(x) + ℯ ⋅cos(x)","category":"page"},{"location":"Tutorial/intro/#In-Julia:-11","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> diff(sin(x)*exp(x), x)\n x           x\nℯ ⋅sin(x) + ℯ ⋅cos(x)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Compute int(e^xsin(x) + e^xcos(x))dx.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> integrate(exp(x)*sin(x) + exp(x)*cos(x), x)\n  x\n ℯ ⋅sin(x)","category":"page"},{"location":"Tutorial/intro/#In-Julia:-12","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> integrate(exp(x)*sin(x) + exp(x)*cos(x), x)\n x\nℯ ⋅sin(x)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Compute int_-infty^infty sin(x^2)dx.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> integrate(sin(x**2), (x, -oo, oo))\n √2⋅√π\n ─────\n   2","category":"page"},{"location":"Tutorial/intro/#In-Julia:-13","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"In Julia ** is ^:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> integrate(sin(x^2), (x, -oo, oo))\n√2⋅√π\n─────\n  2","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Find lim_xto 0fracsin(x)x.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> limit(sin(x)/x, x, 0)\n 1","category":"page"},{"location":"Tutorial/intro/#In-Julia:-14","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> limit(sin(x)/x, x, 0)\n1","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Solve x^2 - 2 = 0.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> solve(x**2 - 2, x)\n [-√2, √2]","category":"page"},{"location":"Tutorial/intro/#In-Julia:-15","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> solve(x^2 - 2, x)\n2-element Vector{Sym}:\n -√2\n  √2","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Solve the differential equation y'' - y = e^t.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> y = Function('y')\n >>> dsolve(Eq(y(t).diff(t, t) - y(t), exp(t)), y(t))\n            -t   ⎛     t⎞  t\n y(t) = C₂⋅ℯ   + ⎜C₁ + ─⎟⋅ℯ\n                 ⎝     2⎠","category":"page"},{"location":"Tutorial/intro/#In-Julia:-16","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Function is not a function, so is not exported. We must qualify its use:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> y = sympy.Function(\"y\")\nPyObject y\n\njulia> dsolve(Eq(y(t).diff(t, t) - y(t), exp(t)), y(t)) |> string # work around formatting issue\n\"Eq(y(t), C2*exp(-t) + (C1 + t/2)*exp(t))\"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"note: Why `string`?\nThe uses of |> string above and elsewhere throughout  this translation  of  the SymPy tutorial is only for technical reasons  related to  how Documenter.jl parses  the output. It is not idiomatic, or suggested; it  only allows the cell  to  be tested programatically for  regressions.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"This is made more familiar looking with the SymFunction class:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> y = SymFunction(\"y\")\ny\n\njulia> D = Differential(t);\n\njulia> dsolve(D(D(y))(t) - y(t) - exp(t), y(t)) |> string\n\"Eq(y(t), C2*exp(-t) + (C1 + t/2)*exp(t))\"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Even more so, @syms allows the specification of symbolic functions, as follows:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> @syms y()::real t\n(y, t)\n\njulia> dsolve(D(D(y))(t) - y(t) - exp(t), y(t)) |> string\n\"Eq(y(t), C2*exp(-t) + (C1 + t/2)*exp(t))\"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Find the eigenvalues of \\left[\\begin{smallmatrix}1 & 2\\\\2 & 2\\end{smallmatrix}\\right].","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> Matrix([[1, 2], [2, 2]]).eigenvals()\n ⎧3   √17       √17   3   ⎫\n ⎨─ + ───: 1, - ─── + ─: 1⎬\n ⎩2    2         2    2   ⎭","category":"page"},{"location":"Tutorial/intro/#In-Julia:-17","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Like Function, Matrix is not imported and its use must by qualified (Julia matrix conventions  are used):","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> out = sympy.Matrix([1 2; 2 2]).eigenvals();\n\njulia> sort(collect(keys(out)))\n2-element Vector{Any}:\n 3/2 - sqrt(17)/2\n 3/2 + sqrt(17)/2","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"(The keys are returned  as type  Any, they may format more nicely if converted, say, through  convert(Dict{Sym,Sym},out).)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Rewrite the Bessel function J_nuleft(zright) in terms of the spherical Bessel function j_nu(z).","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"  >>> besselj(nu, z).rewrite(jn)\n  √2⋅√z⋅jn(ν - 1/2, z)\n  ────────────────────\n           √π","category":"page"},{"location":"Tutorial/intro/#In-Julia:-18","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"we need to call in SpecialFunctions\njn is imported as a function object and this is not what SymPy expects, instead we pass in the object sympy.jn","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> using SpecialFunctions\n\n\njulia> @syms ν z\n(ν, z)\n\njulia> besselj(ν, z).rewrite(sympy.jn)\n√2⋅√z⋅jn(ν - 1/2, z)\n────────────────────\n         √π","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Print int_0^pi cos^2left (x right ) dx using LaTeX.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"  >>> latex(Integral(cos(x)**2, (x, 0, pi)))\n  \\int_{0}^{\\pi} \\cos^{2}{\\left (x \\right )}\\, dx","category":"page"},{"location":"Tutorial/intro/#In-Julia:-19","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Latex printing occurs when the mime type is requested. However, the latex function can be called directly. However, this is not imported by default to avoid name collisions, and so must be qualified. Below, the latex is output as a string, though\nIntegral, like Function and Matrix is not a function and must be qualified\n** must become ^\nand we use  PI, an alias for sympy.pi, the symbolic value for pi:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"julia> sympy.latex(sympy.Integral(cos(x)^2, (x, 0, PI)))\n\"\\\\int\\\\limits_{0}^{\\\\pi} \\\\cos^{2}{\\\\left(x \\\\right)}\\\\, dx\"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/#Why-SymPy?","page":"Introduction","title":"Why SymPy?","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"There are many computer algebra systems out there.  This <http://en.wikipedia.org/wiki/List_of_computer_algebra_systems>_ Wikipedia article lists many of them.  What makes SymPy a better choice than the alternatives?","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"First off, SymPy is completely free. It is open source, and licensed under the liberal BSD license, so you can modify the source code and even sell it if you want to.  This contrasts with popular commercial systems like Maple or Mathematica that cost hundreds of dollars in licenses.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Second, SymPy uses Python.  Most computer algebra systems invent their own language. Not SymPy. SymPy is written entirely in Python, and is executed entirely in Python. This means that if you already know Python, it is much easier to get started with SymPy, because you already know the syntax (and if you don't know Python, it is really easy to learn).  We already know that Python is a well-designed, battle-tested language.  The SymPy developers are confident in their abilities in writing mathematical software, but programming language design is a completely different thing.  By reusing an existing language, we are able to focus on those things that matter: the mathematics.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Another computer algebra system, Sage also uses Python as its language.  But Sage is large, with a download of over a gigabyte.  An advantage of SymPy is that it is lightweight.  In addition to being relatively small, it has no dependencies other than Python, so it can be used almost anywhere easily. Furthermore, the goals of Sage and the goals of SymPy are different.  Sage aims to be a full featured system for mathematics, and aims to do so by compiling all the major open source mathematical systems together into one. When you call some function in Sage, such as integrate, it calls out to one of the open source packages that it includes.  In fact, SymPy is included in Sage.  SymPy on the other hand aims to be an independent system, with all the features implemented in SymPy itself.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"A final important feature of SymPy is that it can be used as a library. Many computer algebra systems focus on being usable in interactive environments, but if you wish to automate or extend them, it is difficult to do.  With SymPy, you can just as easily use it in an interactive Python environment or import it in your own Python application.  SymPy also provides APIs to make it easy to extend it with your own custom functions.","category":"page"},{"location":"Tutorial/intro/#In-Julia:-20","page":"Introduction","title":"In Julia:","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"There are other symbolic packages for Julia:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"ModelingToolkit.jl\nReduce.jl\nSymata.jl\nSymEngine.jl\nNemo.jl\nSymbolicUtils","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"SymPy is an attractive alternative as PyCall makes most all of its functinality directly available and SymPy is fairly feature rich.","category":"page"},{"location":"#SymPy.jl","page":"Home","title":"SymPy.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia package SymPy uses the PyCall package to interface Julia with the underlying SymPy Python package. SymPy (http://sympy.org/) is a Python library for symbolic mathematics. The Symbolics package for Julia provides an alternative with some compelling performance improvements, though is not nearly as feature rich as the underlying SymPy Python library.","category":"page"},{"location":"#Using-Python's-SymPy-with-PyCall","page":"Home","title":"Using Python's SymPy with PyCall","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PyCall package does the heavy lifting for SymPy. In fact, this package can be skipped altogether, if so inclined. For example, we can import the underlying Python module as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PyCall\n\njulia> sympy = pyimport(\"sympy\")\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using the dot-call notation of Python, we can create a symbolic variable, and a symbolic expression:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = sympy.symbols(\"x\")\nPyObject x\n\njulia> y = sympy.sin(x)\nPyObject sin(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The symbolic expression can be evaluated at a symbolic value returning an object accessible via pycall. In the following, this is then converted to a floating point number in Julia:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> z = y.subs(x, sympy.pi)\nPyObject 0\n\njulia> convert(Float64, z)\n0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further, some arithmetic operations are already available, for example multiplication and powers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> y = sympy.sin(sympy.pi * x)^2 # ^ in Julia, ** in Python\nPyObject sin(pi*x)**2\n\njulia> z = y.subs(x,2)\nPyObject 0","category":"page"},{"location":"#Using-SymPy-with-SymPy","page":"Home","title":"Using SymPy with SymPy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SymPy package provides a more Julian interface to such tasks;","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SymPy\nWARNING: using SymPy.sympy in module Main conflicts with an existing identifier.\n\njulia> @syms x\n(x,)\n\njulia> ex = sin(pi*x)^2     # generic method overload\n   2\nsin (π⋅x)\n\njulia> z = ex(x => 1) # Julia style, use ex.subs((x, PI)) for Python style\n0\n\njulia> N(z)            # z refers to a python value; N converts this symbolic number to a number in Julia\n0","category":"page"},{"location":"","page":"Home","title":"Home","text":"As seen in the warning, the SymPy package also exposes the underlying sympy module. In addition, the basic usage follows these points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"generic methods from Julia and imported functions in the sympy namespace are called through fn(object). Method overloading for basic generics usually expects the first argument to be symbolic for dispatch.\nSymPy methods of an object are called through Python's dot-call syntax: object.fn(...).\nConstructors, like sympy.Symbol, and other non-function calls from sympy are qualified with sympy.Constructor(...). Such qualified calls are also useful when the first argument is not symbolic.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed through the usual means (using SymPy or add SymPy).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation of the package will also install PyCall, if needed; a python interpreter, if needed; and then use the Conda package to install the underlying SymPy library, if needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the Conda installation, the following commands can be used to update the underlying python library:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Conda  # may need to be installed\nConda.update()","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nIf installation does not work, there may be a conflict with another python installation. There have been reports for Mac OS systems that a Conda installed python and a brew installed python do not work well together, with the solution being to delete the brew installed version.","category":"page"}]
}
